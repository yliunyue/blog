/*
 Navicat MySQL Data Transfer

 Source Server         : localhost_3306
 Source Server Type    : MySQL
 Source Server Version : 80018
 Source Host           : localhost:3306
 Source Schema         : blog

 Target Server Type    : MySQL
 Target Server Version : 80018
 File Encoding         : 65001

 Date: 31/07/2023 10:32:01
*/

SET NAMES utf8mb4;
SET FOREIGN_KEY_CHECKS = 0;

-- ----------------------------
-- Table structure for ms_admin
-- ----------------------------
DROP TABLE IF EXISTS `ms_admin`;
CREATE TABLE `ms_admin`  (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `username` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL,
  `password` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 7 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_unicode_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of ms_admin
-- ----------------------------
INSERT INTO `ms_admin` VALUES (1, 'admin', '$2a$10$.U1dhb1UWXV9mobhR4RkM.aBUHKhocOdmToeBNJANgiH8CquJevXS');
INSERT INTO `ms_admin` VALUES (2, 'mszlu', '$2a$10$RZECQ90DjOT/t1mhnXsl5.XSuZWc0Sa1XduPxj2rb4yaSYcje3nWW');
INSERT INTO `ms_admin` VALUES (3, 'zzz', '$2a$10$Ex4AEiDOKypZ3cLqLnIAeOGbMIoGBYxz9//xoymYlqbG37fSBm5f6');

-- ----------------------------
-- Table structure for ms_admin_permission
-- ----------------------------
DROP TABLE IF EXISTS `ms_admin_permission`;
CREATE TABLE `ms_admin_permission`  (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `admin_id` bigint(20) NOT NULL,
  `permission_id` bigint(20) NOT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 8 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_unicode_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of ms_admin_permission
-- ----------------------------
INSERT INTO `ms_admin_permission` VALUES (1, 1, 1);
INSERT INTO `ms_admin_permission` VALUES (2, 2, 1);
INSERT INTO `ms_admin_permission` VALUES (3, 1, 2);
INSERT INTO `ms_admin_permission` VALUES (6, 3, 1);
INSERT INTO `ms_admin_permission` VALUES (7, 3, 8);

-- ----------------------------
-- Table structure for ms_adminfeed
-- ----------------------------
DROP TABLE IF EXISTS `ms_adminfeed`;
CREATE TABLE `ms_adminfeed`  (
  `id` int(8) NOT NULL AUTO_INCREMENT,
  `feedback_id` int(8) NULL DEFAULT NULL,
  `create_date` datetime NULL DEFAULT NULL ON UPDATE CURRENT_TIMESTAMP,
  `content` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `admin_name` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 9 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of ms_adminfeed
-- ----------------------------
INSERT INTO `ms_adminfeed` VALUES (3, 1, '2023-03-31 21:52:30', '感谢您的反馈，我们会尽快解决', '系统管理员');
INSERT INTO `ms_adminfeed` VALUES (6, 1, '2023-04-13 18:01:24', NULL, '系统管理员');
INSERT INTO `ms_adminfeed` VALUES (7, 1, '2023-04-13 18:04:25', NULL, '系统管理员');
INSERT INTO `ms_adminfeed` VALUES (8, 1, '2023-04-13 18:18:28', '您的反馈aaaa', '系统管理员');
INSERT INTO `ms_adminfeed` VALUES (9, 2, '2023-05-20 01:49:45', '感谢您的反馈，我们会尽快解决', '系统管理员');

-- ----------------------------
-- Table structure for ms_answer
-- ----------------------------
DROP TABLE IF EXISTS `ms_answer`;
CREATE TABLE `ms_answer`  (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `user_id` bigint(20) NOT NULL,
  `question_id` int(11) NOT NULL,
  `content` longtext CHARACTER SET utf8 COLLATE utf8_general_ci NULL,
  `create_date` bigint(20) NULL DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 7 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of ms_answer
-- ----------------------------
INSERT INTO `ms_answer` VALUES (3, 1, 5, '网上一搜一大把', 1680267842570);
INSERT INTO `ms_answer` VALUES (4, 1646173406938275841, 7, 'bean的生命周期大致分为实例化-属性赋值', 1681313477686);
INSERT INTO `ms_answer` VALUES (6, 1658815292421292033, 10, '使用Executors创建线程池可能存在以下问题：  线程池大小控制不够灵活，无法直接设置线程池的大小。 默认情况下，Executors使用无界任务队列，可能导致任务积压过多。 没有明确的拒绝策略，可能导致任务被拒绝执行而无法处理。 隐藏了线程池的内部实现细节，无法针对具体需求进行优化和调整。 因此，建议使用ThreadPoolExecutor类手动创建线程池，以便更好地控制线程池的大小、任务队列的选择、拒绝策略等，以适应具体的应用场景和需求。', 1684499475994);

-- ----------------------------
-- Table structure for ms_article
-- ----------------------------
DROP TABLE IF EXISTS `ms_article`;
CREATE TABLE `ms_article`  (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `comment_counts` int(11) NULL DEFAULT NULL COMMENT '评论数量',
  `create_date` bigint(20) NULL DEFAULT NULL COMMENT '创建时间',
  `summary` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '简介',
  `title` varchar(64) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '标题',
  `view_counts` int(11) NULL DEFAULT NULL COMMENT '浏览数量',
  `weight` int(11) NOT NULL COMMENT '是否置顶',
  `author_id` bigint(20) NULL DEFAULT NULL COMMENT '作者id',
  `body_id` bigint(20) NULL DEFAULT NULL COMMENT '内容id',
  `category_id` int(11) NULL DEFAULT NULL COMMENT '类别id',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 1659724221955276802 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of ms_article
-- ----------------------------
INSERT INTO `ms_article` VALUES (1, 0, 1621947720727, '通过Spring Boot实现的服务，只需要依靠一个Java类，把它打包成jar，并通过`java -jar`命令就可以运行起来。\r\n\r\n这一切相较于传统Spring应用来说，已经变得非常的轻便、简单。', 'springboot介绍以及入门案例', 146, 0, 1, 1, 2);
INSERT INTO `ms_article` VALUES (9, 0, 1613947720727, 'Vue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的渐进式框架。', 'Vue.js 到底是什么', 8, 0, 1, 20, 2);
INSERT INTO `ms_article` VALUES (10, 0, 1523947720727, '本节将介绍如何在项目中使用 Element。', 'Element相关', 14, 0, 1, 21, 2);
INSERT INTO `ms_article` VALUES (1405916999732707330, 0, 1624031708047, 'springboot入门案例', 'SpringBoot入门案例', 40, 0, 1, 1405916999854342146, 2);
INSERT INTO `ms_article` VALUES (1622156649005326338, 0, 1675587257992, '关于springboot你不知道的特点', '有关springboot框架你不知道的事', 21, 0, 1, 1622156649072435203, 2);
INSERT INTO `ms_article` VALUES (1622157820797394946, 1, 1675587537382, '关于springboot你不知道的特点', '有关springboot框架你不知道的事', 48, 0, 1, 1622157820864503810, 2);
INSERT INTO `ms_article` VALUES (1658757309691707394, 0, 1684313535503, '线程', '线程执行顺序', 8, 0, 1658756096623493121, 1658757559055663105, 2);
INSERT INTO `ms_article` VALUES (1658759520274464770, 1, 1684314062556, '锁内容', 'synchronized和Lock的区别', 2, 0, 1658756096623493121, 1658759520337379330, 2);
INSERT INTO `ms_article` VALUES (1658761194200219649, 1, 1684314461646, 'net技术', '.NET6项目连接数据库方式方法 ', 1, 0, 1658759848361312257, 1658761194200219651, 2);
INSERT INTO `ms_article` VALUES (1658761730190327810, 0, 1684314589450, 'net', 'VB.NET 截取字符串', 1, 0, 1658759848361312257, 1658761730257436674, 2);
INSERT INTO `ms_article` VALUES (1658763647515738114, 0, 1684315046573, 'java面试', 'Java中打印对象输出的字符串到底是什么', 3, 0, 1658759848361312257, 1658763647582846978, 2);
INSERT INTO `ms_article` VALUES (1658764793500254210, 0, 1684315319802, 'vue 基于原生动画的自动滚动表格', 'vue 基于原生动画的自动滚动表格', 1, 0, 1658759848361312257, 1658764793571557378, 1);
INSERT INTO `ms_article` VALUES (1658766617233965058, 0, 1684315754612, '排序面试', 'java排序算法3(冒泡排序、) ', 1, 0, 1658759848361312257, 1658766617301073922, 7);
INSERT INTO `ms_article` VALUES (1658768565064548353, 0, 1684316219009, '排序算法', 'java排序算法2（简单选择排序、堆排序）', 1, 0, 1658759848361312257, 1658768565131657219, 7);
INSERT INTO `ms_article` VALUES (1658770056324169729, 0, 1684316574551, '排序算法', 'java排序算法1（插入排序、希尔排序）', 2, 0, 1658759848361312257, 1658770056391278593, 7);
INSERT INTO `ms_article` VALUES (1658772080889544706, 0, 1684317057247, 'swagger', 'swagger使用教程——快速使用swagger', 1, 0, 1658756096623493121, 1658772080956653571, 2);
INSERT INTO `ms_article` VALUES (1658774222585053186, 0, 1684317567859, '前端基础', 'HTML常用标签', 1, 0, 1658756096623493121, 1658774222647967746, 1);
INSERT INTO `ms_article` VALUES (1658776284639117314, 0, 1684318059489, '数据库事务', ' MySQL事务一文搞懂', 1, 0, 1658756096623493121, 1658776284639117316, 4);
INSERT INTO `ms_article` VALUES (1658781189672124417, 0, 1684319228952, 'mysql', ' DQL语句（一） -----简单select查询 ', 1, 0, 1658756096623493121, 1658781189735038979, 4);
INSERT INTO `ms_article` VALUES (1658806949472485377, 0, 1684325370564, 'jquery', 'jQuery', 2, 0, 1658756096623493121, 1658806949535399938, 1);
INSERT INTO `ms_article` VALUES (1658816190316920833, 0, 1684327573750, 'jvm', '深入浅出JVM调优，看完你就懂', 1, 0, 1658815292421292033, 1658816190384029698, 12);
INSERT INTO `ms_article` VALUES (1658818233379176450, 0, 1684328060850, 'jquery', '基于jQuery的三种AJAX请求', 1, 0, 1658815292421292033, 1658818233442091010, 1);
INSERT INTO `ms_article` VALUES (1658819577250955265, 0, 1684328381262, '设计模式，工厂模式', '工厂模式', 1, 0, 1658815292421292033, 1658819577318064131, 13);
INSERT INTO `ms_article` VALUES (1658819789432406017, 0, 1684328431839, '抽象工厂模式', '抽象工厂模式', 1, 0, 1658815292421292033, 1658819789432406019, 13);
INSERT INTO `ms_article` VALUES (1658820077463650306, 0, 1684328500511, 'jvm面试', 'jvm面试题', 1, 0, 1658815292421292033, 1658820077463650308, 12);
INSERT INTO `ms_article` VALUES (1658820246859005953, 0, 1684328540904, 'mysql面试题', 'mysql面试题', 1, 0, 1658815292421292033, 1658820246917726210, 4);
INSERT INTO `ms_article` VALUES (1658820406947201026, 0, 1684328579069, 'redis', 'redis面试题1', 2, 0, 1658815292421292033, 1658820406947201028, 4);
INSERT INTO `ms_article` VALUES (1658820724711866370, 0, 1684328654838, 'springBoot入门程序开发', 'springBoot入门程序开发', 1, 0, 1658815292421292033, 1658820724778975234, 2);
INSERT INTO `ms_article` VALUES (1658821020066365442, 0, 1684328725255, '2.springboot简介pom解析', 'springboot简介pom解析', 1, 0, 1658815292421292033, 1658821020133474307, 2);
INSERT INTO `ms_article` VALUES (1658821135468445698, 0, 1684328752766, 'springboot整合junit', 'springboot整合junit', 1, 0, 1658815292421292033, 1658821135531360257, 2);
INSERT INTO `ms_article` VALUES (1658822003743899649, 0, 1684328959773, 'mybatis简介', 'mybatis简介', 1, 0, 1658759848361312257, 1658822003743899651, 2);
INSERT INTO `ms_article` VALUES (1658822244211736578, 0, 1684329017110, '7.2 Mybatis快速入门', '7.2 Mybatis快速入门', 1, 0, 1658759848361312257, 1658822244262068227, 2);
INSERT INTO `ms_article` VALUES (1658822614287761409, 0, 1684329105341, 'linux', 'linux', 1, 0, 1658759848361312257, 1658822614287761411, 16);
INSERT INTO `ms_article` VALUES (1658822869255307265, 0, 1684329166126, 'EL和JSTL', 'EL和JSTL', 1, 0, 1658759848361312257, 1658822869255307267, 1);
INSERT INTO `ms_article` VALUES (1658822996493713410, 0, 1684329196470, '2.JSTL标签工具类', 'JSTL标签工具类', 1, 0, 1658759848361312257, 1658822996560822274, 1);
INSERT INTO `ms_article` VALUES (1658823734083043330, 0, 1684329372327, 'SQL和NoSQL.pn', '1.初识redisd', 1, 0, 1658759848361312257, 1658823734150152194, 4);
INSERT INTO `ms_article` VALUES (1658824196089823234, 3, 1684329482482, '2.redis常见命令', '2.redis常见命令', 4, 0, 1658759848361312257, 1658824196156932099, 4);
INSERT INTO `ms_article` VALUES (1658826393972228098, 0, 1684330006488, 'Java面向对象进阶第一天', 'Java面向对象进阶第一天', 1, 0, 1658759848361312257, 1658826394043531265, 13);
INSERT INTO `ms_article` VALUES (1658827199270207489, 0, 1684330198485, 'Ubuntu忘记密码(五个小步骤)', 'Ubuntu忘记密码(五个小步骤)', 1, 0, 1658759848361312257, 1658827199270207491, 16);
INSERT INTO `ms_article` VALUES (1658827734752804866, 1, 1684330326164, 'CentOS安装Docker', 'CentOS安装Docker', 2, 0, 1658756096623493121, 1658827734819913731, 16);
INSERT INTO `ms_article` VALUES (1658828931769417730, 0, 1684330611547, 'Android Studio相关问题 ', 'Android Studio相关问题 ', 6, 0, 1658756096623493121, 1658829123264561155, 14);
INSERT INTO `ms_article` VALUES (1658830019813818369, 0, 1684330870957, 'sVue', 'Vue', 11, 0, 1658756096623493121, 1658830019876732930, 1);
INSERT INTO `ms_article` VALUES (1659724221955276802, 1, 1684544065349, '发顺丰', 'hkfda ', 1, 0, 1, 1659724222093688833, 7);

-- ----------------------------
-- Table structure for ms_article_body
-- ----------------------------
DROP TABLE IF EXISTS `ms_article_body`;
CREATE TABLE `ms_article_body`  (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `content` longtext CHARACTER SET utf8 COLLATE utf8_general_ci NULL,
  `content_html` longtext CHARACTER SET utf8 COLLATE utf8_general_ci NULL,
  `article_id` bigint(20) NOT NULL,
  PRIMARY KEY (`id`) USING BTREE,
  INDEX `article_id`(`article_id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 1659724222093688833 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of ms_article_body
-- ----------------------------
INSERT INTO `ms_article_body` VALUES (1, '# 1. Spring Boot介绍\r\n\r\n## 1.1 简介\r\n\r\n在您第1次接触和学习Spring框架的时候，是否因为其繁杂的配置而退却了？\r\n\r\n在你第n次使用Spring框架的时候，是否觉得一堆反复黏贴的配置有一些厌烦？\r\n\r\n那么您就不妨来试试使用Spring Boot来让你更易上手，更简单快捷地构建Spring应用！\r\n\r\nSpring Boot让我们的Spring应用变的更轻量化。\r\n\r\n我们不必像以前那样繁琐的构建项目、打包应用、部署到Tomcat等应用服务器中来运行我们的业务服务。\r\n\r\n通过Spring Boot实现的服务，只需要依靠一个Java类，把它打包成jar，并通过`java -jar`命令就可以运行起来。\r\n\r\n这一切相较于传统Spring应用来说，已经变得非常的轻便、简单。\r\n\r\n**总结一下Spring Boot的主要优点：**\r\n\r\n1. 为所有Spring开发者更快的入门\r\n2. 开箱即用，提供各种默认配置来简化项目配置\r\n3. 内嵌式容器简化Web项目\r\n4. 没有冗余代码生成和XML配置的要求\r\n5. 统一的依赖管理\r\n6. 自动装配，更易使用，更易扩展\r\n\r\n## 1.2 使用版本说明\r\n\r\nSpringboot版本：使用最新的2.5.0版本\r\n\r\n教程参考了官方文档进行制作，权威。\r\n\r\n其他依赖版本：\r\n\r\n	1. Maven  需求：3.5+\r\n\r\n   	2. JDK 需求  8+\r\n   	3. Spring Framework 5.3.7以上版本\r\n   	4. Tomcat 9.0\r\n   	5. Servlet版本 4.0  但是可以部署到Servlet到3.1+的容器中\r\n\r\n# 2. 快速入门\r\n\r\n快速的创建一个Spring Boot应用，并且实现一个简单的Http请求处理。通过这个例子对Spring Boot有一个初步的了解，并体验其结构简单、开发快速的特性。\r\n\r\n教程使用的Idea版本：2019.3\r\n\r\n## 2.1 创建基础项目\r\n\r\n**第一步：** 创建maven项目\r\n\r\npom.xml :\r\n\r\n~~~xml\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\r\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\r\n    <modelVersion>4.0.0</modelVersion>\r\n\r\n    <groupId>com.xiaopizhu</groupId>\r\n    <artifactId>helloSpringBoot</artifactId>\r\n    <version>1.0-SNAPSHOT</version>\r\n	<!--springboot的父工程其中定义了常用的依赖，并且无依赖冲突-->\r\n    <parent>\r\n        <groupId>org.springframework.boot</groupId>\r\n        <artifactId>spring-boot-starter-parent</artifactId>\r\n        <version>2.5.0</version>\r\n    </parent>\r\n</project>\r\n~~~\r\n\r\n注意上方的parent必须加，其中定义了springboot官方支持的n多依赖，基本上常用的已经有了，所以接下来导入依赖的时候，绝大部分都可以不加版本号。\r\n\r\n此时的工程结构为：\r\n\r\n![image-20210523173241557](img/image-20210523173241557.png)\r\n\r\n**第二步：** 添加web依赖\r\n\r\n~~~xml\r\n<dependencies>\r\n    <dependency>\r\n        <groupId>org.springframework.boot</groupId>\r\n        <artifactId>spring-boot-starter-web</artifactId>\r\n    </dependency>\r\n</dependencies>\r\n~~~\r\n\r\n添加上方的web依赖，其中间接依赖了spring-web，spring-webmvc，spring-core等spring和springmvc的包，并且集成了tomcat。\r\n\r\n**第三步：** 编写启动类\r\n\r\n~~~java\r\npackage com.xiaopizhu.springboot;\r\n\r\nimport org.springframework.boot.SpringApplication;\r\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\r\n\r\n@SpringBootApplication\r\npublic class HelloApp {\r\n\r\n    public static void main(String[] args) {\r\n        SpringApplication.run(HelloApp.class,args);\r\n    }\r\n}\r\n\r\n~~~\r\n\r\n@SpringBootApplication注解标识了HelloApp为启动类，也是Spring Boot的核心。\r\n\r\n**第四步：** 运行启动类的main方法\r\n\r\n![image-20210523173712142](img/image-20210523173712142.png)\r\n\r\n看到如上配置，证明启动成功，tomcat端口号默认为8080。\r\n\r\n**第五步：**  如果想要修改端口号，可以在resources目录下新建application.properties\r\n\r\n~~~properties\r\nserver.port=8082\r\n~~~\r\n\r\n**第六步：** 重新运行\r\n\r\n![image-20210523174011613](img/image-20210523174011613.png)\r\n\r\n此时的项目结构为：\r\n\r\n![image-20210523174032053](img/image-20210523174032053.png)\r\n\r\n**src/main/java :**  编写java代码，注意启动类需要放在项目的根包下。\r\n\r\n**src/main/resources:**  放置资源的目录，比如springboot的配置文件，静态文件，mybatis配置，日志配置等。\r\n\r\n**src/test/java:**  测试代码\r\n\r\n## 2.2 编写一个Http接口\r\n\r\n**第一步：**创建`HelloController`类，内容如下：\r\n\r\n~~~java\r\npackage com.xiaopizhu.springboot.controller;\r\n\r\nimport org.springframework.web.bind.annotation.GetMapping;\r\nimport org.springframework.web.bind.annotation.RequestMapping;\r\nimport org.springframework.web.bind.annotation.RestController;\r\n\r\n@RestController\r\n@RequestMapping(\"hello\")\r\npublic class HelloController {\r\n\r\n    @GetMapping(\"boot\")\r\n    public String hello(){\r\n        return \"hello spring boot\";\r\n    }\r\n\r\n}\r\n\r\n~~~\r\n\r\n**注意包名，必须在启动类所在的包名下。**\r\n\r\n**第二步：**重启程序，使用postman或者直接在浏览器输入http://localhost:8082/hello/boot\r\n\r\n得到结果：hello spring boot\r\n\r\n## 2.3 编写单元测试用例\r\n\r\n**第一步：**添加spring boot测试依赖\r\n\r\n~~~xml\r\n		<dependency>\r\n            <groupId>org.springframework.boot</groupId>\r\n            <artifactId>spring-boot-starter-test</artifactId>\r\n            <scope>test</scope>\r\n        </dependency>\r\n~~~\r\n\r\n**第二步：**在src/test 下，编写测试用例\r\n\r\n~~~java\r\npackage com.xiaopizhu.springboot.controller;\r\n\r\nimport org.junit.jupiter.api.BeforeAll;\r\nimport org.junit.jupiter.api.BeforeEach;\r\nimport org.junit.jupiter.api.Test;\r\nimport org.springframework.boot.test.context.SpringBootTest;\r\nimport org.springframework.http.MediaType;\r\nimport org.springframework.test.web.servlet.MockMvc;\r\nimport org.springframework.test.web.servlet.request.MockMvcRequestBuilders;\r\nimport org.springframework.test.web.servlet.setup.MockMvcBuilders;\r\n\r\nimport static org.hamcrest.Matchers.equalTo;\r\nimport static org.springframework.test.web.servlet.result.MockMvcResultMatchers.content;\r\nimport static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;\r\n\r\n@SpringBootTest\r\npublic class TestHelloController {\r\n\r\n    private MockMvc mockMvc;\r\n\r\n    @BeforeEach\r\n    public void beforeEach(){\r\n        mockMvc = MockMvcBuilders.standaloneSetup(new HelloController()).build();\r\n    }\r\n    @Test\r\n    public void testHello() throws Exception {\r\n        mockMvc.perform(MockMvcRequestBuilders.get(\"/hello/boot\")\r\n                .accept(MediaType.APPLICATION_JSON))\r\n                .andExpect(status().isOk())\r\n                .andExpect(content().string(equalTo(\"hello spring boot\")));\r\n    }\r\n}\r\n\r\n~~~\r\n\r\n上面的测试用例，是构建一个空的`WebApplicationContext`，并且在before中加载了HelloController，得以在测试用例中mock调用，模拟请求。\r\n\r\n## 2.4 打包为jar运行\r\n\r\n**第一步：**添加打包(maven构建springboot)插件\r\n\r\n~~~xml\r\n  <build>\r\n        <plugins>\r\n            <plugin>\r\n                <groupId>org.springframework.boot</groupId>\r\n                <artifactId>spring-boot-maven-plugin</artifactId>\r\n            </plugin>\r\n        </plugins>\r\n    </build>\r\n~~~\r\n\r\n在idea的右侧 maven中，使用package来打包程序，打包完成后，在target目录下生成helloSpringBoot-1.0-SNAPSHOT.jar\r\n\r\n![image-20210523181737720](img/image-20210523181737720.png)\r\n\r\n**第二步：**打开cmd：找到jar对应的目录\r\n\r\n输入命令\r\n\r\n~~~shell\r\njava -jar helloSpringBoot-1.0-SNAPSHOT.jar\r\n~~~\r\n\r\n![image-20210523182426404](img/image-20210523182426404.png)\r\n\r\n**第三步：**测试，使用postman或者直接在浏览器输入http://localhost:8082/hello/boot\r\n\r\n得到结果：hello spring boot\r\n\r\n## 2.5 查看jar包内容\r\n\r\n~~~shell\r\njar tvf helloSpringBoot-1.0-SNAPSHOT.jar\r\n~~~\r\n\r\n# 3. 小结\r\n\r\n1. 通过Maven构建了一个空白Spring Boot项目，再通过引入web模块实现了一个简单的请求处理。\r\n2. 通过修改配置文件，更改端口号\r\n3. 编写了测试用例\r\n4. 打包jar包运行\r\n\r\n', '<h2>2018-01-04</h2>\n<pre><code class=\"lang-\"># 使用vue的Webpack模板生成脚手架\n</code></pre>\n<h2>2018-01-05</h2>\n<pre><code class=\"lang-\"># 引入ElementUI\n\n# babel-plugin-component自定义主题\n# 首页\n# 登陆页\n# 注册页面\n# 日志页\n</code></pre>\n<h2>2018-01-07</h2>\n<pre><code class=\"lang-\"># 调整底部栏始终固定在底部\n# 日志页 添加时间轴\n# 首页的文章列表\n</code></pre>\n<h2>2018-01-08</h2>\n<pre><code class=\"lang-\"># 使用组件-博客作者tab页 \n# 添加第三方图标\n</code></pre>\n<h2>2018-01-09</h2>\n<pre><code class=\"lang-\"># 调整顶部导航栏：激活文字颜色，click点击\n# 组件-最新文章tab页\n\n# 最新文章、最热文章使用相同组件\n# 底部栏设计\n# 页面与两边边距改为100\n</code></pre>\n<h2>2018-01-10</h2>\n<pre><code class=\"lang-\"># 写博客 引入mavonEditor编辑器\n# 顶部导航栏都放入一个Menu中\n# 写文章页面\n#　mavonEditor局部引入\n\n#　页面的中间区域固定宽度，自动居中\n# 发布和取消\n# 发布dialog\n\n</code></pre>\n<h2>2018-01-11</h2>\n<pre><code class=\"lang-\"># 文章组件用守卫来改变body背景色\n# 调整登陆和注册页面，使其居中\n\n#子页面调整根元素为div\n#文章详情页\n\n</code></pre>\n<h2>2018-01-12</h2>\n<pre><code class=\"lang-\"># 文章详情页  内容  评论等\n\n</code></pre>\n<h2>2018-01-13</h2>\n<pre><code class=\"lang-\">## 重新调整页面结构	\n#顶部和底部 抽成  BaseHeader BaseFooter 组件\n#BlogView为单独页，以前是Home的子路由\n\n</code></pre>\n<h2>2018-01-15</h2>\n<pre><code class=\"lang-\"># 文章分类去掉子级\n# 将首页的文章列表抽成 ArticleItem组件\n# 增加文章的评论展示\n# 增加文章分类、标签页\n\n</code></pre>\n<h2>2018-01-15  2</h2>\n<pre><code class=\"lang-\"># 回到顶部去掉过渡动画（影响顶部导航栏）\n# 顶部导航栏 增加登录后菜单\n# 首页增加 最热标签\n# 增加 文章分类 标签的详情页\n# 将文章详情页、 文章分类标签页 改为Home的子路由（以前单独页）\n# Home组件增加路由判断：更正导航栏的状态、条件显示底部栏\n\n</code></pre>\n<h2>2018-01-16</h2>\n<pre><code class=\"lang-\"># 将写文章的顶部Header合并到BaseHeader中\n# 图片都放到了static目录下\n\n</code></pre>\n<h2>2018-01-24</h2>\n<pre><code class=\"lang-\"># 将自定义的theme放到assets下\n# 加入axios\n# 加入vuex\n# 实现登录\n# 实现退出\n\n</code></pre>\n<h2>2018-01-25</h2>\n<pre><code class=\"lang-\"># 实现注册逻辑\n# 写文章功能实现\n# 写文章时支持插入图片\n\n</code></pre>\n<h2>2018-01-26</h2>\n<pre><code class=\"lang-\"># 引入lodash工具类\n# 优化写文章的工具栏：滚动时固定顶部\n# 写文章 后台获取文章分类和标签\n\n# 首页的文章列表\n\n</code></pre>\n<h2>2018-01-27</h2>\n<pre><code class=\"lang-\"># 修改首页文章列表的样式\n# 首页加载文章功能\n# 文章查看功能\n# 文章分类和标签功能列表\n\n</code></pre>\n<h2>2018-01-28</h2>\n<pre><code class=\"lang-\"># 文章分类和标签详情\n\n</code></pre>\n<h2>2018-01-29</h2>\n<pre><code class=\"lang-\"># 文章分类和标签的文章数\n# 首页最热文章\n# 首页最新文章\n# 首页最热标签\n\n</code></pre>\n<h2>2018-01-30</h2>\n<pre><code class=\"lang-\"># BaseHeader放回views中\n# 修改Axios后置拦截，全局处理错误\n# 将登录 退出 和头像 放到一起\n\n</code></pre>\n', 1);
INSERT INTO `ms_article_body` VALUES (20, 'Vue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的渐进式框架。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。\n\n如果你想在深入学习 Vue 之前对它有更多了解，我们制作了一个视频，带您了解其核心概念和一个示例工程。\n如果你已经是有经验的前端开发者，想知道 Vue 与其它库/框架有哪些区别，请查看对比其它框架。\n\n# 起步\n\n> 官方指南假设你已了解关于 HTML、CSS 和 JavaScript 的中级知识。如果你刚开始学习前端开发，将框架作为你的第一步可能不是最好的主意——掌握好基础知识再来吧！之前有其它框架的使用经验会有帮助，但这不是必需的。\n\n尝试 Vue.js 最简单的方法是使用 JSFiddle 上的 Hello World 例子。你可以在浏览器新标签页中打开它，跟着例子学习一些基础用法。或者你也可以创建一个 .html 文件，然后通过如下方式引入 Vue：\n\n```javascript\n<script src=\"https://cdn.jsdelivr.net/npm/vue\"></script>\n\n```\n安装教程给出了更多安装 Vue 的方式。请注意我们不推荐新手直接使用 vue-cli，尤其是在你还不熟悉基于 Node.js 的构建工具时。\n\n# 声明式渲染\nVue.js 的核心是一个允许采用简洁的模板语法来声明式地将数据渲染进 DOM 的系统：\n```javascript\n<div id=\"app\">\n  {{ message }}\n</div>\n\n```\n```javascript\nvar app = new Vue({\n  el: \'#app\',\n  data: {\n    message: \'Hello Vue!\'\n  }\n})\n\n```\n我们已经成功创建了第一个 Vue 应用！看起来这跟渲染一个字符串模板非常类似，但是 Vue 在背后做了大量工作。现在数据和 DOM 已经被建立了关联，所有东西都是响应式的。我们要怎么确认呢？打开你的浏览器的 JavaScript 控制台 (就在这个页面打开)，并修改 app.message 的值，你将看到上例相应地更新。\n\n除了文本插值，我们还可以像这样来绑定元素特性：\n\n\n\n\n\n\n', '<p>Vue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的渐进式框架。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。</p>\n<p>如果你想在深入学习 Vue 之前对它有更多了解，我们制作了一个视频，带您了解其核心概念和一个示例工程。<br />\n如果你已经是有经验的前端开发者，想知道 Vue 与其它库/框架有哪些区别，请查看对比其它框架。</p>\n<h1>起步</h1>\n<blockquote>\n<p>官方指南假设你已了解关于 HTML、CSS 和 JavaScript 的中级知识。如果你刚开始学习前端开发，将框架作为你的第一步可能不是最好的主意——掌握好基础知识再来吧！之前有其它框架的使用经验会有帮助，但这不是必需的。</p>\n</blockquote>\n<p>尝试 Vue.js 最简单的方法是使用 JSFiddle 上的 Hello World 例子。你可以在浏览器新标签页中打开它，跟着例子学习一些基础用法。或者你也可以创建一个 .html 文件，然后通过如下方式引入 Vue：</p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\">&lt;script src=<span class=\"hljs-string\">\"https://cdn.jsdelivr.net/npm/vue\"</span>&gt;<span class=\"xml\"><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span></span>\n\n</code></div></pre>\n<p>安装教程给出了更多安装 Vue 的方式。请注意我们不推荐新手直接使用 vue-cli，尤其是在你还不熟悉基于 Node.js 的构建工具时。</p>\n<h1>声明式渲染</h1>\n<p>Vue.js 的核心是一个允许采用简洁的模板语法来声明式地将数据渲染进 DOM 的系统：</p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\">&lt;div id=<span class=\"hljs-string\">\"app\"</span>&gt;\n  {{ message }}\n&lt;<span class=\"hljs-regexp\">/div&gt;\n\n</span></code></div></pre>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">var</span> app = <span class=\"hljs-keyword\">new</span> Vue({\n  <span class=\"hljs-attr\">el</span>: <span class=\"hljs-string\">\'#app\'</span>,\n  <span class=\"hljs-attr\">data</span>: {\n    <span class=\"hljs-attr\">message</span>: <span class=\"hljs-string\">\'Hello Vue!\'</span>\n  }\n})\n\n</code></div></pre>\n<p>我们已经成功创建了第一个 Vue 应用！看起来这跟渲染一个字符串模板非常类似，但是 Vue 在背后做了大量工作。现在数据和 DOM 已经被建立了关联，所有东西都是响应式的。我们要怎么确认呢？打开你的浏览器的 JavaScript 控制台 (就在这个页面打开)，并修改 app.message 的值，你将看到上例相应地更新。</p>\n<p>除了文本插值，我们还可以像这样来绑定元素特性：</p>\n', 9);
INSERT INTO `ms_article_body` VALUES (21, '## 快速上手\n\n本节将介绍如何在项目中使用 Element。\n\n### 使用 Starter Kit\n我们提供了通用的项目模板，你可以直接使用。对于 Laravel 用户，我们也准备了相应的模板，同样可以直接下载使用。\n\n如果不希望使用我们提供的模板，请继续阅读。\n\n### 使用 vue-cli\n\n我们还可以使用 vue-cli 初始化项目，命令如下：\n\n```language\n> npm i -g vue-cli\n> mkdir my-project && cd my-project\n> vue init webpack\n> npm i && npm i element-ui\n```\n\n### 引入 Element\n你可以引入整个 Element，或是根据需要仅引入部分组件。我们先介绍如何引入完整的 Element。\n\n#### 完整引入\n在 main.js 中写入以下内容：\n```javascript\nimport Vue from \'vue\'\nimport ElementUI from \'element-ui\'\nimport \'element-ui/lib/theme-chalk/index.css\'\nimport App from \'./App.vue\'\n\nVue.use(ElementUI)\n\nnew Vue({\n  el: \'#app\',\n  render: h => h(App)\n})\n\n```\n以上代码便完成了 Element 的引入。需要注意的是，样式文件需要单独引入。\n\n#### 按需引入\n借助 babel-plugin-component，我们可以只引入需要的组件，以达到减小项目体积的目的。\n\n首先，安装 babel-plugin-component：\n\n', '<h2>快速上手</h2>\n<p>本节将介绍如何在项目中使用 Element。</p>\n<h3>使用 Starter Kit</h3>\n<p>我们提供了通用的项目模板，你可以直接使用。对于 Laravel 用户，我们也准备了相应的模板，同样可以直接下载使用。</p>\n<p>如果不希望使用我们提供的模板，请继续阅读。</p>\n<h3>使用 vue-cli</h3>\n<p>我们还可以使用 vue-cli 初始化项目，命令如下：</p>\n<pre><code class=\"lang-language\">&gt; npm i -g vue-cli\n&gt; mkdir my-project &amp;&amp; cd my-project\n&gt; vue init webpack\n&gt; npm i &amp;&amp; npm i element-ui\n</code></pre>\n<h3>引入 Element</h3>\n<p>你可以引入整个 Element，或是根据需要仅引入部分组件。我们先介绍如何引入完整的 Element。</p>\n<h4>完整引入</h4>\n<p>在 main.js 中写入以下内容：</p>\n<pre><div class=\"hljs\"><code class=\"lang-javascript\"><span class=\"hljs-keyword\">import</span> Vue <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\'vue\'</span>\n<span class=\"hljs-keyword\">import</span> ElementUI <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\'element-ui\'</span>\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">\'element-ui/lib/theme-chalk/index.css\'</span>\n<span class=\"hljs-keyword\">import</span> App <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\'./App.vue\'</span>\n\nVue.use(ElementUI)\n\n<span class=\"hljs-keyword\">new</span> Vue({\n  <span class=\"hljs-attr\">el</span>: <span class=\"hljs-string\">\'#app\'</span>,\n  <span class=\"hljs-attr\">render</span>: <span class=\"hljs-function\"><span class=\"hljs-params\">h</span> =&gt;</span> h(App)\n})\n\n</code></div></pre>\n<p>以上代码便完成了 Element 的引入。需要注意的是，样式文件需要单独引入。</p>\n<h4>按需引入</h4>\n<p>借助 babel-plugin-component，我们可以只引入需要的组件，以达到减小项目体积的目的。</p>\n<p>首先，安装 babel-plugin-component：</p>\n', 10);
INSERT INTO `ms_article_body` VALUES (1405916999854342146, '# 1. Spring Boot介绍\n\n## 1.1 简介\n\n在您第1次接触和学习Spring框架的时候，是否因为其繁杂的配置而退却了？\n\n在你第n次使用Spring框架的时候，是否觉得一堆反复黏贴的配置有一些厌烦？\n\n那么您就不妨来试试使用Spring Boot来让你更易上手，更简单快捷地构建Spring应用！\n\nSpring Boot让我们的Spring应用变的更轻量化。\n\n我们不必像以前那样繁琐的构建项目、打包应用、部署到Tomcat等应用服务器中来运行我们的业务服务。\n\n通过Spring Boot实现的服务，只需要依靠一个Java类，把它打包成jar，并通过`java -jar`命令就可以运行起来。\n\n这一切相较于传统Spring应用来说，已经变得非常的轻便、简单。\n\n**总结一下Spring Boot的主要优点：**\n\n1. 为所有Spring开发者更快的入门\n2. 开箱即用，提供各种默认配置来简化项目配置\n3. 内嵌式容器简化Web项目\n4. 没有冗余代码生成和XML配置的要求\n5. 统一的依赖管理\n6. 自动装配，更易使用，更易扩展\n\n## 1.2 使用版本说明\n\nSpringboot版本：使用最新的2.5.0版本\n\n教程参考了官方文档进行制作，权威。\n\n其他依赖版本：\n\n	1. Maven  需求：3.5+\n\n   	2. JDK 需求  8+\n   	3. Spring Framework 5.3.7以上版本\n   	4. Tomcat 9.0\n   	5. Servlet版本 4.0  但是可以部署到Servlet到3.1+的容器中\n\n# 2. 快速入门\n\n快速的创建一个Spring Boot应用，并且实现一个简单的Http请求处理。通过这个例子对Spring Boot有一个初步的了解，并体验其结构简单、开发快速的特性。\n\n教程使用的Idea版本：2019.3\n\n## 2.1 创建基础项目\n\n**第一步：** 创建maven项目\n\npom.xml :\n\n~~~xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    <modelVersion>4.0.0</modelVersion>\n\n    <groupId>com.xiaopizhu</groupId>\n    <artifactId>helloSpringBoot</artifactId>\n    <version>1.0-SNAPSHOT</version>\n	<!--springboot的父工程其中定义了常用的依赖，并且无依赖冲突-->\n    <parent>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-parent</artifactId>\n        <version>2.5.0</version>\n    </parent>\n</project>\n~~~\n\n注意上方的parent必须加，其中定义了springboot官方支持的n多依赖，基本上常用的已经有了，所以接下来导入依赖的时候，绝大部分都可以不加版本号。\n\n此时的工程结构为：\n\n![image20210523173241557.png](https://static.mszlu.com/a7302c88-e106-46ad-9713-dc9a6d523957.png)\n\n**第二步：** 添加web依赖\n\n~~~xml\n<dependencies>\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-web</artifactId>\n    </dependency>\n</dependencies>\n~~~\n\n添加上方的web依赖，其中间接依赖了spring-web，spring-webmvc，spring-core等spring和springmvc的包，并且集成了tomcat。\n\n**第三步：** 编写启动类\n\n~~~java\npackage com.xiaopizhu.springboot;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\n\n@SpringBootApplication\npublic class HelloApp {\n\n    public static void main(String[] args) {\n        SpringApplication.run(HelloApp.class,args);\n    }\n}\n\n~~~\n\n@SpringBootApplication注解标识了HelloApp为启动类，也是Spring Boot的核心。\n\n**第四步：** 运行启动类的main方法\n\n![image20210523173712142.png](https://static.mszlu.com/dc17b43e-08df-46b0-bb7a-eb73044de7da.png)\n\n看到如上配置，证明启动成功，tomcat端口号默认为8080。\n\n**第五步：**  如果想要修改端口号，可以在resources目录下新建application.properties\n\n~~~properties\nserver.port=8082\n~~~\n\n**第六步：** 重新运行\n\n![image20210523174011613.png](https://static.mszlu.com/318e4b7e-95d2-4e43-a18f-279ea6ff9495.png)\n\n此时的项目结构为：\n\n![image20210523174032053.png](https://static.mszlu.com/756e4ae0-c4c7-43a5-9b5d-bc7ce974a942.png)\n\n**src/main/java :**  编写java代码，注意启动类需要放在项目的根包下。\n\n**src/main/resources:**  放置资源的目录，比如springboot的配置文件，静态文件，mybatis配置，日志配置等。\n\n**src/test/java:**  测试代码\n\n## 2.2 编写一个Http接口\n\n**第一步：**  创建`HelloController`类，内容如下：\n\n~~~java\npackage com.xiaopizhu.springboot.controller;\n\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RestController;\n\n@RestController\n@RequestMapping(\"hello\")\npublic class HelloController {\n\n    @GetMapping(\"boot\")\n    public String hello(){\n        return \"hello spring boot\";\n    }\n\n}\n\n~~~\n\n**注意包名，必须在启动类所在的包名下。**\n\n**第二步： ** 重启程序，使用postman或者直接在浏览器输入http://localhost:8082/hello/boot\n\n得到结果：hello spring boot\n\n## 2.3 编写单元测试用例\n\n**第一步： ** 添加spring boot测试依赖\n\n~~~xml\n		<dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-test</artifactId>\n            <scope>test</scope>\n        </dependency>\n~~~\n\n**第二步：** 在src/test 下，编写测试用例\n\n~~~java\npackage com.xiaopizhu.springboot.controller;\n\nimport org.junit.jupiter.api.BeforeAll;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport org.springframework.boot.test.context.SpringBootTest;\nimport org.springframework.http.MediaType;\nimport org.springframework.test.web.servlet.MockMvc;\nimport org.springframework.test.web.servlet.request.MockMvcRequestBuilders;\nimport org.springframework.test.web.servlet.setup.MockMvcBuilders;\n\nimport static org.hamcrest.Matchers.equalTo;\nimport static org.springframework.test.web.servlet.result.MockMvcResultMatchers.content;\nimport static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;\n\n@SpringBootTest\npublic class TestHelloController {\n\n    private MockMvc mockMvc;\n\n    @BeforeEach\n    public void beforeEach(){\n        mockMvc = MockMvcBuilders.standaloneSetup(new HelloController()).build();\n    }\n    @Test\n    public void testHello() throws Exception {\n        mockMvc.perform(MockMvcRequestBuilders.get(\"/hello/boot\")\n                .accept(MediaType.APPLICATION_JSON))\n                .andExpect(status().isOk())\n                .andExpect(content().string(equalTo(\"hello spring boot\")));\n    }\n}\n\n~~~\n\n上面的测试用例，是构建一个空的`WebApplicationContext`，并且在before中加载了HelloController，得以在测试用例中mock调用，模拟请求。\n\n## 2.4 打包为jar运行\n\n**第一步：** 添加打包(maven构建springboot)插件\n\n~~~xml\n  <build>\n        <plugins>\n            <plugin>\n                <groupId>org.springframework.boot</groupId>\n                <artifactId>spring-boot-maven-plugin</artifactId>\n            </plugin>\n        </plugins>\n    </build>\n~~~\n\n在idea的右侧 maven中，使用package来打包程序，打包完成后，在target目录下生成helloSpringBoot-1.0-SNAPSHOT.jar\n\n![image20210523181737720.png](https://static.mszlu.com/45aa0db2-598f-4564-964c-a2d889dfbafe.png)\n\n**第二步： ** 打开cmd：找到jar对应的目录\n\n输入命令\n\n~~~shell\njava -jar helloSpringBoot-1.0-SNAPSHOT.jar\n~~~\n\n![image20210523182426404.png](https://static.mszlu.com/74376f77-b8eb-4c2c-a4cc-d3bfe24901e3.png)\n\n**第三步：**  测试，使用postman或者直接在浏览器输入http://localhost:8082/hello/boot\n\n得到结果：hello spring boot\n\n## 2.5 查看jar包内容\n\n~~~shell\njar tvf helloSpringBoot-1.0-SNAPSHOT.jar\n~~~\n\n# 3. 小结\n\n1. 通过Maven构建了一个空白Spring Boot项目，再通过引入web模块实现了一个简单的请求处理。\n2. 通过修改配置文件，更改端口号\n3. 编写了测试用例\n4. 打包jar包运行\n\n', '<h1><a id=\"1_Spring_Boot_0\"></a>1. Spring Boot介绍</h1>\n<h2><a id=\"11__2\"></a>1.1 简介</h2>\n<p>在您第1次接触和学习Spring框架的时候，是否因为其繁杂的配置而退却了？</p>\n<p>在你第n次使用Spring框架的时候，是否觉得一堆反复黏贴的配置有一些厌烦？</p>\n<p>那么您就不妨来试试使用Spring Boot来让你更易上手，更简单快捷地构建Spring应用！</p>\n<p>Spring Boot让我们的Spring应用变的更轻量化。</p>\n<p>我们不必像以前那样繁琐的构建项目、打包应用、部署到Tomcat等应用服务器中来运行我们的业务服务。</p>\n<p>通过Spring Boot实现的服务，只需要依靠一个Java类，把它打包成jar，并通过<code>java -jar</code>命令就可以运行起来。</p>\n<p>这一切相较于传统Spring应用来说，已经变得非常的轻便、简单。</p>\n<p><strong>总结一下Spring Boot的主要优点：</strong></p>\n<ol>\n<li>为所有Spring开发者更快的入门</li>\n<li>开箱即用，提供各种默认配置来简化项目配置</li>\n<li>内嵌式容器简化Web项目</li>\n<li>没有冗余代码生成和XML配置的要求</li>\n<li>统一的依赖管理</li>\n<li>自动装配，更易使用，更易扩展</li>\n</ol>\n<h2><a id=\"12__27\"></a>1.2 使用版本说明</h2>\n<p>Springboot版本：使用最新的2.5.0版本</p>\n<p>教程参考了官方文档进行制作，权威。</p>\n<p>其他依赖版本：</p>\n<pre><code>1. Maven  需求：3.5+\n\n2. JDK 需求  8+\n3. Spring Framework 5.3.7以上版本\n4. Tomcat 9.0\n5. Servlet版本 4.0  但是可以部署到Servlet到3.1+的容器中\n</code></pre>\n<h1><a id=\"2__42\"></a>2. 快速入门</h1>\n<p>快速的创建一个Spring Boot应用，并且实现一个简单的Http请求处理。通过这个例子对Spring Boot有一个初步的了解，并体验其结构简单、开发快速的特性。</p>\n<p>教程使用的Idea版本：2019.3</p>\n<h2><a id=\"21__48\"></a>2.1 创建基础项目</h2>\n<p><strong>第一步：</strong> 创建maven项目</p>\n<p>pom.xml :</p>\n<pre><div class=\"hljs\"><code class=\"lang-xml\"><span class=\"php\"><span class=\"hljs-meta\">&lt;?</span>xml version=<span class=\"hljs-string\">\"1.0\"</span> encoding=<span class=\"hljs-string\">\"UTF-8\"</span><span class=\"hljs-meta\">?&gt;</span></span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">project</span> <span class=\"hljs-attr\">xmlns</span>=<span class=\"hljs-string\">\"http://maven.apache.org/POM/4.0.0\"</span>\n         <span class=\"hljs-attr\">xmlns:xsi</span>=<span class=\"hljs-string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span>\n         <span class=\"hljs-attr\">xsi:schemaLocation</span>=<span class=\"hljs-string\">\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">modelVersion</span>&gt;</span>4.0.0<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">modelVersion</span>&gt;</span>\n\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>com.xiaopizhu<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>helloSpringBoot<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>1.0-SNAPSHOT<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n	<span class=\"hljs-comment\">&lt;!--springboot的父工程其中定义了常用的依赖，并且无依赖冲突--&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">parent</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>spring-boot-starter-parent<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>2.5.0<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">parent</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">project</span>&gt;</span>\n</code></div></pre>\n<p>注意上方的parent必须加，其中定义了springboot官方支持的n多依赖，基本上常用的已经有了，所以接下来导入依赖的时候，绝大部分都可以不加版本号。</p>\n<p>此时的工程结构为：</p>\n<p><img src=\"https://static.mszlu.com/a7302c88-e106-46ad-9713-dc9a6d523957.png\" alt=\"image20210523173241557.png\" /></p>\n<p><strong>第二步：</strong> 添加web依赖</p>\n<pre><div class=\"hljs\"><code class=\"lang-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependencies</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>spring-boot-starter-web<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependencies</span>&gt;</span>\n</code></div></pre>\n<p>添加上方的web依赖，其中间接依赖了spring-web，spring-webmvc，spring-core等spring和springmvc的包，并且集成了tomcat。</p>\n<p><strong>第三步：</strong> 编写启动类</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">package</span> com.xiaopizhu.springboot;\n\n<span class=\"hljs-keyword\">import</span> org.springframework.boot.SpringApplication;\n<span class=\"hljs-keyword\">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;\n\n<span class=\"hljs-meta\">@SpringBootApplication</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">HelloApp</span> </span>{\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span> </span>{\n        SpringApplication.run(HelloApp.class,args);\n    }\n}\n\n</code></div></pre>\n<p>@SpringBootApplication注解标识了HelloApp为启动类，也是Spring Boot的核心。</p>\n<p><strong>第四步：</strong> 运行启动类的main方法</p>\n<p><img src=\"https://static.mszlu.com/dc17b43e-08df-46b0-bb7a-eb73044de7da.png\" alt=\"image20210523173712142.png\" /></p>\n<p>看到如上配置，证明启动成功，tomcat端口号默认为8080。</p>\n<p><strong>第五步：</strong>  如果想要修改端口号，可以在resources目录下新建application.properties</p>\n<pre><code class=\"lang-properties\">server.port=8082\n</code></pre>\n<p><strong>第六步：</strong> 重新运行</p>\n<p><img src=\"https://static.mszlu.com/318e4b7e-95d2-4e43-a18f-279ea6ff9495.png\" alt=\"image20210523174011613.png\" /></p>\n<p>此时的项目结构为：</p>\n<p><img src=\"https://static.mszlu.com/756e4ae0-c4c7-43a5-9b5d-bc7ce974a942.png\" alt=\"image20210523174032053.png\" /></p>\n<p><strong>src/main/java :</strong>  编写java代码，注意启动类需要放在项目的根包下。</p>\n<p><strong>src/main/resources:</strong>  放置资源的目录，比如springboot的配置文件，静态文件，mybatis配置，日志配置等。</p>\n<p><strong>src/test/java:</strong>  测试代码</p>\n<h2><a id=\"22_Http_138\"></a>2.2 编写一个Http接口</h2>\n<p><strong>第一步：</strong>  创建<code>HelloController</code>类，内容如下：</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">package</span> com.xiaopizhu.springboot.controller;\n\n<span class=\"hljs-keyword\">import</span> org.springframework.web.bind.annotation.GetMapping;\n<span class=\"hljs-keyword\">import</span> org.springframework.web.bind.annotation.RequestMapping;\n<span class=\"hljs-keyword\">import</span> org.springframework.web.bind.annotation.RestController;\n\n<span class=\"hljs-meta\">@RestController</span>\n<span class=\"hljs-meta\">@RequestMapping</span>(<span class=\"hljs-string\">\"hello\"</span>)\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">HelloController</span> </span>{\n\n    <span class=\"hljs-meta\">@GetMapping</span>(<span class=\"hljs-string\">\"boot\"</span>)\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> String <span class=\"hljs-title\">hello</span><span class=\"hljs-params\">()</span></span>{\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"hello spring boot\"</span>;\n    }\n\n}\n\n</code></div></pre>\n<p><strong>注意包名，必须在启动类所在的包名下。</strong></p>\n<p>**第二步： ** 重启程序，使用postman或者直接在浏览器输入http://localhost:8082/hello/boot</p>\n<p>得到结果：hello spring boot</p>\n<h2><a id=\"23__168\"></a>2.3 编写单元测试用例</h2>\n<p>**第一步： ** 添加spring boot测试依赖</p>\n<pre><div class=\"hljs\"><code class=\"lang-xml\">		<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>spring-boot-starter-test<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">scope</span>&gt;</span>test<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">scope</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span>\n</code></div></pre>\n<p><strong>第二步：</strong> 在src/test 下，编写测试用例</p>\n<pre><div class=\"hljs\"><code class=\"lang-java\"><span class=\"hljs-keyword\">package</span> com.xiaopizhu.springboot.controller;\n\n<span class=\"hljs-keyword\">import</span> org.junit.jupiter.api.BeforeAll;\n<span class=\"hljs-keyword\">import</span> org.junit.jupiter.api.BeforeEach;\n<span class=\"hljs-keyword\">import</span> org.junit.jupiter.api.Test;\n<span class=\"hljs-keyword\">import</span> org.springframework.boot.test.context.SpringBootTest;\n<span class=\"hljs-keyword\">import</span> org.springframework.http.MediaType;\n<span class=\"hljs-keyword\">import</span> org.springframework.test.web.servlet.MockMvc;\n<span class=\"hljs-keyword\">import</span> org.springframework.test.web.servlet.request.MockMvcRequestBuilders;\n<span class=\"hljs-keyword\">import</span> org.springframework.test.web.servlet.setup.MockMvcBuilders;\n\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-keyword\">static</span> org.hamcrest.Matchers.equalTo;\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-keyword\">static</span> org.springframework.test.web.servlet.result.MockMvcResultMatchers.content;\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-keyword\">static</span> org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;\n\n<span class=\"hljs-meta\">@SpringBootTest</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">TestHelloController</span> </span>{\n\n    <span class=\"hljs-keyword\">private</span> MockMvc mockMvc;\n\n    <span class=\"hljs-meta\">@BeforeEach</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">beforeEach</span><span class=\"hljs-params\">()</span></span>{\n        mockMvc = MockMvcBuilders.standaloneSetup(<span class=\"hljs-keyword\">new</span> HelloController()).build();\n    }\n    <span class=\"hljs-meta\">@Test</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">testHello</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">throws</span> Exception </span>{\n        mockMvc.perform(MockMvcRequestBuilders.get(<span class=\"hljs-string\">\"/hello/boot\"</span>)\n                .accept(MediaType.APPLICATION_JSON))\n                .andExpect(status().isOk())\n                .andExpect(content().string(equalTo(<span class=\"hljs-string\">\"hello spring boot\"</span>)));\n    }\n}\n\n</code></div></pre>\n<p>上面的测试用例，是构建一个空的<code>WebApplicationContext</code>，并且在before中加载了HelloController，得以在测试用例中mock调用，模拟请求。</p>\n<h2><a id=\"24_jar_220\"></a>2.4 打包为jar运行</h2>\n<p><strong>第一步：</strong> 添加打包(maven构建springboot)插件</p>\n<pre><div class=\"hljs\"><code class=\"lang-xml\">  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">build</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">plugins</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">plugin</span>&gt;</span>\n                <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n                <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">plugin</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">plugins</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">build</span>&gt;</span>\n</code></div></pre>\n<p>在idea的右侧 maven中，使用package来打包程序，打包完成后，在target目录下生成helloSpringBoot-1.0-SNAPSHOT.jar</p>\n<p><img src=\"https://static.mszlu.com/45aa0db2-598f-4564-964c-a2d889dfbafe.png\" alt=\"image20210523181737720.png\" /></p>\n<p>**第二步： ** 打开cmd：找到jar对应的目录</p>\n<p>输入命令</p>\n<pre><div class=\"hljs\"><code class=\"lang-shell\">java -jar helloSpringBoot-1.0-SNAPSHOT.jar\n</code></div></pre>\n<p><img src=\"https://static.mszlu.com/74376f77-b8eb-4c2c-a4cc-d3bfe24901e3.png\" alt=\"image20210523182426404.png\" /></p>\n<p><strong>第三步：</strong>  测试，使用postman或者直接在浏览器输入http://localhost:8082/hello/boot</p>\n<p>得到结果：hello spring boot</p>\n<h2><a id=\"25_jar_253\"></a>2.5 查看jar包内容</h2>\n<pre><div class=\"hljs\"><code class=\"lang-shell\">jar tvf helloSpringBoot-1.0-SNAPSHOT.jar\n</code></div></pre>\n<h1><a id=\"3__259\"></a>3. 小结</h1>\n<ol>\n<li>通过Maven构建了一个空白Spring Boot项目，再通过引入web模块实现了一个简单的请求处理。</li>\n<li>通过修改配置文件，更改端口号</li>\n<li>编写了测试用例</li>\n<li>打包jar包运行</li>\n</ol>\n', 1405916999732707330);
INSERT INTO `ms_article_body` VALUES (1622156649072435203, '# Spring Boot特征\n## 概念：\n\n约定优于配置，简单来说就是你所期待的配置与约定的配置一致，那么就可以不做任何配置，约定不符合期待时才需要对约定进行替换配置。\n\n## 特征：\n\n1. SpringBoot Starter：他将常用的依赖分组进行了整合，将其合并到一个依赖中，这样就可以一次性添加到项目的Maven或Gradle构建中。\n\n2,使编码变得简单，SpringBoot采用 JavaConfig的方式对Spring进行配置，并且提供了大量的注解，极大的提高了工作效率，比如@Configuration和@bean注解结合，基于@Configuration完成类扫描，基于@bean注解把返回值注入IOC容器。\n\n3.自动配置：SpringBoot的自动配置特性利用了Spring对条件化配置的支持，合理地推测应用所需的bean并自动化配置他们。\n\n4.使部署变得简单，SpringBoot内置了三种Servlet容器，Tomcat，Jetty,undertow.我们只需要一个Java的运行环境就可以跑SpringBoot的项目了，SpringBoot的项目可以打成一个jar包。', '<h1><a id=\"Spring_Boot_0\"></a>Spring Boot特征</h1>\n<h2><a id=\"_1\"></a>概念：</h2>\n<p>约定优于配置，简单来说就是你所期待的配置与约定的配置一致，那么就可以不做任何配置，约定不符合期待时才需要对约定进行替换配置。</p>\n<h2><a id=\"_5\"></a>特征：</h2>\n<ol>\n<li>SpringBoot Starter：他将常用的依赖分组进行了整合，将其合并到一个依赖中，这样就可以一次性添加到项目的Maven或Gradle构建中。</li>\n</ol>\n<p>2,使编码变得简单，SpringBoot采用 JavaConfig的方式对Spring进行配置，并且提供了大量的注解，极大的提高了工作效率，比如@Configuration和@bean注解结合，基于@Configuration完成类扫描，基于@bean注解把返回值注入IOC容器。</p>\n<p>3.自动配置：SpringBoot的自动配置特性利用了Spring对条件化配置的支持，合理地推测应用所需的bean并自动化配置他们。</p>\n<p>4.使部署变得简单，SpringBoot内置了三种Servlet容器，Tomcat，Jetty,undertow.我们只需要一个Java的运行环境就可以跑SpringBoot的项目了，SpringBoot的项目可以打成一个jar包。</p>\n', 1622156649005326338);
INSERT INTO `ms_article_body` VALUES (1622157820864503810, '# Spring Boot特征\n## 概念：\n\n约定优于配置，简单来说就是你所期待的配置与约定的配置一致，那么就可以不做任何配置，约定不符合期待时才需要对约定进行替换配置。\n\n## 特征：\n\n1. SpringBoot Starter：他将常用的依赖分组进行了整合，将其合并到一个依赖中，这样就可以一次性添加到项目的Maven或Gradle构建中。\n\n2,使编码变得简单，SpringBoot采用 JavaConfig的方式对Spring进行配置，并且提供了大量的注解，极大的提高了工作效率，比如@Configuration和@bean注解结合，基于@Configuration完成类扫描，基于@bean注解把返回值注入IOC容器。\n\n3.自动配置：SpringBoot的自动配置特性利用了Spring对条件化配置的支持，合理地推测应用所需的bean并自动化配置他们。\n\n4.使部署变得简单，SpringBoot内置了三种Servlet容器，Tomcat，Jetty,undertow.我们只需要一个Java的运行环境就可以跑SpringBoot的项目了，SpringBoot的项目可以打成一个jar包。', '<h1><a id=\"Spring_Boot_0\"></a>Spring Boot特征</h1>\n<h2><a id=\"_1\"></a>概念：</h2>\n<p>约定优于配置，简单来说就是你所期待的配置与约定的配置一致，那么就可以不做任何配置，约定不符合期待时才需要对约定进行替换配置。</p>\n<h2><a id=\"_5\"></a>特征：</h2>\n<ol>\n<li>SpringBoot Starter：他将常用的依赖分组进行了整合，将其合并到一个依赖中，这样就可以一次性添加到项目的Maven或Gradle构建中。</li>\n</ol>\n<p>2,使编码变得简单，SpringBoot采用 JavaConfig的方式对Spring进行配置，并且提供了大量的注解，极大的提高了工作效率，比如@Configuration和@bean注解结合，基于@Configuration完成类扫描，基于@bean注解把返回值注入IOC容器。</p>\n<p>3.自动配置：SpringBoot的自动配置特性利用了Spring对条件化配置的支持，合理地推测应用所需的bean并自动化配置他们。</p>\n<p>4.使部署变得简单，SpringBoot内置了三种Servlet容器，Tomcat，Jetty,undertow.我们只需要一个Java的运行环境就可以跑SpringBoot的项目了，SpringBoot的项目可以打成一个jar包。</p>\n', 1622157820797394946);
INSERT INTO `ms_article_body` VALUES (1646368109738655748, '删除测试1', '<p>删除测试1</p>\n', 1646368109717684225);
INSERT INTO `ms_article_body` VALUES (1656874498286215170, '## 支持markdown文档编写\n图片![2020112022562230967.jpg](http://rraajldpj.hn-bkt.clouddn.com/52de97e6-f371-4d89-bc6f-ebc065ae14c4.jpg)', '<h2><a id=\"markdown_0\"></a>支持markdown文档编写</h2>\n<p>图片<img src=\"http://rraajldpj.hn-bkt.clouddn.com/52de97e6-f371-4d89-bc6f-ebc065ae14c4.jpg\" alt=\"2020112022562230967.jpg\" /></p>\n', 1656874498084888578);
INSERT INTO `ms_article_body` VALUES (1658026844844212225, '![20211722215388977.jpg](http://ruizmypmv.hn-bkt.clouddn.com/68ed9103-6660-4147-8614-b281a3ce6739.jpg)', '<p><img src=\"http://ruizmypmv.hn-bkt.clouddn.com/68ed9103-6660-4147-8614-b281a3ce6739.jpg\" alt=\"20211722215388977.jpg\" /></p>\n', 1658026844760326146);
INSERT INTO `ms_article_body` VALUES (1658757310081777665, '在做面试题的时候，发现有关线程执行顺序的一个常见考题：（纯纯考研审题）\n```\npackage link;\n\npublic class Test {\n    public static void main(String[] args) {\n        Thread thread = new Thread() {\n            @Override\n            public void run() {\n                pong();\n            }\n        };\n        thread.run();\n        System.out.println(\"ping\");\n    }\n\n    static void  pong(){\n        System.out.println(\"pong\");\n    }\n}\n```\n上面这个程序中，在主线程中创建一个线程对象，审题不仔细就会出问题，以为考的是线程，谁知道这个线程调用的是run（）方法，而不是start（）方法，也就是说，还是只有一个主线程在执行，执行当然是先调用thread对象的run方法，再执行输出语句。\n如果thread调用start方法，那么就是有两个线程，两个线程谁先执行完都有可能，所以出现‘pingpong’和‘pongping’都有可能。\nps：如果线程内部还有start方法如下，thread.start（）并不是启动线程，只是调用这个普通方法罢了\n\nclass MyThread extends Thread{\n \n	@Override\n	public void run() {\n		System.out.println(\"[thread] execute RUN\");\n	}\n	\n	public void start() {\n		System.out.println(\"[method] execute RUN\");\n	}	\n}', '<p>在做面试题的时候，发现有关线程执行顺序的一个常见考题：（纯纯考研审题）</p>\n<pre><code class=\"lang-\">package link;\n\npublic class Test {\n    public static void main(String[] args) {\n        Thread thread = new Thread() {\n            @Override\n            public void run() {\n                pong();\n            }\n        };\n        thread.run();\n        System.out.println(&quot;ping&quot;);\n    }\n\n    static void  pong(){\n        System.out.println(&quot;pong&quot;);\n    }\n}\n</code></pre>\n<p>上面这个程序中，在主线程中创建一个线程对象，审题不仔细就会出问题，以为考的是线程，谁知道这个线程调用的是run（）方法，而不是start（）方法，也就是说，还是只有一个主线程在执行，执行当然是先调用thread对象的run方法，再执行输出语句。<br />\n如果thread调用start方法，那么就是有两个线程，两个线程谁先执行完都有可能，所以出现‘pingpong’和‘pongping’都有可能。<br />\nps：如果线程内部还有start方法如下，thread.start（）并不是启动线程，只是调用这个普通方法罢了</p>\n<p>class MyThread extends Thread{</p>\n<pre><code>@Override\npublic void run() {\n	System.out.println(&quot;[thread] execute RUN&quot;);\n}\n\npublic void start() {\n	System.out.println(&quot;[method] execute RUN&quot;);\n}	\n</code></pre>\n<p>}</p>\n', 1658757309691707394);
INSERT INTO `ms_article_body` VALUES (1658757404269068291, '在做面试题的时候，发现有关线程执行顺序的一个常见考题：（纯纯考研审题）\n```\npackage link;\n\npublic class Test {\n    public static void main(String[] args) {\n        Thread thread = new Thread() {\n            @Override\n            public void run() {\n                pong();\n            }\n        };\n        thread.run();\n        System.out.println(\"ping\");\n    }\n\n    static void  pong(){\n        System.out.println(\"pong\");\n    }\n}\n```\n上面这个程序中，在主线程中创建一个线程对象，审题不仔细就会出问题，以为考的是线程，谁知道这个线程调用的是run（）方法，而不是start（）方法，也就是说，还是只有一个主线程在执行，执行当然是先调用thread对象的run方法，再执行输出语句。\n如果thread调用start方法，那么就是有两个线程，两个线程谁先执行完都有可能，所以出现‘pingpong’和‘pongping’都有可能。\nps：如果线程内部还有start方法如下，thread.start（）并不是启动线程，只是调用这个普通方法罢了\n```\nclass MyThread extends Thread{\n \n	@Override\n	public void run() {\n		System.out.println(\"[thread] execute RUN\");\n	}\n	\n	public void start() {\n		System.out.println(\"[method] execute RUN\");\n	}	\n}\n```', '<p>在做面试题的时候，发现有关线程执行顺序的一个常见考题：（纯纯考研审题）</p>\n<pre><code class=\"lang-\">package link;\n\npublic class Test {\n    public static void main(String[] args) {\n        Thread thread = new Thread() {\n            @Override\n            public void run() {\n                pong();\n            }\n        };\n        thread.run();\n        System.out.println(&quot;ping&quot;);\n    }\n\n    static void  pong(){\n        System.out.println(&quot;pong&quot;);\n    }\n}\n</code></pre>\n<p>上面这个程序中，在主线程中创建一个线程对象，审题不仔细就会出问题，以为考的是线程，谁知道这个线程调用的是run（）方法，而不是start（）方法，也就是说，还是只有一个主线程在执行，执行当然是先调用thread对象的run方法，再执行输出语句。<br />\n如果thread调用start方法，那么就是有两个线程，两个线程谁先执行完都有可能，所以出现‘pingpong’和‘pongping’都有可能。<br />\nps：如果线程内部还有start方法如下，thread.start（）并不是启动线程，只是调用这个普通方法罢了</p>\n<pre><code class=\"lang-\">class MyThread extends Thread{\n \n	@Override\n	public void run() {\n		System.out.println(&quot;[thread] execute RUN&quot;);\n	}\n	\n	public void start() {\n		System.out.println(&quot;[method] execute RUN&quot;);\n	}	\n}\n</code></pre>\n', 1658757309691707394);
INSERT INTO `ms_article_body` VALUES (1658757559055663105, '在做面试题的时候，发现有关线程执行顺序的一个常见考题：（纯纯考研审题）\n```\npackage link;\n\npublic class Test {\n    public static void main(String[] args) {\n        Thread thread = new Thread() {\n            @Override\n            public void run() {\n                pong();\n            }\n        };\n        thread.run();\n        System.out.println(\"ping\");\n    }\n\n    static void  pong(){\n        System.out.println(\"pong\");\n    }\n}\n```\n上面这个程序中，在主线程中创建一个线程对象，审题不仔细就会出问题，以为考的是线程，谁知道这个线程调用的是run（）方法，而不是start（）方法，也就是说，还是只有一个主线程在执行，执行当然是先调用thread对象的run方法，再执行输出语句。\n如果thread调用start方法，那么就是有两个线程，两个线程谁先执行完都有可能，所以出现‘pingpong’和‘pongping’都有可能。\nps：如果线程内部还有start方法如下，thread.start（）并不是启动线程，只是调用这个普通方法罢了\n```\nclass MyThread extends Thread{\n \n	@Override\n	public void run() {\n		System.out.println(\"[thread] execute RUN\");\n	}\n	\n	public void start() {\n		System.out.println(\"[method] execute RUN\");\n	}	\n}\n```', '<p>在做面试题的时候，发现有关线程执行顺序的一个常见考题：（纯纯考研审题）</p>\n<pre><code class=\"lang-\">package link;\n\npublic class Test {\n    public static void main(String[] args) {\n        Thread thread = new Thread() {\n            @Override\n            public void run() {\n                pong();\n            }\n        };\n        thread.run();\n        System.out.println(&quot;ping&quot;);\n    }\n\n    static void  pong(){\n        System.out.println(&quot;pong&quot;);\n    }\n}\n</code></pre>\n<p>上面这个程序中，在主线程中创建一个线程对象，审题不仔细就会出问题，以为考的是线程，谁知道这个线程调用的是run（）方法，而不是start（）方法，也就是说，还是只有一个主线程在执行，执行当然是先调用thread对象的run方法，再执行输出语句。<br />\n如果thread调用start方法，那么就是有两个线程，两个线程谁先执行完都有可能，所以出现‘pingpong’和‘pongping’都有可能。<br />\nps：如果线程内部还有start方法如下，thread.start（）并不是启动线程，只是调用这个普通方法罢了</p>\n<pre><code class=\"lang-\">class MyThread extends Thread{\n \n	@Override\n	public void run() {\n		System.out.println(&quot;[thread] execute RUN&quot;);\n	}\n	\n	public void start() {\n		System.out.println(&quot;[method] execute RUN&quot;);\n	}	\n}\n</code></pre>\n', 1658757309691707394);
INSERT INTO `ms_article_body` VALUES (1658759520337379330, '### synchronized和Lock的区别\n1. synchronized是java的关键字，而Lock是java中的一个接口。synchronized是由jdk实现的，不需要程序员控制释放锁和加锁，而lock需要手动去控制加锁释放锁。\n2. synchronized修饰的代码异常时，自动释放锁资源，而Lock需要调用unLock()方法手动释放锁，否则会造成死锁现象。需要在finally快中使用该方法释放锁资源。\n3. Lock可以让等待锁资源的线程中断，如tryLock(long time, TimeUnit unit)。而synchronized不行，需要一直等待，直到获得锁\n4. synchronized是非公平锁，Lock默认是非公平，但是可以设置为公平锁。\n5. Lock可以绑定条件，实现分组唤醒需要的线程；synchronized要么随机唤醒一个，要么唤醒全部线程。\n### 公平锁和非公平锁\n#### 公平锁\n多个线程按照申请锁的顺序去获得锁，线程会直接进入队列去排队，永远都是队列的第一位才能得到锁。\n优点：所有的线程都能得到资源，不会饿死在队列中。\n缺点：吞吐量会下降很多，队列里面除了第一个线程，其他的线程都会阻塞，cpu唤醒阻塞线程的开销会很大。\n\n#### 非公平锁\n多个线程去获取锁的时候，会直接去尝试获取，获取不到，再去进入等待队列，如果能获取到，就直接获取到锁。\n优点：可以减少CPU唤醒线程的开销，整体的吞吐效率会高点，CPU也不必取唤醒所有线程，会减少唤起线程的数量。\n缺点：你们可能也发现了，这样可能导致队列中间的线程一直获取不到锁或者长时间获取不到锁，导致饿死。', '<h3><a id=\"synchronizedLock_0\"></a>synchronized和Lock的区别</h3>\n<ol>\n<li>synchronized是java的关键字，而Lock是java中的一个接口。synchronized是由jdk实现的，不需要程序员控制释放锁和加锁，而lock需要手动去控制加锁释放锁。</li>\n<li>synchronized修饰的代码异常时，自动释放锁资源，而Lock需要调用unLock()方法手动释放锁，否则会造成死锁现象。需要在finally快中使用该方法释放锁资源。</li>\n<li>Lock可以让等待锁资源的线程中断，如tryLock(long time, TimeUnit unit)。而synchronized不行，需要一直等待，直到获得锁</li>\n<li>synchronized是非公平锁，Lock默认是非公平，但是可以设置为公平锁。</li>\n<li>Lock可以绑定条件，实现分组唤醒需要的线程；synchronized要么随机唤醒一个，要么唤醒全部线程。</li>\n</ol>\n<h3><a id=\"_6\"></a>公平锁和非公平锁</h3>\n<h4><a id=\"_7\"></a>公平锁</h4>\n<p>多个线程按照申请锁的顺序去获得锁，线程会直接进入队列去排队，永远都是队列的第一位才能得到锁。<br />\n优点：所有的线程都能得到资源，不会饿死在队列中。<br />\n缺点：吞吐量会下降很多，队列里面除了第一个线程，其他的线程都会阻塞，cpu唤醒阻塞线程的开销会很大。</p>\n<h4><a id=\"_12\"></a>非公平锁</h4>\n<p>多个线程去获取锁的时候，会直接去尝试获取，获取不到，再去进入等待队列，如果能获取到，就直接获取到锁。<br />\n优点：可以减少CPU唤醒线程的开销，整体的吞吐效率会高点，CPU也不必取唤醒所有线程，会减少唤起线程的数量。<br />\n缺点：你们可能也发现了，这样可能导致队列中间的线程一直获取不到锁或者长时间获取不到锁，导致饿死。</p>\n', 1658759520274464770);
INSERT INTO `ms_article_body` VALUES (1658761194200219651, '# 前言\n接上一篇Linux系统下创建dotnet项目，这一篇我们聊聊.NET6环境下dotnet项目连接数据库的方式方法，包括数据库字符串该如何配置。看了很多博主写的文章，连接数据库字符串配置的方式和位置五花八门，这篇文章给大家介绍一下连接数据库字符串的配置方式方法，顺便介绍下一个新创建的dotnet项目的各个模块的作用。\n\n# 各模块作用\n在这里插入图片描述\n① Properties -- launchSettings.json\n\nlaunchSettings.json文件是 ASP.NET Core 应用特有的配置标准，用于应用的启动准备工作，包括环境变量，开发端口等。在launchSettings.json文件中进行配置和右键项目--【属性】--【调试】中所提交的更改的效果是一样的，并且支持同步更新。\n②依赖项\n\n依赖项组织了项目开发与运行时所需的DLL，分布在不同的类别下：包、分析器、框架、项目。\n③ Controllers\n\nControllers 目录用于存放MVC编程框架下的控制器类文件。\n④ appsettings.json\n\nappsettings.json 是 ASP.NET Core 默认提供的系统配置文件。与 ASP.NET WeForm、ASP.NET MVC 中的 web.config 文件功能类似。\n\nASP.NET Core 支持利用环境变量来动态配置 JSON 文件。ASP.NET Core 引用了一个特定的环境变量 ASPNETCORE_ENVIRONMENT 来描述应用程序当前运行的环境。这个变量可以被设置为任何你喜欢的值，但是有三个值被约定使用： Development，Staging 和 Production。\n⑤Program.cs\n\nProgram.cs 是 Asp.Net Core 的入口文件。它负责创建、配置和运行泛型主机（Host），ASP.NET Core应用程序需要在泛型主机中执行。\n补充说明：有的同学创建的项目里面没有Program.cs，但是有Startup文件，也是一样的，只是写法略有不同。\n\n# 添加依赖\n添加依赖的命令是dotnet add package xxxx.xxx\n```\n//添加SqlServer依赖\ndotnet add package Microsoft.EntityFrameworkCore.SqlServer\n//添加MySQL依赖\ndotnet add package MySql.EntityFrameworkCor\n//添加Sqlite依赖\ndotnet add package Microsoft.Data.Sqlite.Core\n```\n# 连接数据库字符串到底该写在哪里\n通过对各个模块作用的介绍，我们知道连接数据库的字符串肯定是写在appsettings.json文件里面，有的人把连接数据库字符串写在上下文类文件中，或者写在Program.cs文件中，也不是不可以，不过不是规范的写法。举个例子，当你的项目发布部署以后，要求更改新的数据库服务地址，怎么办？我们都知道.NET项目编译以后，所有.cs文件都会被编译为DLL文件，想修改里面的内容就需要重新编译，也就是说之前发布好的项目是不能用了，但是.json文件没有编译。如果你的连接数据库字符串写在Program.cs文件中，那么只能重新编译发布。如果连接数据库字符串写在了appsettings.json中，则只需要修改appsettings.json文件即可。现在知道连接数据库字符串到底该写在哪里了吧。\n在这里插入图片描述\n在这里插入图片描述\n以上都是不规范的写法。\n\n# 几种数据库的配置方法\n下面逐一介绍MySQL、SQL server、sqlite数据的连接方式\n\n## MySQL\nappsettings.json中添加下面内容，其中MySqlDataBase可以自己定义，见名识意就好哦。后面的内容根据自己的实际情况修改就好。\n```\n\"ConnectionStrings\": {\n    \"MySqlDataBase\": \"Server=127.0.0.1;Port=3306;User Id=xxx;Password=xxx;Database=xxx\"\n  }\n```\nProgram.cs文件中添加如下内容。其中\"MySqlDataBase\"为appsettings.json中定义的名字。MynetContext为你数据上下文类名。\n```\nbuilder.Services.AddDbContext<MynetContext>(\n    options =>\n    {\n        options.UseMySql(builder.Configuration.GetConnectionString(\"MySqlDataBase\"), new MySqlServerVersion(new Version(8, 0, 31)));\n    });\n```\n## SQL server\nappsettings.json中添加下面内容，其中\"MVCSqlContext\"可以自己定义，见名识意就好哦。后面的内容根据自己的实际情况修改就好。\n\n\"ConnectionStrings\": {\n    \"MVCSqlContext\": \"Server=localhost;Database=InfoUser;User ID=sa;Password=sa;\"\n  }\nProgram.cs文件中添加如下内容。其中\"MVCSqlContext\"为appsettings.json中定义的名字。MynetContext为你数据上下文类名。\n```\nbuilder.Services.AddDbContext<MynetContext>(\n    options =>\n    {\n        options.UseSqlServer(builder.Configuration.GetConnectionString(\"MVCSqlContext\"));\n    });\n```\nSQLite\nappsettings.json中添加下面内容，其中\"DefaultConnection\"可以自己定义，见名识意就好哦。后面的内容根据自己的实际情况修改就好。\n```\n\"ConnectionStrings\": {\n    \"DefaultConnection\": \"DataSource=app.db;Cache=Shared\"\n  }\n```\nProgram.cs文件中添加如下内容。其中\"DefaultConnection\"为appsettings.json中定义的名字。MynetContext为你数据上下文类名。\n```\nbuilder.Services.AddDbContext<MynetContext>(\n    options =>\n    {\n        options.UseSqlite(builder.Configuration.GetConnectionString(\"DefaultConnection\"));\n    });\n```\n补充：为防止有人不知道在Startup文件怎么写，这里给一个示例：\n```\n public void ConfigureServices(IServiceCollection services)\n        {\n            services.AddRazorPages();\n \n            services.AddDbContext<PrizeContext>(options => options.UseSqlite(Configuration.GetConnectionString(\"DefaultConnection\")));\n        }\n```', '<h1><a id=\"_0\"></a>前言</h1>\n<p>接上一篇Linux系统下创建dotnet项目，这一篇我们聊聊.NET6环境下dotnet项目连接数据库的方式方法，包括数据库字符串该如何配置。看了很多博主写的文章，连接数据库字符串配置的方式和位置五花八门，这篇文章给大家介绍一下连接数据库字符串的配置方式方法，顺便介绍下一个新创建的dotnet项目的各个模块的作用。</p>\n<h1><a id=\"_3\"></a>各模块作用</h1>\n<p>在这里插入图片描述<br />\n① Properties – launchSettings.json</p>\n<p>launchSettings.json文件是 ASP.NET Core 应用特有的配置标准，用于应用的启动准备工作，包括环境变量，开发端口等。在launchSettings.json文件中进行配置和右键项目–【属性】–【调试】中所提交的更改的效果是一样的，并且支持同步更新。<br />\n②依赖项</p>\n<p>依赖项组织了项目开发与运行时所需的DLL，分布在不同的类别下：包、分析器、框架、项目。<br />\n③ Controllers</p>\n<p>Controllers 目录用于存放MVC编程框架下的控制器类文件。<br />\n④ appsettings.json</p>\n<p>appsettings.json 是 ASP.NET Core 默认提供的系统配置文件。与 ASP.NET WeForm、ASP.NET MVC 中的 web.config 文件功能类似。</p>\n<p>ASP.NET Core 支持利用环境变量来动态配置 JSON 文件。ASP.NET Core 引用了一个特定的环境变量 ASPNETCORE_ENVIRONMENT 来描述应用程序当前运行的环境。这个变量可以被设置为任何你喜欢的值，但是有三个值被约定使用： Development，Staging 和 Production。<br />\n⑤Program.cs</p>\n<p>Program.cs 是 Asp.Net Core 的入口文件。它负责创建、配置和运行泛型主机（Host），ASP.NET Core应用程序需要在泛型主机中执行。<br />\n补充说明：有的同学创建的项目里面没有Program.cs，但是有Startup文件，也是一样的，只是写法略有不同。</p>\n<h1><a id=\"_24\"></a>添加依赖</h1>\n<p>添加依赖的命令是dotnet add package xxxx.xxx</p>\n<pre><code class=\"lang-\">//添加SqlServer依赖\ndotnet add package Microsoft.EntityFrameworkCore.SqlServer\n//添加MySQL依赖\ndotnet add package MySql.EntityFrameworkCor\n//添加Sqlite依赖\ndotnet add package Microsoft.Data.Sqlite.Core\n</code></pre>\n<h1><a id=\"_34\"></a>连接数据库字符串到底该写在哪里</h1>\n<p>通过对各个模块作用的介绍，我们知道连接数据库的字符串肯定是写在appsettings.json文件里面，有的人把连接数据库字符串写在上下文类文件中，或者写在Program.cs文件中，也不是不可以，不过不是规范的写法。举个例子，当你的项目发布部署以后，要求更改新的数据库服务地址，怎么办？我们都知道.NET项目编译以后，所有.cs文件都会被编译为DLL文件，想修改里面的内容就需要重新编译，也就是说之前发布好的项目是不能用了，但是.json文件没有编译。如果你的连接数据库字符串写在Program.cs文件中，那么只能重新编译发布。如果连接数据库字符串写在了appsettings.json中，则只需要修改appsettings.json文件即可。现在知道连接数据库字符串到底该写在哪里了吧。<br />\n在这里插入图片描述<br />\n在这里插入图片描述<br />\n以上都是不规范的写法。</p>\n<h1><a id=\"_40\"></a>几种数据库的配置方法</h1>\n<p>下面逐一介绍MySQL、SQL server、sqlite数据的连接方式</p>\n<h2><a id=\"MySQL_43\"></a>MySQL</h2>\n<p>appsettings.json中添加下面内容，其中MySqlDataBase可以自己定义，见名识意就好哦。后面的内容根据自己的实际情况修改就好。</p>\n<pre><code class=\"lang-\">&quot;ConnectionStrings&quot;: {\n    &quot;MySqlDataBase&quot;: &quot;Server=127.0.0.1;Port=3306;User Id=xxx;Password=xxx;Database=xxx&quot;\n  }\n</code></pre>\n<p>Program.cs文件中添加如下内容。其中&quot;MySqlDataBase&quot;为appsettings.json中定义的名字。MynetContext为你数据上下文类名。</p>\n<pre><code class=\"lang-\">builder.Services.AddDbContext&lt;MynetContext&gt;(\n    options =&gt;\n    {\n        options.UseMySql(builder.Configuration.GetConnectionString(&quot;MySqlDataBase&quot;), new MySqlServerVersion(new Version(8, 0, 31)));\n    });\n</code></pre>\n<h2><a id=\"SQL_server_58\"></a>SQL server</h2>\n<p>appsettings.json中添加下面内容，其中&quot;MVCSqlContext&quot;可以自己定义，见名识意就好哦。后面的内容根据自己的实际情况修改就好。</p>\n<p>“ConnectionStrings”: {<br />\n“MVCSqlContext”: “Server=localhost;Database=InfoUser;User ID=sa;Password=sa;”<br />\n}<br />\nProgram.cs文件中添加如下内容。其中&quot;MVCSqlContext&quot;为appsettings.json中定义的名字。MynetContext为你数据上下文类名。</p>\n<pre><code class=\"lang-\">builder.Services.AddDbContext&lt;MynetContext&gt;(\n    options =&gt;\n    {\n        options.UseSqlServer(builder.Configuration.GetConnectionString(&quot;MVCSqlContext&quot;));\n    });\n</code></pre>\n<p>SQLite<br />\nappsettings.json中添加下面内容，其中&quot;DefaultConnection&quot;可以自己定义，见名识意就好哦。后面的内容根据自己的实际情况修改就好。</p>\n<pre><code class=\"lang-\">&quot;ConnectionStrings&quot;: {\n    &quot;DefaultConnection&quot;: &quot;DataSource=app.db;Cache=Shared&quot;\n  }\n</code></pre>\n<p>Program.cs文件中添加如下内容。其中&quot;DefaultConnection&quot;为appsettings.json中定义的名字。MynetContext为你数据上下文类名。</p>\n<pre><code class=\"lang-\">builder.Services.AddDbContext&lt;MynetContext&gt;(\n    options =&gt;\n    {\n        options.UseSqlite(builder.Configuration.GetConnectionString(&quot;DefaultConnection&quot;));\n    });\n</code></pre>\n<p>补充：为防止有人不知道在Startup文件怎么写，这里给一个示例：</p>\n<pre><code class=\"lang-\"> public void ConfigureServices(IServiceCollection services)\n        {\n            services.AddRazorPages();\n \n            services.AddDbContext&lt;PrizeContext&gt;(options =&gt; options.UseSqlite(Configuration.GetConnectionString(&quot;DefaultConnection&quot;)));\n        }\n</code></pre>\n', 1658761194200219649);
INSERT INTO `ms_article_body` VALUES (1658761730257436674, '在VB.NET中，您可以使用Substring方法或Split方法来截取字符串。\n\nSubstring方法允许您从字符串中提取一个子字符串，该子字符串从指定的起始索引开始，并继续到字符串的末尾或指定的长度。以下是使用Substring方法截取字符串的示例：\n```\nDim str As String = \"Hello World!\"\nDim subStr1 As String = str.Substring(0, 5) \'截取从索引0开始，长度为5的子字符串\nDim subStr2 As String = str.Substring(6) \'截取从索引6开始到字符串末尾的子字符串\n```\n在上面的代码中，我们首先定义了一个字符串“Hello World!”。然后，我们使用Substring方法截取了两个子字符串，其中第一个子字符串从索引0开始，长度为5，第二个子字符串从索引6开始到字符串末尾。\n\nSplit方法允许您将字符串拆分为子字符串数组，根据指定的分隔符。以下是使用Split方法截取字符串的示例：\n```\nDim str As String = \"Hello-World!\"\nDim parts As String() = str.Split(\"-\"c) \'根据“-”符号将字符串分割成多个部分\nDim part1 As String = parts(0) \'获取第一个部分\nDim part2 As String = parts(1) \'获取第二个部分\n```\n在上面的代码中，我们首先定义了一个字符串“Hello-World!”。然后，我们使用`Split`方法根据“-”符号将字符串分割成两个部分，并将这些部分存储在字符串数组中。最后，我们使用数组索引获取第一个部分和第二个部分。\n\n请注意，Split方法返回一个字符串数组，其中包含原始字符串中的所有子字符串。如果原始字符串中没有指定的分隔符，则Split方法返回包含原始字符串的单个元素的字符串数组。', '<p>在VB.NET中，您可以使用Substring方法或Split方法来截取字符串。</p>\n<p>Substring方法允许您从字符串中提取一个子字符串，该子字符串从指定的起始索引开始，并继续到字符串的末尾或指定的长度。以下是使用Substring方法截取字符串的示例：</p>\n<pre><code class=\"lang-\">Dim str As String = &quot;Hello World!&quot;\nDim subStr1 As String = str.Substring(0, 5) \'截取从索引0开始，长度为5的子字符串\nDim subStr2 As String = str.Substring(6) \'截取从索引6开始到字符串末尾的子字符串\n</code></pre>\n<p>在上面的代码中，我们首先定义了一个字符串“Hello World!”。然后，我们使用Substring方法截取了两个子字符串，其中第一个子字符串从索引0开始，长度为5，第二个子字符串从索引6开始到字符串末尾。</p>\n<p>Split方法允许您将字符串拆分为子字符串数组，根据指定的分隔符。以下是使用Split方法截取字符串的示例：</p>\n<pre><code class=\"lang-\">Dim str As String = &quot;Hello-World!&quot;\nDim parts As String() = str.Split(&quot;-&quot;c) \'根据“-”符号将字符串分割成多个部分\nDim part1 As String = parts(0) \'获取第一个部分\nDim part2 As String = parts(1) \'获取第二个部分\n</code></pre>\n<p>在上面的代码中，我们首先定义了一个字符串“Hello-World!”。然后，我们使用<code>Split</code>方法根据“-”符号将字符串分割成两个部分，并将这些部分存储在字符串数组中。最后，我们使用数组索引获取第一个部分和第二个部分。</p>\n<p>请注意，Split方法返回一个字符串数组，其中包含原始字符串中的所有子字符串。如果原始字符串中没有指定的分隔符，则Split方法返回包含原始字符串的单个元素的字符串数组。</p>\n', 1658761730190327810);
INSERT INTO `ms_article_body` VALUES (1658763647582846978, '# 前言\n我们在进行 Java 编程时，经常要打印对象，有的是查看是否拿到了该对象，有的是查看该对象中的数据。打印输出的却是一知半解的字符串，那么这个字符串是怎么来的？代表什么？我们如何打印出对象中的数据呢？\n\n# 一、Java中打印对象\n## 1.演示代码\n我们使用 Java 的 System.out 类可以打印输出对象，例如我们有一个 Student 类，有三个成员变量，一个有参构造方法，它的代码如下：\n\n点击查看代码\n```\n\npublic class Student {\n\n    private String name;\n    private String sex;\n    private Integer age;\n\n    public Student(String name, String sex, Integer age) {\n        this.name = name;\n        this.sex = sex;\n        this.age = age;\n    }\n}\n```\n然后我们新建测试类，创建 Student 对象，并直接使用 System.out.println 语句进行打印。\n```\npublic class Test {\n    public static void main(String[] args) {\n        Student student = new Student(\"张三\", \"男\", 16);\n        System.out.println(student);\n    }\n}\n```\n执行结果如下：\n```\ncom.example.Student@2f4d3709\n```\n## 2.提出问题\n通过演示代码运行结果可以看到打印输出的是当前包下的类名，还有@字符，还有一串数字和字母。打印出类名很好理解，但是`@`、数字、字母是什么意思呀？应该很多同学都不是很明白吧。\n\n# 二、深入分析\n## 1.打印的字符串是什么\n当我们在 Java 中使用 `System.out.println` 或者其他输出语句时，如果传入的参数不是字符串类型的数据，那么程序会自动调用该数据所属类的 `toString() `方法。目前 `Student`` 类中并没有 toString()` 方法呀，是所有 Java 类都直接或间接继承了 `Object `类，而 `Object `类中有一个默认的` toString() `方法，代码如下：\n```\npublic String toString() {\n    return getClass().getName() + \"@\" + Integer.toHexString(hashCode());\n}\n```\n该方法官方注释如下：\n```\n该方法返回对象的字符串表示形式。一般来说，toString 方法返回一个“文本表示”此对象的字符串。结果应该是一个简洁但信息丰富的表示，便于人们阅读。建议所有子类重写此方法。\nObject 类的 toString 方法返回一个字符串，该字符串由该对象作为其实例的类的名称、@符号字符’ @\'以及该对象哈希码的无符号十六进制表示形式组成。换句话说，这个方法返回的字符串等于的值：getClass().getName() + ‘@’ + Integer.toHexString(hashCode())\n```\n也就是我们的 `Student`` 没有重写 toString() `方法，而是自动调用了` Object` 类中的 `toString()` 方法。这时候我们打印输出的是一个字符串，其中包含对象的类名和哈希码。\n\n## 2.是对象的地址吗？\n有时候我们总是说打印了该对象的地址，其实是不准确的。打印的内容一个是类名，一个是哈希码。打印的对象的哈希码并不是引用地址，尽管在某些情况下它们可能看起来像是一样的。\n\n哈希码是一个整数，它是由Java运行时环境根据对象的内部状态计算出来的。对于一个类的任何两个不同的实例，它们的哈希码通常不会相同。也就是说，如果在打印一个对象时，看到了两个不同的哈希码，可以确定这两个对象是不同的，它们占用不同的内存空间。\n\n而引用地址是内存中的一个地址值，它表示某个对象在内存中的位置。对于同一个对象，无论它被引用多少次，它的引用地址始终是相同的。两个不同的对象的引用地址也是不同的。\n\n通常情况下，打印一个 Java 对象时显示的是该对象的字符串表示，这个字符串既包括了实例的哈希码，也包括了它的一些其他信息。因此，在某些情况下，打印出来的哈希码和引用地址可能看起来相同，但实际上它们是不同的概念。\n\n# 三、打印对象内部信息\n如何打印对象内部信息呢，比如打印出对象中姓名、性别和年龄。这时需要我们自定义或是重写 `Student `类的 `toString()` 方法。如下代码中我们重写 `toString()` 方法：\n```\npublic class Student {\n    private String name;\n    private String sex;\n    private Integer age;\n\n    public Student(String name, String sex, Integer age) {\n        this.name = name;\n        this.sex = sex;\n        this.age = age;\n    }\n\n    @Override\n    public String toString() {\n        return \"Student{\" +\n                \"name=\'\" + name + \'\\\'\' +\n                \", sex=\'\" + sex + \'\\\'\' +\n                \", age=\" + age +\n                \'}\';\n    }\n}\n\n```\n我们再次执行 Test 中的 main() 方法，可得结果如下：\n```\nStudent{name=\'张三\', sex=\'男\', age=16}\n```\n这时就调用了被重写的 `toString()` 方法，并按照我们的意愿对 `student` 对象进行了打印输出。\n\n总结\n这里我们知道了 `Java` 中打印对象，如果没有重写 `toString()` 方法，那么调用执行的是 Object 类中的 toString() 方法，会打印该对象的类名和哈希码，而它的哈希码也不是对象的地址。如果想更好的输出对象信息，可以重写 toString() 方法。', '<h1><a id=\"_0\"></a>前言</h1>\n<p>我们在进行 Java 编程时，经常要打印对象，有的是查看是否拿到了该对象，有的是查看该对象中的数据。打印输出的却是一知半解的字符串，那么这个字符串是怎么来的？代表什么？我们如何打印出对象中的数据呢？</p>\n<h1><a id=\"Java_3\"></a>一、Java中打印对象</h1>\n<h2><a id=\"1_4\"></a>1.演示代码</h2>\n<p>我们使用 Java 的 System.out 类可以打印输出对象，例如我们有一个 Student 类，有三个成员变量，一个有参构造方法，它的代码如下：</p>\n<p>点击查看代码</p>\n<pre><code class=\"lang-\">\npublic class Student {\n\n    private String name;\n    private String sex;\n    private Integer age;\n\n    public Student(String name, String sex, Integer age) {\n        this.name = name;\n        this.sex = sex;\n        this.age = age;\n    }\n}\n</code></pre>\n<p>然后我们新建测试类，创建 Student 对象，并直接使用 System.out.println 语句进行打印。</p>\n<pre><code class=\"lang-\">public class Test {\n    public static void main(String[] args) {\n        Student student = new Student(&quot;张三&quot;, &quot;男&quot;, 16);\n        System.out.println(student);\n    }\n}\n</code></pre>\n<p>执行结果如下：</p>\n<pre><code class=\"lang-\">com.example.Student@2f4d3709\n</code></pre>\n<h2><a id=\"2_36\"></a>2.提出问题</h2>\n<p>通过演示代码运行结果可以看到打印输出的是当前包下的类名，还有@字符，还有一串数字和字母。打印出类名很好理解，但是<code>@</code>、数字、字母是什么意思呀？应该很多同学都不是很明白吧。</p>\n<h1><a id=\"_39\"></a>二、深入分析</h1>\n<h2><a id=\"1_40\"></a>1.打印的字符串是什么</h2>\n<p>当我们在 Java 中使用 <code>System.out.println</code> 或者其他输出语句时，如果传入的参数不是字符串类型的数据，那么程序会自动调用该数据所属类的 <code>toString() </code>方法。目前 <code>Student`` 类中并没有 toString()</code> 方法呀，是所有 Java 类都直接或间接继承了 <code>Object </code>类，而 <code>Object </code>类中有一个默认的<code>toString()</code>方法，代码如下：</p>\n<pre><code class=\"lang-\">public String toString() {\n    return getClass().getName() + &quot;@&quot; + Integer.toHexString(hashCode());\n}\n</code></pre>\n<p>该方法官方注释如下：</p>\n<pre><code class=\"lang-\">该方法返回对象的字符串表示形式。一般来说，toString 方法返回一个“文本表示”此对象的字符串。结果应该是一个简洁但信息丰富的表示，便于人们阅读。建议所有子类重写此方法。\nObject 类的 toString 方法返回一个字符串，该字符串由该对象作为其实例的类的名称、@符号字符’ @\'以及该对象哈希码的无符号十六进制表示形式组成。换句话说，这个方法返回的字符串等于的值：getClass().getName() + ‘@’ + Integer.toHexString(hashCode())\n</code></pre>\n<p>也就是我们的 <code>Student`` 没有重写 toString() </code>方法，而是自动调用了<code> Object</code> 类中的 <code>toString()</code> 方法。这时候我们打印输出的是一个字符串，其中包含对象的类名和哈希码。</p>\n<h2><a id=\"2_54\"></a>2.是对象的地址吗？</h2>\n<p>有时候我们总是说打印了该对象的地址，其实是不准确的。打印的内容一个是类名，一个是哈希码。打印的对象的哈希码并不是引用地址，尽管在某些情况下它们可能看起来像是一样的。</p>\n<p>哈希码是一个整数，它是由Java运行时环境根据对象的内部状态计算出来的。对于一个类的任何两个不同的实例，它们的哈希码通常不会相同。也就是说，如果在打印一个对象时，看到了两个不同的哈希码，可以确定这两个对象是不同的，它们占用不同的内存空间。</p>\n<p>而引用地址是内存中的一个地址值，它表示某个对象在内存中的位置。对于同一个对象，无论它被引用多少次，它的引用地址始终是相同的。两个不同的对象的引用地址也是不同的。</p>\n<p>通常情况下，打印一个 Java 对象时显示的是该对象的字符串表示，这个字符串既包括了实例的哈希码，也包括了它的一些其他信息。因此，在某些情况下，打印出来的哈希码和引用地址可能看起来相同，但实际上它们是不同的概念。</p>\n<h1><a id=\"_63\"></a>三、打印对象内部信息</h1>\n<p>如何打印对象内部信息呢，比如打印出对象中姓名、性别和年龄。这时需要我们自定义或是重写 <code>Student </code>类的 <code>toString()</code> 方法。如下代码中我们重写 <code>toString()</code> 方法：</p>\n<pre><code class=\"lang-\">public class Student {\n    private String name;\n    private String sex;\n    private Integer age;\n\n    public Student(String name, String sex, Integer age) {\n        this.name = name;\n        this.sex = sex;\n        this.age = age;\n    }\n\n    @Override\n    public String toString() {\n        return &quot;Student{&quot; +\n                &quot;name=\'&quot; + name + \'\\\'\' +\n                &quot;, sex=\'&quot; + sex + \'\\\'\' +\n                &quot;, age=&quot; + age +\n                \'}\';\n    }\n}\n\n</code></pre>\n<p>我们再次执行 Test 中的 main() 方法，可得结果如下：</p>\n<pre><code class=\"lang-\">Student{name=\'张三\', sex=\'男\', age=16}\n</code></pre>\n<p>这时就调用了被重写的 <code>toString()</code> 方法，并按照我们的意愿对 <code>student</code> 对象进行了打印输出。</p>\n<p>总结<br />\n这里我们知道了 <code>Java</code> 中打印对象，如果没有重写 <code>toString()</code> 方法，那么调用执行的是 Object 类中的 toString() 方法，会打印该对象的类名和哈希码，而它的哈希码也不是对象的地址。如果想更好的输出对象信息，可以重写 toString() 方法。</p>\n', 1658763647515738114);
INSERT INTO `ms_article_body` VALUES (1658764793571557378, '# 前言\n公司展示大屏需要写滚动表格，通过滚动播放数据，自己随便摸了一个基于动画的自动滚动表格\n# 原理\n根据每行的大小和设置的每行滚动时间设置滚动位置，动态添加动画，并把数组第一项移动到最后一项，并订阅该动画结束的事件，在结束时循环执行该操作。\n# 其他功能\n- 可自定义单元格或行\n- 可设置中文映射和取消显示\n- 单元格默认基于网格的响应式大小\n- 鼠标进入时可设置暂停\n# 代码\n```\n<template>\n      <div class=\"title-container\" v-if=\"!props.noTitle\">\n        <div\n          v-for=\"item in props.displayTitles ?? Object.keys(props. List[0])\"\n          :key=\"item\"\n        >\n          {{ props.titleMapping?.get(item) ?? item }}\n        </div>\n      </div>\n    <div class=\"scroll-table\">\n      <div\n        ref=\"container\"\n        class=\"container\"\n        v-on:mouseenter=\"() => {if(props.pauseWhenMouseEnter) animation?.pause()}\"\n        v-on:mouseleave=\"() => {if(props.pauseWhenMouseEnter) animation?.play()}\"\n      >\n        <!-- 行插槽，作用于每个单元格，设置每个单元格的格式，设置 item-container 类型可继承组件定义的样式 -->\n        <slot\n          name=\"row\"\n          v-for=\"(item, index) in innerList\"\n          :key=\"item.id\"\n          :item=\"item\"\n          :index=\"index\"\n        >\n          <div class=\"item-container\">\n            <!-- 默认插槽，作用于每个单元格，设置每个单元格的格式，设置 item 类型可继承组件定义的样式 -->\n            <slot\n              v-for=\"key in props.displayTitles ?? Object.keys(props.list[0])\"\n              :key=\"key\"\n              :item=\"Object.keys(item.data).includes(key) ? item.data[key] ? item.data[key] : props.undefinedPlaceholder : props.undefinedPlaceholder\"\n            >\n              <div class=\"item\">\n                {{ Object.keys(item.data).includes(key) ? item.data[key] ? item.data[key] : props.undefinedPlaceholder : props.undefinedPlaceholder }}\n              </div>\n            </slot>\n          </div>\n        </slot>\n      </div>\n    </div>\n</template>\n\n<script setup lang=\"ts\">\nimport BaseBox from \"./BaseBox.vue\";\nimport {\n  defineProps,\n  withDefaults,\n  onMounted,\n  computed,\n  ref,\n  watch,\n} from \"vue\";\nconst props = withDefaults(\n  defineProps<{\n    // 属性名翻译为标题，默认值 属性名列表\n    titleMapping?: Map<string, string>;\n    // 列宽，与 grid-template-columns 格式，默认值 repeat(${props.displayTitles?.length ?? Object.keys(props.list[0]).length}, 1fr)\n    columnSizes?: string;\n    // 列表\n    list: Array<any>;\n    // 展示哪些标题，默认值 全部展示\n    displayTitles?: Array<string>;\n    // 走完每一行的时间，默认值 2300 ms\n    interval?: number;\n    // 是否显示标题行，默认值 true\n    noTitle?: Boolean;\n    // 属性无参数时替换为某字符串，默认值 --\n    undefinedPlaceholder?: string;\n    // 鼠标进入时暂停，默认值 true\n    pauseWhenMouseEnter?: Boolean;\n  }>(),\n  {\n    interval: 2300,\n    noTitle: false,\n    undefinedPlaceholder: \"--\",\n    pauseWhenMouseEnter: false,\n  }\n);\nconst innerList = ref<Array<{ id: number; data: any }>>(\n  props.list.map((item, index) => ({ id: index, data: item }))\n);\nconst container = ref<HTMLDivElement>();\nonMounted(() => {\n  animate(true);\n});\n// 监控数据列表更新\nwatch(\n  () => props.list,\n  () => {\n    innerList.value = props.list.map((item, index) => ({\n      id: index,\n      data: item,\n    }));\n  }\n);\n// 计算列大小\nconst columnSize = computed(() => {\n  return (\n    props.columnSizes ??\n    `repeat(${\n      props.displayTitles?.length ?? Object.keys(props.list[0]).length\n    }, 1fr)`\n  );\n});\n// 进行动画\nconst animation = ref<Animation>();\nconst animate = (isStart = false) => {\n  // 计算动画高度\n  let height = 0;\n  if (!isStart) {\n    height = -container.value!.children[1].getBoundingClientRect().height;\n    // 移动数组第一个到最后一个\n    let temp = innerList.value.shift();\n    innerList.value.push(temp!);\n  } else {\n    height = -container.value!.children[0].getBoundingClientRect().height;\n  }\n  // 进行动画\n  animation.value = container.value!.animate(\n    [\n      {\n        top: `${height}px`,\n      },\n    ],\n    {\n      duration: props.interval,\n      iterations: 1,\n    }\n  );\n  // 监听动画完成后，重新开始动画\n  animation.value.addEventListener(\"finish\", () => animate(false));\n};\n</script>\n\n<style scoped lang=\"scss\">\n.title-container {\n  display: grid;\n  padding: 1rem 0;\n  font-size: 1.25rem;\n  background-color: rgb(24, 34, 103);\n  grid-template-columns: v-bind(columnSize);\n  text-align: center;\n}\n:slotted(.item-container),\n.item-container {\n  overflow: hidden;\n  position: relative;\n  left: 0;\n  right: 0;\n  top: 0;\n  display: grid;\n  padding: 1rem 0;\n  grid-template-columns: v-bind(columnSize);\n}\n:slotted(.item),\n.item {\n  text-align: center;\n  font-size: 1.25rem;\n}\n.scroll-table {\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n\n  .container {\n    overflow: hidden;\n    position: relative;\n    left: 0;\n    right: 0;\n    top: 0;\n  }\n}\n</style>\n```', '<h1><a id=\"_0\"></a>前言</h1>\n<p>公司展示大屏需要写滚动表格，通过滚动播放数据，自己随便摸了一个基于动画的自动滚动表格</p>\n<h1><a id=\"_2\"></a>原理</h1>\n<p>根据每行的大小和设置的每行滚动时间设置滚动位置，动态添加动画，并把数组第一项移动到最后一项，并订阅该动画结束的事件，在结束时循环执行该操作。</p>\n<h1><a id=\"_4\"></a>其他功能</h1>\n<ul>\n<li>可自定义单元格或行</li>\n<li>可设置中文映射和取消显示</li>\n<li>单元格默认基于网格的响应式大小</li>\n<li>鼠标进入时可设置暂停</li>\n</ul>\n<h1><a id=\"_9\"></a>代码</h1>\n<pre><code class=\"lang-\">&lt;template&gt;\n      &lt;div class=&quot;title-container&quot; v-if=&quot;!props.noTitle&quot;&gt;\n        &lt;div\n          v-for=&quot;item in props.displayTitles ?? Object.keys(props. List[0])&quot;\n          :key=&quot;item&quot;\n        &gt;\n          {{ props.titleMapping?.get(item) ?? item }}\n        &lt;/div&gt;\n      &lt;/div&gt;\n    &lt;div class=&quot;scroll-table&quot;&gt;\n      &lt;div\n        ref=&quot;container&quot;\n        class=&quot;container&quot;\n        v-on:mouseenter=&quot;() =&gt; {if(props.pauseWhenMouseEnter) animation?.pause()}&quot;\n        v-on:mouseleave=&quot;() =&gt; {if(props.pauseWhenMouseEnter) animation?.play()}&quot;\n      &gt;\n        &lt;!-- 行插槽，作用于每个单元格，设置每个单元格的格式，设置 item-container 类型可继承组件定义的样式 --&gt;\n        &lt;slot\n          name=&quot;row&quot;\n          v-for=&quot;(item, index) in innerList&quot;\n          :key=&quot;item.id&quot;\n          :item=&quot;item&quot;\n          :index=&quot;index&quot;\n        &gt;\n          &lt;div class=&quot;item-container&quot;&gt;\n            &lt;!-- 默认插槽，作用于每个单元格，设置每个单元格的格式，设置 item 类型可继承组件定义的样式 --&gt;\n            &lt;slot\n              v-for=&quot;key in props.displayTitles ?? Object.keys(props.list[0])&quot;\n              :key=&quot;key&quot;\n              :item=&quot;Object.keys(item.data).includes(key) ? item.data[key] ? item.data[key] : props.undefinedPlaceholder : props.undefinedPlaceholder&quot;\n            &gt;\n              &lt;div class=&quot;item&quot;&gt;\n                {{ Object.keys(item.data).includes(key) ? item.data[key] ? item.data[key] : props.undefinedPlaceholder : props.undefinedPlaceholder }}\n              &lt;/div&gt;\n            &lt;/slot&gt;\n          &lt;/div&gt;\n        &lt;/slot&gt;\n      &lt;/div&gt;\n    &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script setup lang=&quot;ts&quot;&gt;\nimport BaseBox from &quot;./BaseBox.vue&quot;;\nimport {\n  defineProps,\n  withDefaults,\n  onMounted,\n  computed,\n  ref,\n  watch,\n} from &quot;vue&quot;;\nconst props = withDefaults(\n  defineProps&lt;{\n    // 属性名翻译为标题，默认值 属性名列表\n    titleMapping?: Map&lt;string, string&gt;;\n    // 列宽，与 grid-template-columns 格式，默认值 repeat(${props.displayTitles?.length ?? Object.keys(props.list[0]).length}, 1fr)\n    columnSizes?: string;\n    // 列表\n    list: Array&lt;any&gt;;\n    // 展示哪些标题，默认值 全部展示\n    displayTitles?: Array&lt;string&gt;;\n    // 走完每一行的时间，默认值 2300 ms\n    interval?: number;\n    // 是否显示标题行，默认值 true\n    noTitle?: Boolean;\n    // 属性无参数时替换为某字符串，默认值 --\n    undefinedPlaceholder?: string;\n    // 鼠标进入时暂停，默认值 true\n    pauseWhenMouseEnter?: Boolean;\n  }&gt;(),\n  {\n    interval: 2300,\n    noTitle: false,\n    undefinedPlaceholder: &quot;--&quot;,\n    pauseWhenMouseEnter: false,\n  }\n);\nconst innerList = ref&lt;Array&lt;{ id: number; data: any }&gt;&gt;(\n  props.list.map((item, index) =&gt; ({ id: index, data: item }))\n);\nconst container = ref&lt;HTMLDivElement&gt;();\nonMounted(() =&gt; {\n  animate(true);\n});\n// 监控数据列表更新\nwatch(\n  () =&gt; props.list,\n  () =&gt; {\n    innerList.value = props.list.map((item, index) =&gt; ({\n      id: index,\n      data: item,\n    }));\n  }\n);\n// 计算列大小\nconst columnSize = computed(() =&gt; {\n  return (\n    props.columnSizes ??\n    `repeat(${\n      props.displayTitles?.length ?? Object.keys(props.list[0]).length\n    }, 1fr)`\n  );\n});\n// 进行动画\nconst animation = ref&lt;Animation&gt;();\nconst animate = (isStart = false) =&gt; {\n  // 计算动画高度\n  let height = 0;\n  if (!isStart) {\n    height = -container.value!.children[1].getBoundingClientRect().height;\n    // 移动数组第一个到最后一个\n    let temp = innerList.value.shift();\n    innerList.value.push(temp!);\n  } else {\n    height = -container.value!.children[0].getBoundingClientRect().height;\n  }\n  // 进行动画\n  animation.value = container.value!.animate(\n    [\n      {\n        top: `${height}px`,\n      },\n    ],\n    {\n      duration: props.interval,\n      iterations: 1,\n    }\n  );\n  // 监听动画完成后，重新开始动画\n  animation.value.addEventListener(&quot;finish&quot;, () =&gt; animate(false));\n};\n&lt;/script&gt;\n\n&lt;style scoped lang=&quot;scss&quot;&gt;\n.title-container {\n  display: grid;\n  padding: 1rem 0;\n  font-size: 1.25rem;\n  background-color: rgb(24, 34, 103);\n  grid-template-columns: v-bind(columnSize);\n  text-align: center;\n}\n:slotted(.item-container),\n.item-container {\n  overflow: hidden;\n  position: relative;\n  left: 0;\n  right: 0;\n  top: 0;\n  display: grid;\n  padding: 1rem 0;\n  grid-template-columns: v-bind(columnSize);\n}\n:slotted(.item),\n.item {\n  text-align: center;\n  font-size: 1.25rem;\n}\n.scroll-table {\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n\n  .container {\n    overflow: hidden;\n    position: relative;\n    left: 0;\n    right: 0;\n    top: 0;\n  }\n}\n&lt;/style&gt;\n</code></pre>\n', 1658764793500254210);
INSERT INTO `ms_article_body` VALUES (1658766617301073922, '# 冒泡排序---稳定\n冒泡排序（Bubble Sort）是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。\n```\n        for (int i = 0; i <arr.length-1; i++) {//第几轮\n            boolean flag=false;//是否交换过\n            for (int j = 0; j <arr.length-i-1; j++) {//两两比较\n                if (arr[j]>arr[j+1]){\n                    int tmp=arr[j];\n                    arr[j]=arr[j+1];\n                    arr[j+1]=tmp;\n                    flag=true;\n                }\n            }\n            if (!flag) {//如果没有交换，说明提前排好序了，直接结束\n                break;\n            }\n        }\n```\n\n|平均时间复杂度	|最好	|最坏	|空间复杂度|\n|------|-----|----|----|\n|O(n²)	|O(n)	|O(n²)|	O(1)\n# 快速排序---不稳定\n双边快排\n```\n//快速排序\n    public void QuickSort(int[] arr, int l, int h) {\n        if (l >= h) {\n            return;\n        }\n        int tmp = arr[l];//第一个数为基准\n        int i = l;\n        int j = h;\n        while (i < j) {\n            //j从右向左\n            while (i < j && arr[j] > tmp) {\n                j--;\n            }\n            //i从左向右走\n            while (i < j && arr[i] <= tmp) {\n                i++;\n            }\n            swep(arr, i, j);\n\n        }\n        //基点交换\n        swep(arr, l, j);\n        QuickSort(arr,l,i-1);//左边递归\n        QuickSort(arr,i+1,h);\n        // return i;\n    }\n```', '<h1><a id=\"_0\"></a>冒泡排序—稳定</h1>\n<p>冒泡排序（Bubble Sort）是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。</p>\n<pre><code class=\"lang-\">        for (int i = 0; i &lt;arr.length-1; i++) {//第几轮\n            boolean flag=false;//是否交换过\n            for (int j = 0; j &lt;arr.length-i-1; j++) {//两两比较\n                if (arr[j]&gt;arr[j+1]){\n                    int tmp=arr[j];\n                    arr[j]=arr[j+1];\n                    arr[j+1]=tmp;\n                    flag=true;\n                }\n            }\n            if (!flag) {//如果没有交换，说明提前排好序了，直接结束\n                break;\n            }\n        }\n</code></pre>\n<table>\n<thead>\n<tr>\n<th>平均时间复杂度</th>\n<th>最好</th>\n<th>最坏</th>\n<th>空间复杂度</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>O(n²)</td>\n<td>O(n)</td>\n<td>O(n²)</td>\n<td>O(1)</td>\n</tr>\n</tbody>\n</table>\n<h1><a id=\"_22\"></a>快速排序—不稳定</h1>\n<p>双边快排</p>\n<pre><code class=\"lang-\">//快速排序\n    public void QuickSort(int[] arr, int l, int h) {\n        if (l &gt;= h) {\n            return;\n        }\n        int tmp = arr[l];//第一个数为基准\n        int i = l;\n        int j = h;\n        while (i &lt; j) {\n            //j从右向左\n            while (i &lt; j &amp;&amp; arr[j] &gt; tmp) {\n                j--;\n            }\n            //i从左向右走\n            while (i &lt; j &amp;&amp; arr[i] &lt;= tmp) {\n                i++;\n            }\n            swep(arr, i, j);\n\n        }\n        //基点交换\n        swep(arr, l, j);\n        QuickSort(arr,l,i-1);//左边递归\n        QuickSort(arr,i+1,h);\n        // return i;\n    }\n</code></pre>\n', 1658766617233965058);
INSERT INTO `ms_article_body` VALUES (1658768565131657219, '# 简单选择排序---不稳定\n选择排序在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后以此类推，直到所有元素均排序完毕。\n```\n	 for (int i = 0; i < arr.length; i++) {\n            //记录最小值下标位置\n            int min=i;\n            for (int j=i+1;j<arr.length;j++){\n                if (arr[i]>arr[j]){\n                    min=j;\n                }\n            }\n            //交换位置\n            if (min != i) {\n                int tmp=arr[i];\n                arr[i]=arr[min];\n                arr[min]=tmp;//如果有两个相同的值，2，2，1，这种情况，第一次排序时，第一个2到了1的位置，所以排序不稳定\n            }\n        }\n```\n\n|平均时间复杂度	|最好	|最坏	|空间复杂度|\n|------|-----|----|----|\n|O(n²)	|O(n²)	|O(n²)|	O(1)\n# 堆排序---不稳定\n![2993839202304242012385391131211721.png](http://ruizmypmv.hn-bkt.clouddn.com/7d02432c-71a8-4796-a796-14bd192ac85a.png)\n1.父结点索引：(i-1)/2（这里计算机中的除以2，省略掉小数）\n2.左孩子索引：2i+1\n3.右孩子索引：2i+2\n升序用大顶堆，降序用小顶堆。\n```\n	//维护堆,参数为数组和当前需要维护的根节点,len表示堆中有多少元素\n    public void heapify(int[] arr,int len, int i) {\n        // 最大值节点\n        int max = i;\n        int lChild = i * 2 + 1;\n        int rChild = i * 2 + 2;\n        //找出孩子节点中最大的那个值，然后交换\n        if (lChild < len && arr[lChild] > arr[max]) {\n            max=lChild;\n        }\n        if (rChild < len && arr[rChild] > arr[max]) {\n            max=rChild;\n        }\n        //交换节点位置\n        if (max != i) {\n            swep(arr,i,max);\n            //递归维护之后的节点\n            heapify(arr,len,max);\n        }\n    }\n    //交换节点\n    public void swep(int[] arr,int i,int j){\n        int tmp=arr[i];\n        arr[i]=arr[j];\n        arr[j]=tmp;\n    }\n\n    //堆排序\n    public void heapSort(int[] arr) {\n        //建堆,i表示最后一个非叶子节点\n        for (int i = arr.length/2-1; i >=0; i--) {\n            heapify(arr,arr.length,i);\n        }\n        //排序，将堆顶元素和最后一个元素交换，然后将最后一个元素移除堆，维护堆，再将倒数第二个元素和堆顶元素交换......\n        for (int j = arr.length - 1; j >0 ; j--) {\n            swep(arr,j,0);\n            //最后一个元素不需要参与维护，所以长度是arr.length-1,一次减少一次\n            heapify(arr,j,0);\n        }\n    }\n```\n1.建立堆的过程, 从length/2 一直处理到0, 时间复杂度为O(n);\n2.调整堆的过程是沿着堆的父子节点进行调整, 执行次数为堆的深度, 时间复杂度为O(lgn);\n3.堆排序的过程由n次第2步完成, 时间复杂度为O(nlgn).\n\n|平均时间复杂度	|最好	|最坏	|空间复杂度|\n|------|-----|----|----|\n|O(nlog2n)|O(nlog2n)	|O(nlog2n)|	O(1)', '<h1><a id=\"_0\"></a>简单选择排序—不稳定</h1>\n<p>选择排序在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后以此类推，直到所有元素均排序完毕。</p>\n<pre><code class=\"lang-\">	 for (int i = 0; i &lt; arr.length; i++) {\n            //记录最小值下标位置\n            int min=i;\n            for (int j=i+1;j&lt;arr.length;j++){\n                if (arr[i]&gt;arr[j]){\n                    min=j;\n                }\n            }\n            //交换位置\n            if (min != i) {\n                int tmp=arr[i];\n                arr[i]=arr[min];\n                arr[min]=tmp;//如果有两个相同的值，2，2，1，这种情况，第一次排序时，第一个2到了1的位置，所以排序不稳定\n            }\n        }\n</code></pre>\n<table>\n<thead>\n<tr>\n<th>平均时间复杂度</th>\n<th>最好</th>\n<th>最坏</th>\n<th>空间复杂度</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>O(n²)</td>\n<td>O(n²)</td>\n<td>O(n²)</td>\n<td>O(1)</td>\n</tr>\n</tbody>\n</table>\n<h1><a id=\"_23\"></a>堆排序—不稳定</h1>\n<p><img src=\"http://ruizmypmv.hn-bkt.clouddn.com/7d02432c-71a8-4796-a796-14bd192ac85a.png\" alt=\"2993839202304242012385391131211721.png\" /><br />\n1.父结点索引：(i-1)/2（这里计算机中的除以2，省略掉小数）<br />\n2.左孩子索引：2i+1<br />\n3.右孩子索引：2i+2<br />\n升序用大顶堆，降序用小顶堆。</p>\n<pre><code class=\"lang-\">	//维护堆,参数为数组和当前需要维护的根节点,len表示堆中有多少元素\n    public void heapify(int[] arr,int len, int i) {\n        // 最大值节点\n        int max = i;\n        int lChild = i * 2 + 1;\n        int rChild = i * 2 + 2;\n        //找出孩子节点中最大的那个值，然后交换\n        if (lChild &lt; len &amp;&amp; arr[lChild] &gt; arr[max]) {\n            max=lChild;\n        }\n        if (rChild &lt; len &amp;&amp; arr[rChild] &gt; arr[max]) {\n            max=rChild;\n        }\n        //交换节点位置\n        if (max != i) {\n            swep(arr,i,max);\n            //递归维护之后的节点\n            heapify(arr,len,max);\n        }\n    }\n    //交换节点\n    public void swep(int[] arr,int i,int j){\n        int tmp=arr[i];\n        arr[i]=arr[j];\n        arr[j]=tmp;\n    }\n\n    //堆排序\n    public void heapSort(int[] arr) {\n        //建堆,i表示最后一个非叶子节点\n        for (int i = arr.length/2-1; i &gt;=0; i--) {\n            heapify(arr,arr.length,i);\n        }\n        //排序，将堆顶元素和最后一个元素交换，然后将最后一个元素移除堆，维护堆，再将倒数第二个元素和堆顶元素交换......\n        for (int j = arr.length - 1; j &gt;0 ; j--) {\n            swep(arr,j,0);\n            //最后一个元素不需要参与维护，所以长度是arr.length-1,一次减少一次\n            heapify(arr,j,0);\n        }\n    }\n</code></pre>\n<p>1.建立堆的过程, 从length/2 一直处理到0, 时间复杂度为O(n);<br />\n2.调整堆的过程是沿着堆的父子节点进行调整, 执行次数为堆的深度, 时间复杂度为O(lgn);<br />\n3.堆排序的过程由n次第2步完成, 时间复杂度为O(nlgn).</p>\n<table>\n<thead>\n<tr>\n<th>平均时间复杂度</th>\n<th>最好</th>\n<th>最坏</th>\n<th>空间复杂度</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>O(nlog2n)</td>\n<td>O(nlog2n)</td>\n<td>O(nlog2n)</td>\n<td>O(1)</td>\n</tr>\n</tbody>\n</table>\n', 1658768565064548353);
INSERT INTO `ms_article_body` VALUES (1658770056391278593, '# 插入排序---稳定\n\n|平均时间复杂度	|最好	|最坏	|空间复杂度|\n|------|-----|----|----|\n|O(n²)	|O(n)	|O(n²)|	O(1)\n```\n//实现代码，不需要每次比都交换元素，减少交换次数\nint[] arr = {1, 5, 7, 63, 4, 58, 45};\n        for (int i = 1; i < arr.length; i++) {\n            int tmp = arr[i];\n            int j;\n            for (j = i; j > 0 && tmp < arr[j - 1]; j--) {\n                arr[j]=arr[j-1];\n            }\n            arr[j]=tmp;\n        }\n```\n# 希尔排序---不稳定\n希尔排序，也称 递减增量排序算法，是插入排序的一种更高效的改进版本。希尔排序是 非稳定排序算法。\n\n希尔排序是基于插入排序的以下两点性质而提出改进方法的：\n\n- 插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率，但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一次\n- 希尔排序是先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录“基本有序”时，再对全体记录进行依次直接插入排序。\n思想\n将待排序数组按照步长gap进行分组，然后将每组的元素利用直接插入排序的方法进行排序；每次再将gap折半减小，循环上述操作；当gap=1时，利用直接插入，完成排序。\n\n可以看到步长的选择是希尔排序的重要部分。只要最终步长为1任何步长序列都可以工作。一般来说最简单的步长取值是初次取数组长度的一半为增量，之后每次再减半，直到增量为1。更好的步长序列取值可以参考维基百科。\n\n|平均时间复杂度	|最好	|最坏	|空间复杂度|\n|------|-----|----|----|\n|O(nlog2 n)	|O(n)	|O(nlog2 n)|	O(1)\n```\n	int gap = arr.length;\n        while (gap > 1) {\n            gap = gap / 3 + 1;//最后一次为1\n            for (int i = 0; i < arr.length - gap; i++) {\n                for (int j = i + gap; j < arr.length; j += gap) {\n                    if (arr[j-gap]>arr[j]){\n                        int tmp=arr[j];\n                        arr[j]=arr[j-gap];\n                        arr[j-gap]=tmp;\n                    }\n                }\n            }\n        }\n```\n## 总结\n希尔排序更高效的原因是它权衡了子数组的规模和有序性。排序之初，各个子数组都很短，排序之后子数组都是部分有序的，这两种情况都很适合插入排序。', '<h1><a id=\"_0\"></a>插入排序—稳定</h1>\n<table>\n<thead>\n<tr>\n<th>平均时间复杂度</th>\n<th>最好</th>\n<th>最坏</th>\n<th>空间复杂度</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>O(n²)</td>\n<td>O(n)</td>\n<td>O(n²)</td>\n<td>O(1)</td>\n</tr>\n</tbody>\n</table>\n<pre><code class=\"lang-\">//实现代码，不需要每次比都交换元素，减少交换次数\nint[] arr = {1, 5, 7, 63, 4, 58, 45};\n        for (int i = 1; i &lt; arr.length; i++) {\n            int tmp = arr[i];\n            int j;\n            for (j = i; j &gt; 0 &amp;&amp; tmp &lt; arr[j - 1]; j--) {\n                arr[j]=arr[j-1];\n            }\n            arr[j]=tmp;\n        }\n</code></pre>\n<h1><a id=\"_17\"></a>希尔排序—不稳定</h1>\n<p>希尔排序，也称 递减增量排序算法，是插入排序的一种更高效的改进版本。希尔排序是 非稳定排序算法。</p>\n<p>希尔排序是基于插入排序的以下两点性质而提出改进方法的：</p>\n<ul>\n<li>插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率，但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一次</li>\n<li>希尔排序是先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录“基本有序”时，再对全体记录进行依次直接插入排序。<br />\n思想<br />\n将待排序数组按照步长gap进行分组，然后将每组的元素利用直接插入排序的方法进行排序；每次再将gap折半减小，循环上述操作；当gap=1时，利用直接插入，完成排序。</li>\n</ul>\n<p>可以看到步长的选择是希尔排序的重要部分。只要最终步长为1任何步长序列都可以工作。一般来说最简单的步长取值是初次取数组长度的一半为增量，之后每次再减半，直到增量为1。更好的步长序列取值可以参考维基百科。</p>\n<table>\n<thead>\n<tr>\n<th>平均时间复杂度</th>\n<th>最好</th>\n<th>最坏</th>\n<th>空间复杂度</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>O(nlog2 n)</td>\n<td>O(n)</td>\n<td>O(nlog2 n)</td>\n<td>O(1)</td>\n</tr>\n</tbody>\n</table>\n<pre><code class=\"lang-\">	int gap = arr.length;\n        while (gap &gt; 1) {\n            gap = gap / 3 + 1;//最后一次为1\n            for (int i = 0; i &lt; arr.length - gap; i++) {\n                for (int j = i + gap; j &lt; arr.length; j += gap) {\n                    if (arr[j-gap]&gt;arr[j]){\n                        int tmp=arr[j];\n                        arr[j]=arr[j-gap];\n                        arr[j-gap]=tmp;\n                    }\n                }\n            }\n        }\n</code></pre>\n<h2><a id=\"_47\"></a>总结</h2>\n<p>希尔排序更高效的原因是它权衡了子数组的规模和有序性。排序之初，各个子数组都很短，排序之后子数组都是部分有序的，这两种情况都很适合插入排序。</p>\n', 1658770056324169729);
INSERT INTO `ms_article_body` VALUES (1658772080956653571, '# Swagger使用教程——快速上手swagger\n## 一、swagger简介\n官网：https://swagger.io/\n\n## 1、认识swagger\nswagger是一个规范和完整的框架，用于生成、描述、调用和可视化RestFul风格的web服务，总体目标是使客户端和文件系统作为服务器以同样的速度来更新。文件的方法，参数和模型紧密集成到服务器断的代码，允许API来始终保持同步。\n## 作用：\n1. 接口的文档在线自动生成。\n\n2. 功能测试。\n\n## 2、Swagger是一组开源项目，其中主要要项目如下：\n1. Swagger-tools:提供各种与Swagger进行集成和交互的工具。例如模式检验、Swagger 1.2文档转换成Swagger 2.0文档等功能。\n\n2. Swagger-core: 用于Java/Scala的的Swagger实现。与JAX-RS(Jersey、Resteasy、CXF…)、Servlets和Play框架进行集成。\n\n3. Swagger-js: 用于JavaScript的Swagger实现。\n\n4. Swagger-node-express: Swagger模块，用于node.js的Express web应用框架。\n\n5. Swagger-ui：一个无依赖的HTML、JS和CSS集合，可以为Swagger兼容API动态生成优雅文档。\n\n6. Swagger-codegen：一个模板驱动引擎，通过分析用户Swagger资源声明以各种语言生成客户端代码。\n# 二、SpringBoot集成Swagger\n## 1、新建SpringBoot项目，导入swagger依赖\n```\n <!--swagger依赖-->\n<dependency>\n    <groupId>io.springfox</groupId>\n    <artifactId>springfox-swagger2</artifactId>\n    <version>2.9.2</version>\n</dependency>\n<!--swagger ui-->\n<dependency>\n    <groupId>io.springfox</groupId>\n    <artifactId>springfox-swagger-ui</artifactId>\n    <version>2.9.2</version>\n</dependency>\n\n```\n## 2、编写swagger的配置文件\n```\n@Configuration\n@EnableSwagger2\npublic class Swagger2Config {\n    /**\n     * 创建API应用\n     * apiInfo() 增加API相关信息\n     * 通过select()函数返回一个ApiSelectorBuilder实例,用来控制哪些接口暴露给Swagger来展现，\n     * 指定扫描的包路径来定义指定要建立API的目录。\n     * @return\n     */\n    @Bean\n    public Docket coreApiConfig(){\n        return new Docket(DocumentationType.SWAGGER_2)\n                .apiInfo(adminApiInfo())\n                .groupName(\"adminApi\")\n                .select()\n                //只显示admin下面的路径\n                .paths(Predicates.and(PathSelectors.regex(\"/admin/.*\")))\n                .build();\n    }\n\n    private ApiInfo adminApiInfo(){\n        return new ApiInfoBuilder()\n                .title(\"尚融宝后台管理系统--api文档\")\n                .description(\"尚融宝后台管理系统接口描述\")\n                .version(\"1.0\")\n                .contact(new Contact(\"李燕茹\",\"http://baidu.com\",\"728831102@qq.com\"))\n                .build();\n    }\n}\n\n```\n## 3、添加文档内容\n在完成了上述配置后，其实已经可以生产文档内容，但是这样的文档主要针对请求本身，描述的主要来源是函数的命名，通常需要自己增加一些说明来丰富文档内容。\n\n## Swagger使用的注解及其说明：\n@Api：用在类上，说明该类的作用。\n@ApiOperation：注解来给API增加方法说明。\n@ApiParam：定义在参数上\n@ApiResponses：用于表示一组响应\n@ApiResponse：用在@ApiResponses中，一般用于表达一个错误的响应信息\nl code：数字，例如400\nl message：信息，例如\"请求参数没填好\"\nl response：抛出异常的类\n\n@ApiModel：描述一个Model的信息（一般用在请求参数无法使用@ApiImplicitParam注解进行描述的时候）\n\nl @ApiModelProperty：描述一个model的属性\n\n@ApiImplicitParams: 用在方法上包含一组参数说明。\n\n@ApiImplicitParam：用来注解来给方法入参增加说明。\n\n@ApiImplicitParam的参数说明：\n|paramType：指定参数放在哪个地方   |  header：请求参数放置于Request Header，使用@RequestHeader获取 query：请求参数放置于请求地址，使用@RequestParam获取 path：（用于restful接口）–>请求参数的获取：@PathVariable body：（不常用） form（不常用） |\n| ------------ | ------------ |\n| name：参数名  |   |\n|  dataType：参数类型 |   |\n|  required：参数是否必须传 | `true | false`  |\n|  value：说明参数的意思 |   |\n|defaultValue：参数的默认值 | |', '<h1><a id=\"Swaggerswagger_0\"></a>Swagger使用教程——快速上手swagger</h1>\n<h2><a id=\"swagger_1\"></a>一、swagger简介</h2>\n<p>官网：https://swagger.io/</p>\n<h2><a id=\"1swagger_4\"></a>1、认识swagger</h2>\n<p>swagger是一个规范和完整的框架，用于生成、描述、调用和可视化RestFul风格的web服务，总体目标是使客户端和文件系统作为服务器以同样的速度来更新。文件的方法，参数和模型紧密集成到服务器断的代码，允许API来始终保持同步。</p>\n<h2><a id=\"_6\"></a>作用：</h2>\n<ol>\n<li>\n<p>接口的文档在线自动生成。</p>\n</li>\n<li>\n<p>功能测试。</p>\n</li>\n</ol>\n<h2><a id=\"2Swagger_11\"></a>2、Swagger是一组开源项目，其中主要要项目如下：</h2>\n<ol>\n<li>\n<p>Swagger-tools:提供各种与Swagger进行集成和交互的工具。例如模式检验、Swagger 1.2文档转换成Swagger 2.0文档等功能。</p>\n</li>\n<li>\n<p>Swagger-core: 用于Java/Scala的的Swagger实现。与JAX-RS(Jersey、Resteasy、CXF…)、Servlets和Play框架进行集成。</p>\n</li>\n<li>\n<p>Swagger-js: 用于JavaScript的Swagger实现。</p>\n</li>\n<li>\n<p>Swagger-node-express: Swagger模块，用于node.js的Express web应用框架。</p>\n</li>\n<li>\n<p>Swagger-ui：一个无依赖的HTML、JS和CSS集合，可以为Swagger兼容API动态生成优雅文档。</p>\n</li>\n<li>\n<p>Swagger-codegen：一个模板驱动引擎，通过分析用户Swagger资源声明以各种语言生成客户端代码。</p>\n</li>\n</ol>\n<h1><a id=\"SpringBootSwagger_23\"></a>二、SpringBoot集成Swagger</h1>\n<h2><a id=\"1SpringBootswagger_24\"></a>1、新建SpringBoot项目，导入swagger依赖</h2>\n<pre><code class=\"lang-\"> &lt;!--swagger依赖--&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;io.springfox&lt;/groupId&gt;\n    &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt;\n    &lt;version&gt;2.9.2&lt;/version&gt;\n&lt;/dependency&gt;\n&lt;!--swagger ui--&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;io.springfox&lt;/groupId&gt;\n    &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt;\n    &lt;version&gt;2.9.2&lt;/version&gt;\n&lt;/dependency&gt;\n\n</code></pre>\n<h2><a id=\"2swagger_40\"></a>2、编写swagger的配置文件</h2>\n<pre><code class=\"lang-\">@Configuration\n@EnableSwagger2\npublic class Swagger2Config {\n    /**\n     * 创建API应用\n     * apiInfo() 增加API相关信息\n     * 通过select()函数返回一个ApiSelectorBuilder实例,用来控制哪些接口暴露给Swagger来展现，\n     * 指定扫描的包路径来定义指定要建立API的目录。\n     * @return\n     */\n    @Bean\n    public Docket coreApiConfig(){\n        return new Docket(DocumentationType.SWAGGER_2)\n                .apiInfo(adminApiInfo())\n                .groupName(&quot;adminApi&quot;)\n                .select()\n                //只显示admin下面的路径\n                .paths(Predicates.and(PathSelectors.regex(&quot;/admin/.*&quot;)))\n                .build();\n    }\n\n    private ApiInfo adminApiInfo(){\n        return new ApiInfoBuilder()\n                .title(&quot;尚融宝后台管理系统--api文档&quot;)\n                .description(&quot;尚融宝后台管理系统接口描述&quot;)\n                .version(&quot;1.0&quot;)\n                .contact(new Contact(&quot;李燕茹&quot;,&quot;http://baidu.com&quot;,&quot;728831102@qq.com&quot;))\n                .build();\n    }\n}\n\n</code></pre>\n<h2><a id=\"3_74\"></a>3、添加文档内容</h2>\n<p>在完成了上述配置后，其实已经可以生产文档内容，但是这样的文档主要针对请求本身，描述的主要来源是函数的命名，通常需要自己增加一些说明来丰富文档内容。</p>\n<h2><a id=\"Swagger_77\"></a>Swagger使用的注解及其说明：</h2>\n<p>@Api：用在类上，说明该类的作用。<br />\n@ApiOperation：注解来给API增加方法说明。<br />\n@ApiParam：定义在参数上<br />\n@ApiResponses：用于表示一组响应<br />\n@ApiResponse：用在@ApiResponses中，一般用于表达一个错误的响应信息<br />\nl code：数字，例如400<br />\nl message：信息，例如&quot;请求参数没填好&quot;<br />\nl response：抛出异常的类</p>\n<p>@ApiModel：描述一个Model的信息（一般用在请求参数无法使用@ApiImplicitParam注解进行描述的时候）</p>\n<p>l @ApiModelProperty：描述一个model的属性</p>\n<p>@ApiImplicitParams: 用在方法上包含一组参数说明。</p>\n<p>@ApiImplicitParam：用来注解来给方法入参增加说明。</p>\n<p>@ApiImplicitParam的参数说明：</p>\n<table>\n<thead>\n<tr>\n<th>paramType：指定参数放在哪个地方</th>\n<th>header：请求参数放置于Request Header，使用@RequestHeader获取 query：请求参数放置于请求地址，使用@RequestParam获取 path：（用于restful接口）–&gt;请求参数的获取：@PathVariable body：（不常用） form（不常用）</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>name：参数名</td>\n<td></td>\n</tr>\n<tr>\n<td>dataType：参数类型</td>\n<td></td>\n</tr>\n<tr>\n<td>required：参数是否必须传</td>\n<td><code>true | false</code></td>\n</tr>\n<tr>\n<td>value：说明参数的意思</td>\n<td></td>\n</tr>\n<tr>\n<td>defaultValue：参数的默认值</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n', 1658772080889544706);
INSERT INTO `ms_article_body` VALUES (1658774222647967746, '# 1. 基础语法\n## 1.1 标记（标签）\n```\n- 常规标记（双标记）    <标记></标记>\n- 空标记（单标记）      <标记 />\n```\n## 1.2 `<!DOCTYPE html>`\n```\n文档类型\n```\n## 1.3 `<html lang=\"zh-CN\">`\n```\n为浏览器指出本文档所用语言\n```\n1.4 `<meta />`\n```\n- <meta charset=\"\" />：设置文档字符编码\n```\n# 2. 常用标签\n## 2.1 `<h1>标题</h1>`\n- 作用：标题 h1~h6\n- 特点：加粗、有文本大小、独占一行、默认间距\n- 注意：h1标签最好只有一个，用作突出重点\n## 2.2 `<p>内容</p>`\n```\n- 作用：段落\n- 特点：有段间距\n```\n## 2.3 `<br />`\n```\n- 作用：换行\n```\n## 2.4 `<hr />`\n```\n- 作用：水平线\n```\n## 2.5 加粗\n```\n- <b>文本</b>\n- <strong>文本</strong> ——推荐\n```\n## 2.6 倾斜\n- <i>文本</i>\n- <em>文本</em> ——推荐\n### 2.6.1 strong和b、em和i的区别\n```\n- strong和em 是具备语义化的\n\n- b和i应用场景：在需要使用多个span时，代替其他span，简化选择器的操作\n```\n## 2.7 删除线\n```\n- <s>文本</s>\n- <del>文本</del> ——推荐\n```\n## 2.8 下划线\n```\n- <u>文本</u>\n- <ins>文本</ins> ——推荐\n```\n## 2.9 <sub>内容</sub>\n```\n- 作用：下标\n```\n## 2.10 <sup>内容</sup>\n```\n- 作用：上标\n```\n## 2.11 HTML常用标签练习\n```\n<h1>Markdown</h1>\n<hr />\n<h2>介绍</h2>\n<p>\n  <b>Markdown</b> 是一种<i>轻量级标记语言</i>，创始人为<strong>约翰·格鲁伯</strong>（<em>John Gruber</em>）。\n  <br />\n  它允许人们使用易读易写的<s>纯文本</s>格式编写文档，然后转换成有效的 <em>XHTML</em>（或者<em>HTML</em>）文档。\n  这种语言吸收了很多在电子邮件中已有的纯文本标记的特性<strong><sup>①</sup></strong>。\n  <br>\n  由于 <em>Markdown</em> 的轻量化、易读易写特性，并且对于图片，图表、数学式都有支持，许多网站都广泛使用 Markdown 来撰写帮助文档或是用于论坛上发表消息。 \n  如 GitHub、Reddit、Diaspora、Stack Exchange、OpenStreetMap 、SourceForge、简书等，<del>甚至</del>还能被使用来撰写电子书<strong><sub>②</sub></strong>。\n</p>\n<hr />\n```\n## 2.12 效果预览\n![1480487202305091549360921139411865.jpg](http://ruizmypmv.hn-bkt.clouddn.com/8f211bc6-0219-453a-be04-9b7acb374ca2.jpg)', '<h1><a id=\"1__0\"></a>1. 基础语法</h1>\n<h2><a id=\"11__1\"></a>1.1 标记（标签）</h2>\n<pre><code class=\"lang-\">- 常规标记（双标记）    &lt;标记&gt;&lt;/标记&gt;\n- 空标记（单标记）      &lt;标记 /&gt;\n</code></pre>\n<h2><a id=\"12_DOCTYPE_html_6\"></a>1.2 <code>&lt;!DOCTYPE html&gt;</code></h2>\n<pre><code class=\"lang-\">文档类型\n</code></pre>\n<h2><a id=\"13_html_langzhCN_10\"></a>1.3 <code>&lt;html lang=&quot;zh-CN&quot;&gt;</code></h2>\n<pre><code class=\"lang-\">为浏览器指出本文档所用语言\n</code></pre>\n<p>1.4 <code>&lt;meta /&gt;</code></p>\n<pre><code class=\"lang-\">- &lt;meta charset=&quot;&quot; /&gt;：设置文档字符编码\n</code></pre>\n<h1><a id=\"2__18\"></a>2. 常用标签</h1>\n<h2><a id=\"21_h1h1_19\"></a>2.1 <code>&lt;h1&gt;标题&lt;/h1&gt;</code></h2>\n<ul>\n<li>作用：标题 h1~h6</li>\n<li>特点：加粗、有文本大小、独占一行、默认间距</li>\n<li>注意：h1标签最好只有一个，用作突出重点</li>\n</ul>\n<h2><a id=\"22_pp_23\"></a>2.2 <code>&lt;p&gt;内容&lt;/p&gt;</code></h2>\n<pre><code class=\"lang-\">- 作用：段落\n- 特点：有段间距\n</code></pre>\n<h2><a id=\"23_br__28\"></a>2.3 <code>&lt;br /&gt;</code></h2>\n<pre><code class=\"lang-\">- 作用：换行\n</code></pre>\n<h2><a id=\"24_hr__32\"></a>2.4 <code>&lt;hr /&gt;</code></h2>\n<pre><code class=\"lang-\">- 作用：水平线\n</code></pre>\n<h2><a id=\"25__36\"></a>2.5 加粗</h2>\n<pre><code class=\"lang-\">- &lt;b&gt;文本&lt;/b&gt;\n- &lt;strong&gt;文本&lt;/strong&gt; ——推荐\n</code></pre>\n<h2><a id=\"26__41\"></a>2.6 倾斜</h2>\n<ul>\n<li><i>文本</i></li>\n<li><em>文本</em> ——推荐</li>\n</ul>\n<h3><a id=\"261_strongbemi_44\"></a>2.6.1 strong和b、em和i的区别</h3>\n<pre><code class=\"lang-\">- strong和em 是具备语义化的\n\n- b和i应用场景：在需要使用多个span时，代替其他span，简化选择器的操作\n</code></pre>\n<h2><a id=\"27__50\"></a>2.7 删除线</h2>\n<pre><code class=\"lang-\">- &lt;s&gt;文本&lt;/s&gt;\n- &lt;del&gt;文本&lt;/del&gt; ——推荐\n</code></pre>\n<h2><a id=\"28__55\"></a>2.8 下划线</h2>\n<pre><code class=\"lang-\">- &lt;u&gt;文本&lt;/u&gt;\n- &lt;ins&gt;文本&lt;/ins&gt; ——推荐\n</code></pre>\n<h2><a id=\"29_subsub_60\"></a>2.9 <sub>内容</sub></h2>\n<pre><code class=\"lang-\">- 作用：下标\n</code></pre>\n<h2><a id=\"210_supsup_64\"></a>2.10 <sup>内容</sup></h2>\n<pre><code class=\"lang-\">- 作用：上标\n</code></pre>\n<h2><a id=\"211_HTML_68\"></a>2.11 HTML常用标签练习</h2>\n<pre><code class=\"lang-\">&lt;h1&gt;Markdown&lt;/h1&gt;\n&lt;hr /&gt;\n&lt;h2&gt;介绍&lt;/h2&gt;\n&lt;p&gt;\n  &lt;b&gt;Markdown&lt;/b&gt; 是一种&lt;i&gt;轻量级标记语言&lt;/i&gt;，创始人为&lt;strong&gt;约翰·格鲁伯&lt;/strong&gt;（&lt;em&gt;John Gruber&lt;/em&gt;）。\n  &lt;br /&gt;\n  它允许人们使用易读易写的&lt;s&gt;纯文本&lt;/s&gt;格式编写文档，然后转换成有效的 &lt;em&gt;XHTML&lt;/em&gt;（或者&lt;em&gt;HTML&lt;/em&gt;）文档。\n  这种语言吸收了很多在电子邮件中已有的纯文本标记的特性&lt;strong&gt;&lt;sup&gt;①&lt;/sup&gt;&lt;/strong&gt;。\n  &lt;br&gt;\n  由于 &lt;em&gt;Markdown&lt;/em&gt; 的轻量化、易读易写特性，并且对于图片，图表、数学式都有支持，许多网站都广泛使用 Markdown 来撰写帮助文档或是用于论坛上发表消息。 \n  如 GitHub、Reddit、Diaspora、Stack Exchange、OpenStreetMap 、SourceForge、简书等，&lt;del&gt;甚至&lt;/del&gt;还能被使用来撰写电子书&lt;strong&gt;&lt;sub&gt;②&lt;/sub&gt;&lt;/strong&gt;。\n&lt;/p&gt;\n&lt;hr /&gt;\n</code></pre>\n<h2><a id=\"212__84\"></a>2.12 效果预览</h2>\n<p><img src=\"http://ruizmypmv.hn-bkt.clouddn.com/8f211bc6-0219-453a-be04-9b7acb374ca2.jpg\" alt=\"1480487202305091549360921139411865.jpg\" /></p>\n', 1658774222585053186);
INSERT INTO `ms_article_body` VALUES (1658776284639117316, '# 1、什么是事务？\n事务(Transaction)，顾名思义就是要做的或所做的事情，数据库事务指的则是作为单个逻辑工作单元执行的一系列操作（SQL语句）。这些操作要么全部执行，要么全部不执行。\n# 2、为什么需要事务\n把一系列sql放入一个事务中有两个目的：\n- 为数据库操作提供了一个从失败中恢复到正常状态的方法，同时提供了数据库即使在异常状态下仍能保持一致性的方法。\n- 当多个应用程序在并发访问数据库时，可以在这些应用程序之间提供一个隔离方法，以防止彼此的操作互相干扰。\n```\n当一个事务被提交给了DBMS（数据库管理系统），则DBMS需要确保该事务中的所有操作都成功完成且其结果被永久保存在数据库中，如果事务中有的操作没有成功完成，则事务中的所有操作都需要被回滚，回到事务执行前的状态（要么全执行，要么全都不执行）;同时，该事务对数据库或者其他事务的执行无影响，所有的事务都好像在独立的运行。\n\n但在现实情况下，失败的风险很高。在一个数据库事务的执行过程中，有可能会遇上事务操作失败、数据库系统/操作系统失败，甚至是存储介质失败等情况。这便需要DBMS对一个执行失败的事务执行恢复操作，将其数据库状态恢复到一致状态（数据的一致性得到保证的状态）。为了实现将数据库状态恢复到一致状态的功能，DBMS通常需要维护事务日志以追踪事务中所有影响数据库数据的操作。\n\n```\n# 3、事务的四大特性（ACID）\nACID 即Atomicity、Consistency、Isolation、Durability的缩写\n1、原子性（Atomicity）\n一个事务的执行是整体性的，不可分割，包含在其中的对数据库的操作要么全部被执行，要么都不执行。\n2、一致性（Consistency）\n事务应确保数据库的状态从一个一致状态转变为另一个一致状态。例如转账行为中：一个人减了50元，另 外一个人就应该加上这50元，而不能 是40元。其他一致状态的含义是数据库中的数据应满足完整性约束, 例如字段约束不能为负数，事务执行完毕后的该字段也同样不是负数\n3、隔离性（Isolation）\n多个事务并发执行时，一个事务的执行不应影响其他事务的执行， 且多个事务不能看到对方的中间状态（提交或者回滚之前的状态）\n4、持久性（Durability）\n一个事务的提交，对数据库的修改是永久保存在数据库中的，不受外部因素或其他操作影响。\n# 4、事务的隔离级别\n注意:  下方表格即代表 每个隔离级别是否存在并发事务所导致的问题！\n|   |   |   |   |\n| ------------ | ------------ | ------------ | ------------ |\n|隔离级别	|脏读	|不可重复读	|幻读|\n|Read uncommitted 读未提交|	√	|√	|√|\n|Read committed 读已提交	|×|	√|	√|\nRepeatable Read （MySQL默认隔离级别） 可重复读|	×|	×|	√|\nSerializable 串行化|	×|	×|	×|\n# 5、并发事务导致的问题！\n注意：下列问题其实就是由于并发事务可能会出现的问题（可用提高数据库隔离级别解决 下面会详解）\n1. 脏读(dirty read)\n```\n脏读其实就是 事务A 读取到了 事务B 未提交的数据!\n\n比如：\n	事务A 查询账户金额为200\n	在此期间 事务B 将当前账户存入100 但是并未提交事务（事务只有再提交后才生效）\n	接下来 事务A 又查询了当前账户金额 发现为300!\n	事务B 并未提交数据 而 事务A 则读取到事务B未提交后的数据！\n	\n解决：\n	将数据库隔离级别修改为： Read committed\n```\n2. 不可重复读(non repeatable read)\n```\n不可重复读其实就是 事务A 执行相同的Sql却读取到了不同的数据！\n（和脏读不同的是 它读取到的是已经提交过的事务数据）\n\n比如：\n	事务A 查询账户金额为 200\n    事务B 修改金额为300 并且提交事务\n    然后 事务A 又查询了账户金额发现为 300 \n    这样就导致了 事务A 再同一次事务中执行同样的Sql而获取到不同的值！\n\n解决：\n	将数据库隔离级别修改为： Repeatable Read\n```\n3. 幻读(phantom read)\n```\n幻读其实就是事务A再查询某条数据发现并不存在！但是再插入数据的时候却发生ERROR说当前数据已经存在\n（其实这是再不可重复读解决后发生的下一个问题）\n\n比如：\n	事务A 查询 ID=3 的数据没有！\n	此时 事务B 启动 执行插入了 id=3的一条数据\n	然后 事务A 发现ID为3的数据 并没有 也插入了一条 id=3的数据后报错说 已经存在！\n	这是因为 我们的数据隔离级别已经是可重复的 所以事务A 每次查询到的都是最初未改变的状态！\n\n解决：\n	将数据库隔离级别修改为： Serializable\n```', '<h1><a id=\"1_0\"></a>1、什么是事务？</h1>\n<p>事务(Transaction)，顾名思义就是要做的或所做的事情，数据库事务指的则是作为单个逻辑工作单元执行的一系列操作（SQL语句）。这些操作要么全部执行，要么全部不执行。</p>\n<h1><a id=\"2_2\"></a>2、为什么需要事务</h1>\n<p>把一系列sql放入一个事务中有两个目的：</p>\n<ul>\n<li>为数据库操作提供了一个从失败中恢复到正常状态的方法，同时提供了数据库即使在异常状态下仍能保持一致性的方法。</li>\n<li>当多个应用程序在并发访问数据库时，可以在这些应用程序之间提供一个隔离方法，以防止彼此的操作互相干扰。</li>\n</ul>\n<pre><code class=\"lang-\">当一个事务被提交给了DBMS（数据库管理系统），则DBMS需要确保该事务中的所有操作都成功完成且其结果被永久保存在数据库中，如果事务中有的操作没有成功完成，则事务中的所有操作都需要被回滚，回到事务执行前的状态（要么全执行，要么全都不执行）;同时，该事务对数据库或者其他事务的执行无影响，所有的事务都好像在独立的运行。\n\n但在现实情况下，失败的风险很高。在一个数据库事务的执行过程中，有可能会遇上事务操作失败、数据库系统/操作系统失败，甚至是存储介质失败等情况。这便需要DBMS对一个执行失败的事务执行恢复操作，将其数据库状态恢复到一致状态（数据的一致性得到保证的状态）。为了实现将数据库状态恢复到一致状态的功能，DBMS通常需要维护事务日志以追踪事务中所有影响数据库数据的操作。\n\n</code></pre>\n<h1><a id=\"3ACID_12\"></a>3、事务的四大特性（ACID）</h1>\n<p>ACID 即Atomicity、Consistency、Isolation、Durability的缩写<br />\n1、原子性（Atomicity）<br />\n一个事务的执行是整体性的，不可分割，包含在其中的对数据库的操作要么全部被执行，要么都不执行。<br />\n2、一致性（Consistency）<br />\n事务应确保数据库的状态从一个一致状态转变为另一个一致状态。例如转账行为中：一个人减了50元，另 外一个人就应该加上这50元，而不能 是40元。其他一致状态的含义是数据库中的数据应满足完整性约束, 例如字段约束不能为负数，事务执行完毕后的该字段也同样不是负数<br />\n3、隔离性（Isolation）<br />\n多个事务并发执行时，一个事务的执行不应影响其他事务的执行， 且多个事务不能看到对方的中间状态（提交或者回滚之前的状态）<br />\n4、持久性（Durability）<br />\n一个事务的提交，对数据库的修改是永久保存在数据库中的，不受外部因素或其他操作影响。</p>\n<h1><a id=\"4_22\"></a>4、事务的隔离级别</h1>\n<p>注意:  下方表格即代表 每个隔离级别是否存在并发事务所导致的问题！</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th></th>\n<th></th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>隔离级别</td>\n<td>脏读</td>\n<td>不可重复读</td>\n<td>幻读</td>\n</tr>\n<tr>\n<td>Read uncommitted 读未提交</td>\n<td>√</td>\n<td>√</td>\n<td>√</td>\n</tr>\n<tr>\n<td>Read committed 读已提交</td>\n<td>×</td>\n<td>√</td>\n<td>√</td>\n</tr>\n<tr>\n<td>Repeatable Read （MySQL默认隔离级别） 可重复读</td>\n<td>×</td>\n<td>×</td>\n<td>√</td>\n</tr>\n<tr>\n<td>Serializable 串行化</td>\n<td>×</td>\n<td>×</td>\n<td>×</td>\n</tr>\n</tbody>\n</table>\n<h1><a id=\"5_31\"></a>5、并发事务导致的问题！</h1>\n<p>注意：下列问题其实就是由于并发事务可能会出现的问题（可用提高数据库隔离级别解决 下面会详解）</p>\n<ol>\n<li>脏读(dirty read)</li>\n</ol>\n<pre><code class=\"lang-\">脏读其实就是 事务A 读取到了 事务B 未提交的数据!\n\n比如：\n	事务A 查询账户金额为200\n	在此期间 事务B 将当前账户存入100 但是并未提交事务（事务只有再提交后才生效）\n	接下来 事务A 又查询了当前账户金额 发现为300!\n	事务B 并未提交数据 而 事务A 则读取到事务B未提交后的数据！\n	\n解决：\n	将数据库隔离级别修改为： Read committed\n</code></pre>\n<ol start=\"2\">\n<li>不可重复读(non repeatable read)</li>\n</ol>\n<pre><code class=\"lang-\">不可重复读其实就是 事务A 执行相同的Sql却读取到了不同的数据！\n（和脏读不同的是 它读取到的是已经提交过的事务数据）\n\n比如：\n	事务A 查询账户金额为 200\n    事务B 修改金额为300 并且提交事务\n    然后 事务A 又查询了账户金额发现为 300 \n    这样就导致了 事务A 再同一次事务中执行同样的Sql而获取到不同的值！\n\n解决：\n	将数据库隔离级别修改为： Repeatable Read\n</code></pre>\n<ol start=\"3\">\n<li>幻读(phantom read)</li>\n</ol>\n<pre><code class=\"lang-\">幻读其实就是事务A再查询某条数据发现并不存在！但是再插入数据的时候却发生ERROR说当前数据已经存在\n（其实这是再不可重复读解决后发生的下一个问题）\n\n比如：\n	事务A 查询 ID=3 的数据没有！\n	此时 事务B 启动 执行插入了 id=3的一条数据\n	然后 事务A 发现ID为3的数据 并没有 也插入了一条 id=3的数据后报错说 已经存在！\n	这是因为 我们的数据隔离级别已经是可重复的 所以事务A 每次查询到的都是最初未改变的状态！\n\n解决：\n	将数据库隔离级别修改为： Serializable\n</code></pre>\n', 1658776284639117314);
INSERT INTO `ms_article_body` VALUES (1658781189735038979, '# DQL语句\n# 1、格式\n- select 列名*N from 表名 where 查询条件1 and/or 查询条件2 group by 列 Having 分组条件 Order by 排序\n# 2、规则\n- sql在书写时除了查询条件外，大小写都可以\n  - select * from user where uname=\'zs\';\n  - SELECT *FROM USER WHERE UNAME=\'zs\';\n- 要是在公司要看其他员工sql是大写还是小写\n- --属于sql语句的注释\n- 所有查询条件为字符串时，需要用\'\'进行修饰，否则会当列名处理\n# 3、select查询列和别名\n## 3.1 直接查询\n```\n-- 查询所有员工信息\nselect * from emp;\n-- 查询员工姓名\nselect ename from emp;\n-- 查询员工薪资\nselect sal from emp;\n-- 查询员工姓名和薪资\nselect ename,sal from emp;\nselect ename sal from emp;-- 错误，把sal当成ename别名了\nselect ename sal comm from emp;-- 报错\n-- 查询员工姓名和薪资,给别名，推荐使用单引号\nselect ename \'员工姓名\', sal \"薪资\" from emp;\n-- 查询到的数据可以直接进行运算\nselect ename,sal,sal*12 from emp;\nselect ename,sal,comm,(sal+comm)*12 from emp;\n\n-- 字符串拼接\nselect CONCAT(ename,\' 的薪资是 \',sal) \'员工薪资\' from emp;\n## 二级标题\n```\n## 3.2 条件查询\n```\n-- 条件查询\n-- 查询empno=7844\nselect * from emp where empno = 7844;\n-- 查询工资等于3000\nselect * from emp where sal = 3000;\n-- 查询job等于salesman\nselect * from emp where job = \'SALESMAN\';\n-- 查询工资大于1000\nselect * from emp where sal > 1000;\n-- 查询工资小于1000\nselect * from emp where sal < 1000;\n-- 查询job不等于salesman\nselect * from emp where job != \'SALESMAN\';\nselect * from emp where job <> \'SALESMAN\';\n-- 查询工资大于等于3000\nselect * from emp where sal >= 3000;  \n-- 查询工资介于1600和3000之间包括1600和3000\nselect * from emp where sal between 1600 and 3000;\n-- NULL不能用=，要用is\nselect * from emp where comm is null;\n```\n## 3.3 in查询\n```\n-- IN查询\n-- 查询7499，7566，7782\nselect * from emp where empno in(7499,7566,7782);\n-- 查询除了这三\nselect * from emp where empno not in(7499,7566,7782);\n-- 如果表中没有这个编号，那么只查询其他的\nselect * from emp where empno in(7499,7566,7782,8888);\n```\n## 3.4 like模糊查询\n```\n-- 模糊查询like，%表示任意字符，包括空\n-- 查询员工姓名最后一个字是N的信息\nselect * from emp where ename like \'%N\';\n-- 查询员工姓名第一个字是M的信息\nselect * from emp where ename like \'M%\';\n-- 查询员工姓名中带M的员工信息\nselect * from emp where ename like\'%M%\';\n-- 下划线_表示任意一个字符\nselect * from emp where ename like \'_M%\';\n-- 如果有特殊字符需要用\\来转义\nselect * from emp where ename like \'%\\%%\';\n```\n# 4、查询结果排序\n```\n-- 按薪资排序（默认升序）\nselect * from emp order by sal;\n-- 看每个job的sal排序\nselect * from emp order by job,sal;\n-- 按列进行排序(示例第一列）\nselect ename,sal from emp order by 1;\n-- 升序\nselect * from emp order by sal asc;\n-- 降序\nselect * from emp order by sal desc;\n-- job降序，sal升序\nselect * from emp order by job desc,sal asc;\n```\n# 5、分页排序\n```\n-- 每次查询前n行(示例前4行）\nselect * from emp limit 4;\n-- 分别查询第N页，每页显示M条\nselect * from emp limit 0,3;\nselect * from emp limit 3,3;\nselect * from emp limit 6,3;\nselect * from emp limit (n-1)*m,m;\n```', '<h1><a id=\"DQL_0\"></a>DQL语句</h1>\n<h1><a id=\"1_1\"></a>1、格式</h1>\n<ul>\n<li>select 列名*N from 表名 where 查询条件1 and/or 查询条件2 group by 列 Having 分组条件 Order by 排序</li>\n</ul>\n<h1><a id=\"2_3\"></a>2、规则</h1>\n<ul>\n<li>sql在书写时除了查询条件外，大小写都可以\n<ul>\n<li>select * from user where uname=‘zs’;</li>\n<li>SELECT *FROM USER WHERE UNAME=‘zs’;</li>\n</ul>\n</li>\n<li>要是在公司要看其他员工sql是大写还是小写</li>\n<li>–属于sql语句的注释</li>\n<li>所有查询条件为字符串时，需要用’\'进行修饰，否则会当列名处理</li>\n</ul>\n<h1><a id=\"3select_10\"></a>3、select查询列和别名</h1>\n<h2><a id=\"31__11\"></a>3.1 直接查询</h2>\n<pre><code class=\"lang-\">-- 查询所有员工信息\nselect * from emp;\n-- 查询员工姓名\nselect ename from emp;\n-- 查询员工薪资\nselect sal from emp;\n-- 查询员工姓名和薪资\nselect ename,sal from emp;\nselect ename sal from emp;-- 错误，把sal当成ename别名了\nselect ename sal comm from emp;-- 报错\n-- 查询员工姓名和薪资,给别名，推荐使用单引号\nselect ename \'员工姓名\', sal &quot;薪资&quot; from emp;\n-- 查询到的数据可以直接进行运算\nselect ename,sal,sal*12 from emp;\nselect ename,sal,comm,(sal+comm)*12 from emp;\n\n-- 字符串拼接\nselect CONCAT(ename,\' 的薪资是 \',sal) \'员工薪资\' from emp;\n## 二级标题\n</code></pre>\n<h2><a id=\"32__33\"></a>3.2 条件查询</h2>\n<pre><code class=\"lang-\">-- 条件查询\n-- 查询empno=7844\nselect * from emp where empno = 7844;\n-- 查询工资等于3000\nselect * from emp where sal = 3000;\n-- 查询job等于salesman\nselect * from emp where job = \'SALESMAN\';\n-- 查询工资大于1000\nselect * from emp where sal &gt; 1000;\n-- 查询工资小于1000\nselect * from emp where sal &lt; 1000;\n-- 查询job不等于salesman\nselect * from emp where job != \'SALESMAN\';\nselect * from emp where job &lt;&gt; \'SALESMAN\';\n-- 查询工资大于等于3000\nselect * from emp where sal &gt;= 3000;  \n-- 查询工资介于1600和3000之间包括1600和3000\nselect * from emp where sal between 1600 and 3000;\n-- NULL不能用=，要用is\nselect * from emp where comm is null;\n</code></pre>\n<h2><a id=\"33_in_56\"></a>3.3 in查询</h2>\n<pre><code class=\"lang-\">-- IN查询\n-- 查询7499，7566，7782\nselect * from emp where empno in(7499,7566,7782);\n-- 查询除了这三\nselect * from emp where empno not in(7499,7566,7782);\n-- 如果表中没有这个编号，那么只查询其他的\nselect * from emp where empno in(7499,7566,7782,8888);\n</code></pre>\n<h2><a id=\"34_like_66\"></a>3.4 like模糊查询</h2>\n<pre><code class=\"lang-\">-- 模糊查询like，%表示任意字符，包括空\n-- 查询员工姓名最后一个字是N的信息\nselect * from emp where ename like \'%N\';\n-- 查询员工姓名第一个字是M的信息\nselect * from emp where ename like \'M%\';\n-- 查询员工姓名中带M的员工信息\nselect * from emp where ename like\'%M%\';\n-- 下划线_表示任意一个字符\nselect * from emp where ename like \'_M%\';\n-- 如果有特殊字符需要用\\来转义\nselect * from emp where ename like \'%\\%%\';\n</code></pre>\n<h1><a id=\"4_80\"></a>4、查询结果排序</h1>\n<pre><code class=\"lang-\">-- 按薪资排序（默认升序）\nselect * from emp order by sal;\n-- 看每个job的sal排序\nselect * from emp order by job,sal;\n-- 按列进行排序(示例第一列）\nselect ename,sal from emp order by 1;\n-- 升序\nselect * from emp order by sal asc;\n-- 降序\nselect * from emp order by sal desc;\n-- job降序，sal升序\nselect * from emp order by job desc,sal asc;\n</code></pre>\n<h1><a id=\"5_95\"></a>5、分页排序</h1>\n<pre><code class=\"lang-\">-- 每次查询前n行(示例前4行）\nselect * from emp limit 4;\n-- 分别查询第N页，每页显示M条\nselect * from emp limit 0,3;\nselect * from emp limit 3,3;\nselect * from emp limit 6,3;\nselect * from emp limit (n-1)*m,m;\n</code></pre>\n', 1658781189672124417);
INSERT INTO `ms_article_body` VALUES (1658806949535399938, '# 语法\n## 1、引用声明：\n\n`<script src=\"jQuery文件URL\" type=\"text/javascript\" charset=\"UTF-8\"></script>`\n## 2、基础语法结构：\n1. jQuery的美元符号$是jQuery的简写\n2. 文档就绪函数写法\n```\n//写法一\n$(document).ready(function(){\n	//jQuery函数\n})\n//写法二\n$(function(){\n    //jQuery函数\n})\n```\n# 选择器\n## 基础选择器\n```\n// 全局选择器：选择文档中所有元素，包括<head>及<script>,运行速度较慢\n$(\"*\")\n\n//元素选择器：选择指定元素标签\n$(\"p\") //选择所有p标签\n\n//id选择器：选择指定id的元素\n$(\"#test\")  //选择id=test的元素\n\n//类选择器：选择所有具有同一个指定class的元素\n$(\".a\")  //选择class=“a”的元素\n\n//多重选择器：选择符合条件的所有结果\n$(\"p,hl,div\") //选择文档中所有段落元素<p>、标题元素<hl>和块元素<div>\n```\n## 属性选择器\n```\n//带有指定属性的元素\n$(\"[alt]\")  //所有带alt属性的元素\n\n//属性等于指定值得元素\n$(\"[href=\'#\']\")  //所有href属性值等于#的元素\n\n//属性不等于指定值的元素\n$(\"[href!=\'#\']\")  //所有href属性值不等于#的元素\n\n//属性以指定值结尾的元素\n$(\"[src$=\'.png\']\")  //所有src属性以.png结尾的元素\n\n//属性以指定值为开头的元素\n$(\"input[name^=\'nation\']\")  //所有name属性以nation为开头的元素\n\n//属性包含指定值的元素\n$(\"input[name*=\'nation\']\")  //所有name属性包含nation的元素\n```\n## 表单选择器\n```\n//所有<input>元素\n$(\":input\")\n\n//所有type=“text”的<input>元素\n$(\":text\")\n\n//所有type=“password”的<input>元素\n$(\":password\")\n\n//所有type=“radio”的<input>元素\n$(\":radio\")\n\n//所有type=“checkbox”的<input>元素\n$(\":checkbox\")\n\n//所有type=“submit”的<input>元素\n$(\"input:submit\")\n\n//所有type=“reset”的<input>元素\n$(\":reset\")\n\n//所有type=“button”的<input>元素\n$(\":button\")\n\n//所有type=“image”的<input>元素\n$(\":image\")\n\n//所有type=“file”的<input>元素\n$(\":file\")\n```\n## 指定状态的表单元素选择器\n```\n//所有启用的<input>和<button>元素\n$(\":enabled\")\n\n//所有被禁用的<input>和<button>元素\n$(\":disabled\")\n\n//下拉列表中处于被选中状态的<option>元素\n$(\":selected\")\n\n//所有被选中的单选按钮或者复选框\n$(\":checked\")\n```\n## 层次选择器\n```\n//子元素选择器:只能选择指定元素的第一层子元素\n//语法：$(\"parent>child\")\n$(\"p>span\") //p标签下面的span标签\n\n//后代选择器:指定元素内包含的所有后代元素(可以是第n层子元素)\n//语法：$(ancestor descendant) \n$(\"p span\")  //p标签下面的span标签\n\n//后相邻选择器:与指定元素相邻的后一个元素\n//语法： $(\"prev+next\")\n \n//后兄弟选择器：指定元素后面跟随的所有符合条件的元素(可以是多个)\n//语法：$(\"prev~siblings\") \n    \n//jQuery css选择器\n//语法： $(selector).css(propertyName,value);\n$(\"p\").css(\"background-color\",\"gray\");  //将所有<p>标签背景改为灰色\n```\n# 过滤器\n## 基础过滤器\n```\n//:first 选择第一个符合条件的元素\n$(\"div:first\") //选定第一个div\n\n//:last 选择最后一个符合条件的元素\n$(\"p:last\") //选定最后一个段落\n\n//:even 选择偶数的元素（元素从0开始计数）\n$(\"tr:even\") \n\n//:odd 选择奇数的元素\n$(\"tr:odd\") \n\n//:eq() 选择指定序号的元素\n$(\"li:eq(0)\") \n\n//:gt() 选择大于指定序号的元素\n$(\"li:gt(2)\") \n\n//:lt() 选择小于指定序号的元素\n$(\"li:lt(2)\") \n\n//:not() 选择所有不符合指定要求的元素\n$(\":not(p#test)\") //选择除id=test之外的所有段落\n\n//:header 选择所有的标题元素，即<h1>~<h6>\n$(\":header\") //选中网页中所有标题\n```\n## 子元素过滤器\n```\n//:first-child 所有父元素中的第一个子元素\n$(\"p:first-child\")\n\n//:last-child 所有父元素中的最后一个子元素\n$(\"p:last-child\")\n\n//nth-child() 所有父元素中的第n个子元素\n$(\"ul#test li:nth-child(odd)\") //在id=test的列表中选择所有奇数项<li>元素\n$(\"li:nth-child(2)\") //选择第2个<li>元素\n\n//nth-last-child() 所有父元素中倒数第n个元素\n$(\"li:nth-last-child(2)\") //选择倒数第2个<li>元素\n\n//only-child 所有父元素中唯一的子元素\n$(\"ul:only-child\") //选择只有一个<li>元素的列表\n```\n## 内容过滤器\n```\n//:contains()  选择div中包含北京的\n$(\"div:contains(\'北京\')\")\n\n//:empty\n$(\"td:empty\")  //选择没有内容的<td>元素\n\n//:parent\n$(\"td:parent\")  //选择有内容的<td>元素\n\n//:has()  选择包含有strong标签的div元素\n$(\"div:has(strong)\")\n可见性过滤器\n//:hidden 选择所有隐藏的元素\n$(\"p:hidden\") //网页中不占用任何位置空间就被认定为是隐藏的\n\n//:visible 选择所有可见状态的元素\n$(\"p:visible\") \n```\n# 事件\n## 文档/窗口事件\n```\nready() //文档准备就绪时触发\n$(document).ready()\n\nload() //文档加载时触发\n$(\"img\").load(function(){\n    alert(\"图像已加载\");\n})\n\nunload() //当用户的浏览器窗口从当前窗口跳到提起窗口时触发\n$(window).unload()\n```\n## 键盘事件（键盘事件顺序为 keydown -> keypress ->keyup）\n\n- 所有的键盘事件对象，都有keyCode属性，这个keyCode属性可以获取键值。keyCode是键盘事件对象的属性。记住：键盘上回车键的键值是13；ESC键的键值是27。\n\n- keypress事件与keydown和keyup的主要区别：\n1）对中文输入法支持不好，无法响应中文输入\n2）无法响应系统功能键（如delete，backspace）\n```\nkeydown() //键盘被按下触发\n\nkeypress() //键盘被按下并快速释放触发\n\nkeyup() //键盘被释放触发\n\n$(\"input:text\").keydown(function(){\n	console.log(\"keydown\");\n	$(\"#tip\").text(\"键盘被按下\");\n});\n```\n## 鼠标事件\n```\nclick()  //单击\n\ndblclick()  //双击\n\nhover()  //悬浮\n\nmousedown()  //按下\n\nmouseup()  //释放\n\nmousemove()  //移动\n\nmouseenter()  //进入\n\nmouseleave()  //离开\n\nmouseover()  //穿过\n\nmouseout()  //离开\n\ntoggle()  //在jQuery1.8版之后已过期，慎用\n```\n## 表单事件\n```\nblur()		//当表单元素失去焦点时发生\n\nfocus() 	//当表单元素获得焦点时发生\n\nchange() 	//当表单元素的值发生改变时发生\n\nselect()	//textarea 或文本类型的 input 元素中的文本被选择时发生\n\nsubmit()	//提交表单时发生\n```\n## 事件的绑定与解除\n```\nbind()  //为被选元素添加一个或多个事件\n\ndelegate()  //为被选元素的子元素添加一个或多个事件\n\non()  //在被选元素及子元素上添加一个或多个事件\n\noff() //用于移除添加的事件处理程序\n\none()  //添加只运行一次的事件\n\n语法：\n$(selector).on(event,[data,] function)\n\neg:\n$(\"button\").on/bind/delegate({\n	\"click\":function(){ \n        $(\"body\").css(\"background-color\",\"red\")\n    },\n	\"dblclick\":function(){ \n        $(\"body\").css(\"background-color\",\"yellow\")\n    },\n	\"mouseover\":function(){ \n        $(\"body\").css(\"background-color\",\"blue\")\n    }\n})\n```\n# 特效\n## 隐藏显示\n```\nhide() //隐藏   	\n\nshow() //显示\n\ntoggle() //隐藏和显示切换\n\n$(selector).hide([duration] [, callback]);\nduration参数设置隐藏动作执行持续时间，默认单位毫秒，可以填写“fast”默认持续时间是200毫秒，而“slow”默认是600毫秒或者具体数值\ncallback参数为隐藏动作执行完成之后下一步执行的函数名，没有可以不写\n\neg：\n$(\"#hidebtn2\").click(function(){\n	$(\"#test2\").hide(3000)   //三秒隐藏完成\n})\n$(\"#showbtn2\").click(function(){\n    $(\"#test2\").show(\"fast\")\n})\n```\n## 淡入淡出\n```\nfadeIn()  //淡入  \n\nfadeOut()	//淡出\n\nfadeToggle()  //淡入淡出切换\n\n$(selector).fadeIn([duration] [, callback])\n\nfadeTo()	//元素变为指定的透明度（0~1）\n\n$(selector).fadeTo (duration, opacity [, callback])\n	opacity：该参数为必填内容，用于设置元素的透明度。透明度的数值必须在0~1之间，数值越小透明度越高。0为完全透明，1为非透明。\n```\n## 滑动\n```\nslideDown()  //向下滑动元素\n\nslideUp()  //向上滑动元素\n\nslideToggle()  //切换向上和向下滑动元素\n\n$(selector).slideDown([duration] [, callback])\n```\n## 动画\n```\nanimate() \n$(selector).animate({params} [, duration] [, callback])\n    params:（必选项）表示形成动画的CSS属性，允许多个属性同时改变\n    duration和callback（可选项）\n\neg：\n$(\"#btn\").click(function(){\n	$(\"div\").animate({\n		width:\"400\",\n		fontSize:\"25\",\n        //当CSS属性名称中包含的连字符 \" - “ 时，需要使用Camel标记法\n		backgroundColor: \"#aaffaa\",\n		opacity:\"0.35\"    //透明度\n	},2000)\n})\n\n//使用CSS属性中的方位值left、right、top以及bottom改变元素位置实现移动的效果，在HTML中所有元素的position属性值默认为静态（static）无法移动，若想移动需事先设置指定元素的position属性为relative、absolute或者fixed。 \n$(\"#btn1\").click(function(){\n	$(\"div\").animate({\n		left:\"+200px\",\n		top:\"+100px\"\n		},3000)\n})\n\n//动画队列 多个连续的animate()，在同一个animate()方法中描述的多个动画效果会同时发生，不同animate()方法中描述的会按顺序先后发生\n```\n## 方法链接\n```\n$(selector).action1().action2().action3()......actionN();\n\neg：\n$(\"#btn\").click(function(){\n	$(\"p\").slideUp(3000)\n	.slideDown(\"slow\")\n	.css(\"background-color\",\"green\")\n	.fadeTo(2000,0)\n	.fadeTo(2000,1)\n})\n```\n## 停止动画\n```\n$(selector).stop([stopAll] [, goToEnd]);\nstopAll和goToEnd均为可选项；\nstopAll：是否清除后续所有动画，填入布尔值，默认为false；\ngoToEnd：是否立即完成当前的动画，填入布尔值，默认值为false；\n```\n# HTML DOM\n## 获取和设置\n```\n//text()	//获取元素的纯文本内容，不识别html标签（非表单元素）\n//text(\"内容\")  //设置元素的纯文本内容，不识别html标签（非表单元素）\nconsole.log( \"id为test1的元素的内容是:\" + $(\"#text1\").text() );\n$(\"#text2\").text(\"信科院\");\n\n//html()	//获取元素的内容，包含html标签（非表单元素）\n//html(\"内容\")	//设置元素的内容，包含html标签（非表单元素）\nconsole.log( \"id为html1的内容是:\" + $(\"#html1\").html() );\n$(\"#html1\").html(\"<h2>湖南</h2>\");\n\n//val()	//获取元素的值（表单元素）\n//val(\"值\")	//设置元素的值（表单元素）\nconsole.log( \"id为op的元素的内容是:\" + $(\"#op\").val() );\n$(\"#op\").val(\"today!\");\n\n//attr()   //获取或设置选定元素的属性值\nconsole.log( \"id为aa的name属性值是:\" + $(\"#aa\").attr(\"name\") );\n$(\"a\").attr(\"href\",\"http://www.baidu.com\");\n\n//css()  //获取或设置选定元素的css属性值  addClass()为某个元素添加样式,removeClass()删除样式,toggleClass()删除添加轮流\nconsole.log(\"段落的背景颜色是：\" + $(\"p\").css(\"background-color\") );\n$(\"p\").css(\"background-color\",\"red\");\n$(\"p\").css(\"background-color\":\"red\" , \"font-size\":\"25px\");\n\n$(\"button\").click(function(){\n	$(\"div#remove\").toggleClass(\"bule\");\n})\n\n```\n## 添加\n```\nappend()  //选定元素内部结尾处插入内容\n\nprepend()  //选定元素内部开头插入内容\n\nafter()  //选定元素之后出入内容\n\nbefore()  //选定元素之前插入内容\n\n//用法一样\n$(\"p#test\").append(\"这是一段测试内容\");\n\nappendTo()  //将内容插入到选定元素之前\n$(\"<span>Hello World!</span>\").appendTo(\"p\");  //将Hello World!插入到p标签之前\n```\n## 删除\n```\nremove()  //删除选定元素及其子元素\n$(\"p#test\").remove();  //删除id为test的段落\n\nempty()  //清空元素，文本内容\n$(\"h1\").empty();\n\nremoveAttr()  //删除元素的指定属性\n$(\"div\").removeAttr(\"id\");\n```\n## 尺寸\n```\nwidth()  //获取或设置宽度（不包括内外边距和边框宽度）\n\nheight()  //获取或设置高度（不包括内外边距和边框宽度）\n\ninnerWidth()  //获取或设置宽度（包括内边距）\n\ninnerHeight()  //获取或设置高度（包括内边距）\n\nouterWidth()  //获取或设置宽度（包括内边距和边框宽度）\n\nouterHeight()  //获取或设置高度（包括内边距和边框宽度）\n```\n# 遍历\n## 后代遍历\n```\nchildren() 	//只能查找指定元素的第一层子元素\n$(\"#dc\").children().css({border:\"3px solid red\",backgroundColor:\"pink\"});\n\nfind()	//方法可用于查找指定元素的所有后代元素\n//查找id=df下面所有后代元素\n$(\"#df\").find(\"*\").css({border:\"3px solid red\",backgroundColor:\"pink\"});\n//查找id=df下面所有<span>后代元素\n$(\"#df\").find(\"span\").css({border:\"3px solid red\",backgroundColor:\"pink\"});\n```\n​ 这里加上选择器：\n\n​ 子元素选择器：只能选择指定元素的第一层子元素\n​ 格式：父元素>指定元素 （>隔开）\n​ $(\"parent>chlid\") $(\"父元素>指定元素\")\n​\n​ 后代选择器：指定元素内包含的所有后代元素(可以是第n层子元素)\n​ 格式：父元素 指定元素 （空格隔开）\n​ $(\"ancestor descendant\") $(\"父元素 指定元素\")\n​\n\n## 同胞遍历\n```\nsiblings()：查找指定元素的所有同胞元素\n\nnext()：查找指定元素的下一个同胞元素\n\nnextAll()：查找指定元素后面的所有同胞元素\n\nnextUntil()：查找指定元素后面指定范围内的所有同胞元素\n.nextUntil()([selector][, filter])\nfilter:进一步筛查\n\nprev()：查找指定元素的前一个同胞元素\n\nprevAll()：查找指定元素前面的所有同胞元素\n\nprevUntil()：查找指定元素前面指定范围内的所有同胞元素\n.prevUntil()([selector][, filter])\nfilter:进一步筛查\n```\n​ 这里加上选择器：\n\n​ 后兄弟选择器：指定元素后面跟随的所有符合条件的元素(可以是多个)\n​ 格式：元素~指定元素 （~隔开）\n​ $(\"prev~siblings\") $(\"元素~指定元素\")\n​\n​ 后相邻选择器：与指定元素相邻的后一个元素\n​ 格式：元素+指定元素 （+隔开）\n​ $(\"prev+next\") $(\"元素+指定元素\")\n\n## 祖先遍历\n```\nparent()：查找指定元素的直接父元素\n\nparents()：查找指定元素的所有祖先元素\n\nparentsUntil()：查找指定元素向上指定范围的所有祖先元素\n/*\n.parentsUntil()([selector][, filter])\nfilter:进一步筛查\n*/\neg：\n$(\"li\").parentsUntil(\"div#d1\",\"#d2\");  //向上查找id=d1的祖先元素，不超过id=d2的范围\n```', '<h1><a id=\"_0\"></a>语法</h1>\n<h2><a id=\"1_1\"></a>1、引用声明：</h2>\n<p><code>&lt;script src=&quot;jQuery文件URL&quot; type=&quot;text/javascript&quot; charset=&quot;UTF-8&quot;&gt;&lt;/script&gt;</code></p>\n<h2><a id=\"2_4\"></a>2、基础语法结构：</h2>\n<ol>\n<li>jQuery的美元符号$是jQuery的简写</li>\n<li>文档就绪函数写法</li>\n</ol>\n<pre><code class=\"lang-\">//写法一\n$(document).ready(function(){\n	//jQuery函数\n})\n//写法二\n$(function(){\n    //jQuery函数\n})\n</code></pre>\n<h1><a id=\"_17\"></a>选择器</h1>\n<h2><a id=\"_18\"></a>基础选择器</h2>\n<pre><code class=\"lang-\">// 全局选择器：选择文档中所有元素，包括&lt;head&gt;及&lt;script&gt;,运行速度较慢\n$(&quot;*&quot;)\n\n//元素选择器：选择指定元素标签\n$(&quot;p&quot;) //选择所有p标签\n\n//id选择器：选择指定id的元素\n$(&quot;#test&quot;)  //选择id=test的元素\n\n//类选择器：选择所有具有同一个指定class的元素\n$(&quot;.a&quot;)  //选择class=“a”的元素\n\n//多重选择器：选择符合条件的所有结果\n$(&quot;p,hl,div&quot;) //选择文档中所有段落元素&lt;p&gt;、标题元素&lt;hl&gt;和块元素&lt;div&gt;\n</code></pre>\n<h2><a id=\"_35\"></a>属性选择器</h2>\n<pre><code class=\"lang-\">//带有指定属性的元素\n$(&quot;[alt]&quot;)  //所有带alt属性的元素\n\n//属性等于指定值得元素\n$(&quot;[href=\'#\']&quot;)  //所有href属性值等于#的元素\n\n//属性不等于指定值的元素\n$(&quot;[href!=\'#\']&quot;)  //所有href属性值不等于#的元素\n\n//属性以指定值结尾的元素\n$(&quot;[src$=\'.png\']&quot;)  //所有src属性以.png结尾的元素\n\n//属性以指定值为开头的元素\n$(&quot;input[name^=\'nation\']&quot;)  //所有name属性以nation为开头的元素\n\n//属性包含指定值的元素\n$(&quot;input[name*=\'nation\']&quot;)  //所有name属性包含nation的元素\n</code></pre>\n<h2><a id=\"_55\"></a>表单选择器</h2>\n<pre><code class=\"lang-\">//所有&lt;input&gt;元素\n$(&quot;:input&quot;)\n\n//所有type=“text”的&lt;input&gt;元素\n$(&quot;:text&quot;)\n\n//所有type=“password”的&lt;input&gt;元素\n$(&quot;:password&quot;)\n\n//所有type=“radio”的&lt;input&gt;元素\n$(&quot;:radio&quot;)\n\n//所有type=“checkbox”的&lt;input&gt;元素\n$(&quot;:checkbox&quot;)\n\n//所有type=“submit”的&lt;input&gt;元素\n$(&quot;input:submit&quot;)\n\n//所有type=“reset”的&lt;input&gt;元素\n$(&quot;:reset&quot;)\n\n//所有type=“button”的&lt;input&gt;元素\n$(&quot;:button&quot;)\n\n//所有type=“image”的&lt;input&gt;元素\n$(&quot;:image&quot;)\n\n//所有type=“file”的&lt;input&gt;元素\n$(&quot;:file&quot;)\n</code></pre>\n<h2><a id=\"_87\"></a>指定状态的表单元素选择器</h2>\n<pre><code class=\"lang-\">//所有启用的&lt;input&gt;和&lt;button&gt;元素\n$(&quot;:enabled&quot;)\n\n//所有被禁用的&lt;input&gt;和&lt;button&gt;元素\n$(&quot;:disabled&quot;)\n\n//下拉列表中处于被选中状态的&lt;option&gt;元素\n$(&quot;:selected&quot;)\n\n//所有被选中的单选按钮或者复选框\n$(&quot;:checked&quot;)\n</code></pre>\n<h2><a id=\"_101\"></a>层次选择器</h2>\n<pre><code class=\"lang-\">//子元素选择器:只能选择指定元素的第一层子元素\n//语法：$(&quot;parent&gt;child&quot;)\n$(&quot;p&gt;span&quot;) //p标签下面的span标签\n\n//后代选择器:指定元素内包含的所有后代元素(可以是第n层子元素)\n//语法：$(ancestor descendant) \n$(&quot;p span&quot;)  //p标签下面的span标签\n\n//后相邻选择器:与指定元素相邻的后一个元素\n//语法： $(&quot;prev+next&quot;)\n \n//后兄弟选择器：指定元素后面跟随的所有符合条件的元素(可以是多个)\n//语法：$(&quot;prev~siblings&quot;) \n    \n//jQuery css选择器\n//语法： $(selector).css(propertyName,value);\n$(&quot;p&quot;).css(&quot;background-color&quot;,&quot;gray&quot;);  //将所有&lt;p&gt;标签背景改为灰色\n</code></pre>\n<h1><a id=\"_121\"></a>过滤器</h1>\n<h2><a id=\"_122\"></a>基础过滤器</h2>\n<pre><code class=\"lang-\">//:first 选择第一个符合条件的元素\n$(&quot;div:first&quot;) //选定第一个div\n\n//:last 选择最后一个符合条件的元素\n$(&quot;p:last&quot;) //选定最后一个段落\n\n//:even 选择偶数的元素（元素从0开始计数）\n$(&quot;tr:even&quot;) \n\n//:odd 选择奇数的元素\n$(&quot;tr:odd&quot;) \n\n//:eq() 选择指定序号的元素\n$(&quot;li:eq(0)&quot;) \n\n//:gt() 选择大于指定序号的元素\n$(&quot;li:gt(2)&quot;) \n\n//:lt() 选择小于指定序号的元素\n$(&quot;li:lt(2)&quot;) \n\n//:not() 选择所有不符合指定要求的元素\n$(&quot;:not(p#test)&quot;) //选择除id=test之外的所有段落\n\n//:header 选择所有的标题元素，即&lt;h1&gt;~&lt;h6&gt;\n$(&quot;:header&quot;) //选中网页中所有标题\n</code></pre>\n<h2><a id=\"_151\"></a>子元素过滤器</h2>\n<pre><code class=\"lang-\">//:first-child 所有父元素中的第一个子元素\n$(&quot;p:first-child&quot;)\n\n//:last-child 所有父元素中的最后一个子元素\n$(&quot;p:last-child&quot;)\n\n//nth-child() 所有父元素中的第n个子元素\n$(&quot;ul#test li:nth-child(odd)&quot;) //在id=test的列表中选择所有奇数项&lt;li&gt;元素\n$(&quot;li:nth-child(2)&quot;) //选择第2个&lt;li&gt;元素\n\n//nth-last-child() 所有父元素中倒数第n个元素\n$(&quot;li:nth-last-child(2)&quot;) //选择倒数第2个&lt;li&gt;元素\n\n//only-child 所有父元素中唯一的子元素\n$(&quot;ul:only-child&quot;) //选择只有一个&lt;li&gt;元素的列表\n</code></pre>\n<h2><a id=\"_169\"></a>内容过滤器</h2>\n<pre><code class=\"lang-\">//:contains()  选择div中包含北京的\n$(&quot;div:contains(\'北京\')&quot;)\n\n//:empty\n$(&quot;td:empty&quot;)  //选择没有内容的&lt;td&gt;元素\n\n//:parent\n$(&quot;td:parent&quot;)  //选择有内容的&lt;td&gt;元素\n\n//:has()  选择包含有strong标签的div元素\n$(&quot;div:has(strong)&quot;)\n可见性过滤器\n//:hidden 选择所有隐藏的元素\n$(&quot;p:hidden&quot;) //网页中不占用任何位置空间就被认定为是隐藏的\n\n//:visible 选择所有可见状态的元素\n$(&quot;p:visible&quot;) \n</code></pre>\n<h1><a id=\"_189\"></a>事件</h1>\n<h2><a id=\"_190\"></a>文档/窗口事件</h2>\n<pre><code class=\"lang-\">ready() //文档准备就绪时触发\n$(document).ready()\n\nload() //文档加载时触发\n$(&quot;img&quot;).load(function(){\n    alert(&quot;图像已加载&quot;);\n})\n\nunload() //当用户的浏览器窗口从当前窗口跳到提起窗口时触发\n$(window).unload()\n</code></pre>\n<h2><a id=\"_keydown__keypress_keyup_203\"></a>键盘事件（键盘事件顺序为 keydown -&gt; keypress -&gt;keyup）</h2>\n<ul>\n<li>\n<p>所有的键盘事件对象，都有keyCode属性，这个keyCode属性可以获取键值。keyCode是键盘事件对象的属性。记住：键盘上回车键的键值是13；ESC键的键值是27。</p>\n</li>\n<li>\n<p>keypress事件与keydown和keyup的主要区别：<br />\n1）对中文输入法支持不好，无法响应中文输入<br />\n2）无法响应系统功能键（如delete，backspace）</p>\n</li>\n</ul>\n<pre><code class=\"lang-\">keydown() //键盘被按下触发\n\nkeypress() //键盘被按下并快速释放触发\n\nkeyup() //键盘被释放触发\n\n$(&quot;input:text&quot;).keydown(function(){\n	console.log(&quot;keydown&quot;);\n	$(&quot;#tip&quot;).text(&quot;键盘被按下&quot;);\n});\n</code></pre>\n<h2><a id=\"_222\"></a>鼠标事件</h2>\n<pre><code class=\"lang-\">click()  //单击\n\ndblclick()  //双击\n\nhover()  //悬浮\n\nmousedown()  //按下\n\nmouseup()  //释放\n\nmousemove()  //移动\n\nmouseenter()  //进入\n\nmouseleave()  //离开\n\nmouseover()  //穿过\n\nmouseout()  //离开\n\ntoggle()  //在jQuery1.8版之后已过期，慎用\n</code></pre>\n<h2><a id=\"_246\"></a>表单事件</h2>\n<pre><code class=\"lang-\">blur()		//当表单元素失去焦点时发生\n\nfocus() 	//当表单元素获得焦点时发生\n\nchange() 	//当表单元素的值发生改变时发生\n\nselect()	//textarea 或文本类型的 input 元素中的文本被选择时发生\n\nsubmit()	//提交表单时发生\n</code></pre>\n<h2><a id=\"_258\"></a>事件的绑定与解除</h2>\n<pre><code class=\"lang-\">bind()  //为被选元素添加一个或多个事件\n\ndelegate()  //为被选元素的子元素添加一个或多个事件\n\non()  //在被选元素及子元素上添加一个或多个事件\n\noff() //用于移除添加的事件处理程序\n\none()  //添加只运行一次的事件\n\n语法：\n$(selector).on(event,[data,] function)\n\neg:\n$(&quot;button&quot;).on/bind/delegate({\n	&quot;click&quot;:function(){ \n        $(&quot;body&quot;).css(&quot;background-color&quot;,&quot;red&quot;)\n    },\n	&quot;dblclick&quot;:function(){ \n        $(&quot;body&quot;).css(&quot;background-color&quot;,&quot;yellow&quot;)\n    },\n	&quot;mouseover&quot;:function(){ \n        $(&quot;body&quot;).css(&quot;background-color&quot;,&quot;blue&quot;)\n    }\n})\n</code></pre>\n<h1><a id=\"_286\"></a>特效</h1>\n<h2><a id=\"_287\"></a>隐藏显示</h2>\n<pre><code class=\"lang-\">hide() //隐藏   	\n\nshow() //显示\n\ntoggle() //隐藏和显示切换\n\n$(selector).hide([duration] [, callback]);\nduration参数设置隐藏动作执行持续时间，默认单位毫秒，可以填写“fast”默认持续时间是200毫秒，而“slow”默认是600毫秒或者具体数值\ncallback参数为隐藏动作执行完成之后下一步执行的函数名，没有可以不写\n\neg：\n$(&quot;#hidebtn2&quot;).click(function(){\n	$(&quot;#test2&quot;).hide(3000)   //三秒隐藏完成\n})\n$(&quot;#showbtn2&quot;).click(function(){\n    $(&quot;#test2&quot;).show(&quot;fast&quot;)\n})\n</code></pre>\n<h2><a id=\"_307\"></a>淡入淡出</h2>\n<pre><code class=\"lang-\">fadeIn()  //淡入  \n\nfadeOut()	//淡出\n\nfadeToggle()  //淡入淡出切换\n\n$(selector).fadeIn([duration] [, callback])\n\nfadeTo()	//元素变为指定的透明度（0~1）\n\n$(selector).fadeTo (duration, opacity [, callback])\n	opacity：该参数为必填内容，用于设置元素的透明度。透明度的数值必须在0~1之间，数值越小透明度越高。0为完全透明，1为非透明。\n</code></pre>\n<h2><a id=\"_322\"></a>滑动</h2>\n<pre><code class=\"lang-\">slideDown()  //向下滑动元素\n\nslideUp()  //向上滑动元素\n\nslideToggle()  //切换向上和向下滑动元素\n\n$(selector).slideDown([duration] [, callback])\n</code></pre>\n<h2><a id=\"_332\"></a>动画</h2>\n<pre><code class=\"lang-\">animate() \n$(selector).animate({params} [, duration] [, callback])\n    params:（必选项）表示形成动画的CSS属性，允许多个属性同时改变\n    duration和callback（可选项）\n\neg：\n$(&quot;#btn&quot;).click(function(){\n	$(&quot;div&quot;).animate({\n		width:&quot;400&quot;,\n		fontSize:&quot;25&quot;,\n        //当CSS属性名称中包含的连字符 &quot; - “ 时，需要使用Camel标记法\n		backgroundColor: &quot;#aaffaa&quot;,\n		opacity:&quot;0.35&quot;    //透明度\n	},2000)\n})\n\n//使用CSS属性中的方位值left、right、top以及bottom改变元素位置实现移动的效果，在HTML中所有元素的position属性值默认为静态（static）无法移动，若想移动需事先设置指定元素的position属性为relative、absolute或者fixed。 \n$(&quot;#btn1&quot;).click(function(){\n	$(&quot;div&quot;).animate({\n		left:&quot;+200px&quot;,\n		top:&quot;+100px&quot;\n		},3000)\n})\n\n//动画队列 多个连续的animate()，在同一个animate()方法中描述的多个动画效果会同时发生，不同animate()方法中描述的会按顺序先后发生\n</code></pre>\n<h2><a id=\"_360\"></a>方法链接</h2>\n<pre><code class=\"lang-\">$(selector).action1().action2().action3()......actionN();\n\neg：\n$(&quot;#btn&quot;).click(function(){\n	$(&quot;p&quot;).slideUp(3000)\n	.slideDown(&quot;slow&quot;)\n	.css(&quot;background-color&quot;,&quot;green&quot;)\n	.fadeTo(2000,0)\n	.fadeTo(2000,1)\n})\n</code></pre>\n<h2><a id=\"_373\"></a>停止动画</h2>\n<pre><code class=\"lang-\">$(selector).stop([stopAll] [, goToEnd]);\nstopAll和goToEnd均为可选项；\nstopAll：是否清除后续所有动画，填入布尔值，默认为false；\ngoToEnd：是否立即完成当前的动画，填入布尔值，默认值为false；\n</code></pre>\n<h1><a id=\"HTML_DOM_380\"></a>HTML DOM</h1>\n<h2><a id=\"_381\"></a>获取和设置</h2>\n<pre><code class=\"lang-\">//text()	//获取元素的纯文本内容，不识别html标签（非表单元素）\n//text(&quot;内容&quot;)  //设置元素的纯文本内容，不识别html标签（非表单元素）\nconsole.log( &quot;id为test1的元素的内容是:&quot; + $(&quot;#text1&quot;).text() );\n$(&quot;#text2&quot;).text(&quot;信科院&quot;);\n\n//html()	//获取元素的内容，包含html标签（非表单元素）\n//html(&quot;内容&quot;)	//设置元素的内容，包含html标签（非表单元素）\nconsole.log( &quot;id为html1的内容是:&quot; + $(&quot;#html1&quot;).html() );\n$(&quot;#html1&quot;).html(&quot;&lt;h2&gt;湖南&lt;/h2&gt;&quot;);\n\n//val()	//获取元素的值（表单元素）\n//val(&quot;值&quot;)	//设置元素的值（表单元素）\nconsole.log( &quot;id为op的元素的内容是:&quot; + $(&quot;#op&quot;).val() );\n$(&quot;#op&quot;).val(&quot;today!&quot;);\n\n//attr()   //获取或设置选定元素的属性值\nconsole.log( &quot;id为aa的name属性值是:&quot; + $(&quot;#aa&quot;).attr(&quot;name&quot;) );\n$(&quot;a&quot;).attr(&quot;href&quot;,&quot;http://www.baidu.com&quot;);\n\n//css()  //获取或设置选定元素的css属性值  addClass()为某个元素添加样式,removeClass()删除样式,toggleClass()删除添加轮流\nconsole.log(&quot;段落的背景颜色是：&quot; + $(&quot;p&quot;).css(&quot;background-color&quot;) );\n$(&quot;p&quot;).css(&quot;background-color&quot;,&quot;red&quot;);\n$(&quot;p&quot;).css(&quot;background-color&quot;:&quot;red&quot; , &quot;font-size&quot;:&quot;25px&quot;);\n\n$(&quot;button&quot;).click(function(){\n	$(&quot;div#remove&quot;).toggleClass(&quot;bule&quot;);\n})\n\n</code></pre>\n<h2><a id=\"_412\"></a>添加</h2>\n<pre><code class=\"lang-\">append()  //选定元素内部结尾处插入内容\n\nprepend()  //选定元素内部开头插入内容\n\nafter()  //选定元素之后出入内容\n\nbefore()  //选定元素之前插入内容\n\n//用法一样\n$(&quot;p#test&quot;).append(&quot;这是一段测试内容&quot;);\n\nappendTo()  //将内容插入到选定元素之前\n$(&quot;&lt;span&gt;Hello World!&lt;/span&gt;&quot;).appendTo(&quot;p&quot;);  //将Hello World!插入到p标签之前\n</code></pre>\n<h2><a id=\"_428\"></a>删除</h2>\n<pre><code class=\"lang-\">remove()  //删除选定元素及其子元素\n$(&quot;p#test&quot;).remove();  //删除id为test的段落\n\nempty()  //清空元素，文本内容\n$(&quot;h1&quot;).empty();\n\nremoveAttr()  //删除元素的指定属性\n$(&quot;div&quot;).removeAttr(&quot;id&quot;);\n</code></pre>\n<h2><a id=\"_439\"></a>尺寸</h2>\n<pre><code class=\"lang-\">width()  //获取或设置宽度（不包括内外边距和边框宽度）\n\nheight()  //获取或设置高度（不包括内外边距和边框宽度）\n\ninnerWidth()  //获取或设置宽度（包括内边距）\n\ninnerHeight()  //获取或设置高度（包括内边距）\n\nouterWidth()  //获取或设置宽度（包括内边距和边框宽度）\n\nouterHeight()  //获取或设置高度（包括内边距和边框宽度）\n</code></pre>\n<h1><a id=\"_453\"></a>遍历</h1>\n<h2><a id=\"_454\"></a>后代遍历</h2>\n<pre><code class=\"lang-\">children() 	//只能查找指定元素的第一层子元素\n$(&quot;#dc&quot;).children().css({border:&quot;3px solid red&quot;,backgroundColor:&quot;pink&quot;});\n\nfind()	//方法可用于查找指定元素的所有后代元素\n//查找id=df下面所有后代元素\n$(&quot;#df&quot;).find(&quot;*&quot;).css({border:&quot;3px solid red&quot;,backgroundColor:&quot;pink&quot;});\n//查找id=df下面所有&lt;span&gt;后代元素\n$(&quot;#df&quot;).find(&quot;span&quot;).css({border:&quot;3px solid red&quot;,backgroundColor:&quot;pink&quot;});\n</code></pre>\n<p>​ 这里加上选择器：</p>\n<p>​ 子元素选择器：只能选择指定元素的第一层子元素<br />\n​ 格式：父元素&gt;指定元素 （&gt;隔开）<br />\n​ $(“parent&gt;chlid”) $(“父元素&gt;指定元素”)<br />\n​<br />\n​ 后代选择器：指定元素内包含的所有后代元素(可以是第n层子元素)<br />\n​ 格式：父元素 指定元素 （空格隔开）<br />\n​ $(“ancestor descendant”) $(“父元素 指定元素”)<br />\n​</p>\n<h2><a id=\"_476\"></a>同胞遍历</h2>\n<pre><code class=\"lang-\">siblings()：查找指定元素的所有同胞元素\n\nnext()：查找指定元素的下一个同胞元素\n\nnextAll()：查找指定元素后面的所有同胞元素\n\nnextUntil()：查找指定元素后面指定范围内的所有同胞元素\n.nextUntil()([selector][, filter])\nfilter:进一步筛查\n\nprev()：查找指定元素的前一个同胞元素\n\nprevAll()：查找指定元素前面的所有同胞元素\n\nprevUntil()：查找指定元素前面指定范围内的所有同胞元素\n.prevUntil()([selector][, filter])\nfilter:进一步筛查\n</code></pre>\n<p>​ 这里加上选择器：</p>\n<p>​ 后兄弟选择器：指定元素后面跟随的所有符合条件的元素(可以是多个)<br />\n​ 格式：元素~指定元素 （~隔开）<br />\n​ $(“prev~siblings”) $(“元素~指定元素”)<br />\n​<br />\n​ 后相邻选择器：与指定元素相邻的后一个元素<br />\n​ 格式：元素+指定元素 （+隔开）<br />\n​ $(“prev+next”) $(“元素+指定元素”)</p>\n<h2><a id=\"_506\"></a>祖先遍历</h2>\n<pre><code class=\"lang-\">parent()：查找指定元素的直接父元素\n\nparents()：查找指定元素的所有祖先元素\n\nparentsUntil()：查找指定元素向上指定范围的所有祖先元素\n/*\n.parentsUntil()([selector][, filter])\nfilter:进一步筛查\n*/\neg：\n$(&quot;li&quot;).parentsUntil(&quot;div#d1&quot;,&quot;#d2&quot;);  //向上查找id=d1的祖先元素，不超过id=d2的范围\n</code></pre>\n', 1658806949472485377);
INSERT INTO `ms_article_body` VALUES (1658816190384029698, '## 基本概念：\n\nJVM把内存区分为堆区(heap)、栈区(stack)和方法区(method)。由于本文主要讲解JVM调优，因此我们可以简单的理解为，JVM中的堆区中存放的是实际的对象，是需要被GC的。其他的都无需GC。\n\n下图文JVM的内存模型\n![aHR0cDovL3AzLnBzdGF0cC5jb20vbGFyZ2UvcGdjLWltYWdlLzJmNjdmYzQzMWE5NzQ4ODk5OWNiNWNlMzQ4ZjNjMzA5.jpg](http://ruizmypmv.hn-bkt.clouddn.com/7cfdd513-04a8-48c9-a668-3d18450156c3.jpg)\n从图中我们可以看到，\n\n1、JVM实质上分为三大块，年轻代(YoungGen)，年老代(Old Memory)，及持久代(Perm，在Java8中被取消，我们不做深入介绍)。\n\n2、垃圾回收GC，分为2种，一是Minor GC，可以可以称为YGC，即年轻代GC，当Eden区，还有一种称为Major GC，又称为FullGC。\n\n3、GC原理：\n\n我们可以看到年轻代包括Eden区(对象刚被new出来的时候，放到该区)，S0和S1，是幸存者1区和幸存者2区，从名字可以看出，是当发生YGC，没有被任何其他对象所引用的对象将会从内存中被清除，还被其他对象引用的则放到幸存者区。当发生多次YGC，在S0、S1区多次没有被清楚的对象，则会被移到老年代区域。当老年代区域被占满的时候，则会发送FullGC。\n\n无论是YGC或是FullGC，都会导致stop-the-world，即整个程序停止一些事务的处理，只有GC进程允许以进行垃圾回收，因此如果垃圾回收时间较长，部分web或socket程序，当终端连接的时候会报connetTimeOut或readTimeOut异常，\n\n4、从JVM调优的角度来看，我们应该尽量避免发生YGC或FullGC，或者使得YGC和FullGC的时间足够的短。\n\n## JMV调优的准备工作。\n\n1)、配置jstatd的远程RMI服务（当我们要看远程服务器上JAVA程序的GC情况的时候，需要执行此步骤），允许JVM工具查看JVM使用情况。\n\n将如下的代码存为文件 jstatd.all.policy，放到JAVA_HOME/bin中，其内容如下：不知道JAVA_HOME目录的，可以执行 which java查看。\n\ngrant codebase \"file:${java.home}/../lib/tools.jar\" {\n\npermission java.security.AllPermission;\n\n};\n\n执行命令jstatd -J-Djava.security.policy=jstatd.all.policy -J-Djava.rmi.server.hostname=10.27.20.38 &\n\n(10.27.20.38为你服务器的ip地址,&表示用守护线程的方式运行)\n\n2)、执行C:\\glassfish4\\jdk7\\bin\\jvisualvm.exe 打开JVM控制台。\n\n工具--插件--中找到Visual GC插件进行安装.\n\n3)、对要执行java程序进行调优，以 c1000k.jar为例，在该jar包所在目录下建立一个start.sh文件，文件内容如下。\n\njava -server -Xms4G -Xmx4G -Xmn2G -XX:SurvivorRatio=1 -XX:+UseConcMarkSweepGC -Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.port=1100 -Dcom.sun.management.jmxremote.authenticate=false -Dcom.sun.management.jmxremote.ssl=false -jar c1000k.jar&\n\n通过这样的配置，使用JVM控制台即可查看JVM(CPU/内存)及垃圾回收的情况。\n\n4)、控制台配置\n\n打开\\jvisualvm.exe，远程---添加远程主机---输入远程IP----添加JMX连接\n![aHR0cDovL3AzLnBzdGF0cC5jb20vbGFyZ2UvcGdjLWltYWdlL2VmN2ZhMzI1ZTcxNzRmZTRiZWI0ODk2MDRhY2U2YzQ4.jpg](http://ruizmypmv.hn-bkt.clouddn.com/ef35cf05-52d2-480b-b2e8-69886b5f83a7.jpg)\n5)、下面开始正式的JVM调优。\n\n5.1 JVM调优核心为调整年轻代、年老大的内存空间大小及使用GC发生器的类型等。回到上文的start.sh文件内容，我们来分下：\n\njava -server -Xms4G -Xmx4G -Xmn2G -XX:SurvivorRatio=1 -XX:+UseConcMarkSweepGC -Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.port=1100 -Dcom.sun.management.jmxremote.authenticate=false -Dcom.sun.management.jmxremote.ssl=false -jar c1000k.jar&\n\n这台机器是一个4G内存的机器，因此：\n\n-Xms4G 是指： JVM启动时整个堆(包括年轻代，年老代)的初始化大小。\n\n-Xmx4G 是指： JVM启动时整个堆的最大值。\n\n-Xmn2G是指：年轻代的空间大小，剩下的是年老代的空间。\n\n-XX:SurvivorRatio=1是指：年轻代空间中2个Survivor空间与Eden空间的大小比例。此处为1:1:1，算法如下：比如整个年轻代空间为2G，如果比例为1，那么2/3，则S0/S1/Eden的空间大小是同样的，为666M。\n\n该值不设置，则JDK默认为比例为8，那么是1:1:8，通过上面的算法可以得出S0/S1的大小。我们可以看到官方通过增大Eden区的大小，来减少YGC发生的次数，但有时我们发现，虽然次数减少了，但Eden区满\n\n的时候，由于占用的空间较大，导致释放缓慢，此时stop-the-world的时间较长，因此需要按照程序情况去调优。\n\n-XX:+UseConcMarkSweepGC是指：使用GC的回收类型。这里是CMS类型，JDK1.7以后推荐使用+UseG1GC，被称为G1类型(或Garbage First)的回收器。\n\n5.2当我们设定好start.sh的参数值后，执行./start.sh此时就启动了。\n\n我们可以通过jvisualvm.exe中的Visual GC插件查看GC的图形，我们也可以再服务器上执行：jstat -gc 15016 1000，看到每1秒钟java进程号为15016的GC回收情况。\n\n[root@yxdevapp04 c1000k]# jstat -gc 15016 1000\n\nS0C S1C S0U S1U EC EU OC OU PC PU YGC YGCT FGC FGCT GCT\n\n699008.0 699008.0 29980.4 0.0 699136.0 116881.6 2097152.0 660769.4 21248.0 20071.0 354 54.272 0 0.000 54.272\n\n699008.0 699008.0 29980.4 0.0 699136.0 118344.8 2097152.0 660769.4 21248.0 20071.0 354 54.272 0 0.000 54.272\n\n699008.0 699008.0 29980.4 0.0 699136.0 119895.5 2097152.0 660769.4 21248.0 20071.0 354 54.272 0 0.000 54.272\n\n699008.0 699008.0 29980.4 0.0 699136.0 121383.1 2097152.0 660769.4 21248.0 20071.0 354 54.272 0 0.000 54.272\n\n解释如下：\n\nS0C 是指：Survivor0区的分配空间\n\nS0U 是指：Survivor1区的已经使用的空间\n\nEC是指:Eden区所使用的空间\n\nEU是指：Eden区当前使用的空间\n\nOC是指：老年代分配的空间\n\nOU是指：老年代当前使用的空间\n\nPC是指：持久待分配的空间\n\nPU是指：持久待当前使用的空间\n\nYGC是指：年轻代发生的次数，这里是354次\n\nYGCT是指：年轻代发送的总时长，这里是54.272秒，因此每次年轻代发生GC，即平均每次stop-the-world的时长为54.272/354=0.153秒。\n\nFGC是指：年老代回收的次数，或者成为FullGC的次数。\n\nFGCT是指：年老代发生回收的总时长。\n\nGCT是指：包括年轻代YGC及年老代FGC的总时间长。\n\n通常结合图形或数据，我们可以看到当EU即将等于EC的时候，此时发生YGC，因此YGC次数+1，YGCT时间增加。\n\n经过实际的调优测试我们发现，当发生YGC的时候，如果S0U或S1U区如果有任意一个区域为0的时候，此时YGC的速度很快，相反如果S0U或者S1U中都有数据，或相对满的时候，此时YGC的时间边长，这就是因为S0/S1及Eden区的比例问题导致的。\n\n5.3经过一定时间的调优，我们基本上可以使得YGC的次数非常少，时间非常快，很长时间，数天都不会发生FGC，此时JVM的调优算是一个好的结果。\n\n5.4 在MAC电脑上可以通过jconsole调出图形化分析工具。\n————————————————\n版权声明：本文为CSDN博主「Lemon-」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。\n原文链接：https://blog.csdn.net/Javazhoumou/article/details/99298624', '<h2><a id=\"_0\"></a>基本概念：</h2>\n<p>JVM把内存区分为堆区(heap)、栈区(stack)和方法区(method)。由于本文主要讲解JVM调优，因此我们可以简单的理解为，JVM中的堆区中存放的是实际的对象，是需要被GC的。其他的都无需GC。</p>\n<p>下图文JVM的内存模型<br />\n<img src=\"http://ruizmypmv.hn-bkt.clouddn.com/7cfdd513-04a8-48c9-a668-3d18450156c3.jpg\" alt=\"aHR0cDovL3AzLnBzdGF0cC5jb20vbGFyZ2UvcGdjLWltYWdlLzJmNjdmYzQzMWE5NzQ4ODk5OWNiNWNlMzQ4ZjNjMzA5.jpg\" /><br />\n从图中我们可以看到，</p>\n<p>1、JVM实质上分为三大块，年轻代(YoungGen)，年老代(Old Memory)，及持久代(Perm，在Java8中被取消，我们不做深入介绍)。</p>\n<p>2、垃圾回收GC，分为2种，一是Minor GC，可以可以称为YGC，即年轻代GC，当Eden区，还有一种称为Major GC，又称为FullGC。</p>\n<p>3、GC原理：</p>\n<p>我们可以看到年轻代包括Eden区(对象刚被new出来的时候，放到该区)，S0和S1，是幸存者1区和幸存者2区，从名字可以看出，是当发生YGC，没有被任何其他对象所引用的对象将会从内存中被清除，还被其他对象引用的则放到幸存者区。当发生多次YGC，在S0、S1区多次没有被清楚的对象，则会被移到老年代区域。当老年代区域被占满的时候，则会发送FullGC。</p>\n<p>无论是YGC或是FullGC，都会导致stop-the-world，即整个程序停止一些事务的处理，只有GC进程允许以进行垃圾回收，因此如果垃圾回收时间较长，部分web或socket程序，当终端连接的时候会报connetTimeOut或readTimeOut异常，</p>\n<p>4、从JVM调优的角度来看，我们应该尽量避免发生YGC或FullGC，或者使得YGC和FullGC的时间足够的短。</p>\n<h2><a id=\"JMV_20\"></a>JMV调优的准备工作。</h2>\n<p>1)、配置jstatd的远程RMI服务（当我们要看远程服务器上JAVA程序的GC情况的时候，需要执行此步骤），允许JVM工具查看JVM使用情况。</p>\n<p>将如下的代码存为文件 jstatd.all.policy，放到JAVA_HOME/bin中，其内容如下：不知道JAVA_HOME目录的，可以执行 which java查看。</p>\n<p>grant codebase “file:${java.home}/…/lib/tools.jar” {</p>\n<p>permission java.security.AllPermission;</p>\n<p>};</p>\n<p>执行命令jstatd -J-Djava.security.policy=jstatd.all.policy -J-Djava.rmi.server.hostname=10.27.20.38 &amp;</p>\n<p>(10.27.20.38为你服务器的ip地址,&amp;表示用守护线程的方式运行)</p>\n<p>2)、执行C:\\glassfish4\\jdk7\\bin\\jvisualvm.exe 打开JVM控制台。</p>\n<p>工具–插件–中找到Visual GC插件进行安装.</p>\n<p>3)、对要执行java程序进行调优，以 c1000k.jar为例，在该jar包所在目录下建立一个start.sh文件，文件内容如下。</p>\n<p>java -server -Xms4G -Xmx4G -Xmn2G -XX:SurvivorRatio=1 -XX:+UseConcMarkSweepGC -Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.port=1100 -Dcom.sun.management.jmxremote.authenticate=false -Dcom.sun.management.jmxremote.ssl=false -jar c1000k.jar&amp;</p>\n<p>通过这样的配置，使用JVM控制台即可查看JVM(CPU/内存)及垃圾回收的情况。</p>\n<p>4)、控制台配置</p>\n<p>打开\\jvisualvm.exe，远程—添加远程主机—输入远程IP----添加JMX连接<br />\n<img src=\"http://ruizmypmv.hn-bkt.clouddn.com/ef35cf05-52d2-480b-b2e8-69886b5f83a7.jpg\" alt=\"aHR0cDovL3AzLnBzdGF0cC5jb20vbGFyZ2UvcGdjLWltYWdlL2VmN2ZhMzI1ZTcxNzRmZTRiZWI0ODk2MDRhY2U2YzQ4.jpg\" /><br />\n5)、下面开始正式的JVM调优。</p>\n<p>5.1 JVM调优核心为调整年轻代、年老大的内存空间大小及使用GC发生器的类型等。回到上文的start.sh文件内容，我们来分下：</p>\n<p>java -server -Xms4G -Xmx4G -Xmn2G -XX:SurvivorRatio=1 -XX:+UseConcMarkSweepGC -Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.port=1100 -Dcom.sun.management.jmxremote.authenticate=false -Dcom.sun.management.jmxremote.ssl=false -jar c1000k.jar&amp;</p>\n<p>这台机器是一个4G内存的机器，因此：</p>\n<p>-Xms4G 是指： JVM启动时整个堆(包括年轻代，年老代)的初始化大小。</p>\n<p>-Xmx4G 是指： JVM启动时整个堆的最大值。</p>\n<p>-Xmn2G是指：年轻代的空间大小，剩下的是年老代的空间。</p>\n<p>-XX:SurvivorRatio=1是指：年轻代空间中2个Survivor空间与Eden空间的大小比例。此处为1:1:1，算法如下：比如整个年轻代空间为2G，如果比例为1，那么2/3，则S0/S1/Eden的空间大小是同样的，为666M。</p>\n<p>该值不设置，则JDK默认为比例为8，那么是1:1:8，通过上面的算法可以得出S0/S1的大小。我们可以看到官方通过增大Eden区的大小，来减少YGC发生的次数，但有时我们发现，虽然次数减少了，但Eden区满</p>\n<p>的时候，由于占用的空间较大，导致释放缓慢，此时stop-the-world的时间较长，因此需要按照程序情况去调优。</p>\n<p>-XX:+UseConcMarkSweepGC是指：使用GC的回收类型。这里是CMS类型，JDK1.7以后推荐使用+UseG1GC，被称为G1类型(或Garbage First)的回收器。</p>\n<p>5.2当我们设定好start.sh的参数值后，执行./start.sh此时就启动了。</p>\n<p>我们可以通过jvisualvm.exe中的Visual GC插件查看GC的图形，我们也可以再服务器上执行：jstat -gc 15016 1000，看到每1秒钟java进程号为15016的GC回收情况。</p>\n<p>[root@yxdevapp04 c1000k]# jstat -gc 15016 1000</p>\n<p>S0C S1C S0U S1U EC EU OC OU PC PU YGC YGCT FGC FGCT GCT</p>\n<p>699008.0 699008.0 29980.4 0.0 699136.0 116881.6 2097152.0 660769.4 21248.0 20071.0 354 54.272 0 0.000 54.272</p>\n<p>699008.0 699008.0 29980.4 0.0 699136.0 118344.8 2097152.0 660769.4 21248.0 20071.0 354 54.272 0 0.000 54.272</p>\n<p>699008.0 699008.0 29980.4 0.0 699136.0 119895.5 2097152.0 660769.4 21248.0 20071.0 354 54.272 0 0.000 54.272</p>\n<p>699008.0 699008.0 29980.4 0.0 699136.0 121383.1 2097152.0 660769.4 21248.0 20071.0 354 54.272 0 0.000 54.272</p>\n<p>解释如下：</p>\n<p>S0C 是指：Survivor0区的分配空间</p>\n<p>S0U 是指：Survivor1区的已经使用的空间</p>\n<p>EC是指:Eden区所使用的空间</p>\n<p>EU是指：Eden区当前使用的空间</p>\n<p>OC是指：老年代分配的空间</p>\n<p>OU是指：老年代当前使用的空间</p>\n<p>PC是指：持久待分配的空间</p>\n<p>PU是指：持久待当前使用的空间</p>\n<p>YGC是指：年轻代发生的次数，这里是354次</p>\n<p>YGCT是指：年轻代发送的总时长，这里是54.272秒，因此每次年轻代发生GC，即平均每次stop-the-world的时长为54.272/354=0.153秒。</p>\n<p>FGC是指：年老代回收的次数，或者成为FullGC的次数。</p>\n<p>FGCT是指：年老代发生回收的总时长。</p>\n<p>GCT是指：包括年轻代YGC及年老代FGC的总时间长。</p>\n<p>通常结合图形或数据，我们可以看到当EU即将等于EC的时候，此时发生YGC，因此YGC次数+1，YGCT时间增加。</p>\n<p>经过实际的调优测试我们发现，当发生YGC的时候，如果S0U或S1U区如果有任意一个区域为0的时候，此时YGC的速度很快，相反如果S0U或者S1U中都有数据，或相对满的时候，此时YGC的时间边长，这就是因为S0/S1及Eden区的比例问题导致的。</p>\n<p>5.3经过一定时间的调优，我们基本上可以使得YGC的次数非常少，时间非常快，很长时间，数天都不会发生FGC，此时JVM的调优算是一个好的结果。</p>\n<p>5.4 在MAC电脑上可以通过jconsole调出图形化分析工具。<br />\n————————————————<br />\n版权声明：本文为CSDN博主「Lemon-」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br />\n原文链接：https://blog.csdn.net/Javazhoumou/article/details/99298624</p>\n', 1658816190316920833);
INSERT INTO `ms_article_body` VALUES (1658818233442091010, '# 1. 介绍\n- `get请求` 通常用于 `获取服务端资源`（向服务器要资源）\n​ 例如：根据URL地址，从服务器获取HTML文件、CSS文件、JS文件、图片文件、数据资源等。\n\n- `post请求` 通常用于 `向服务器提交数据`（往服务器发送资源）\n​ 例如：登录时向服务器提交的登录信息、注册是向服务器提交的注册信息、添加用户时向服务器提交的用户信息等各种数据提交操作。\n\n- `ajax请求` 就比较综合，既可以发送 `get请求` 也可以发送 `post请求`\n# 2. 用法\n## 2.1. get请求\n语法：\n`$.get(url, [data], [callback]);  // 带有中括号的参数表示可以省略`\n参数介绍：\n| 参数  |  是否可省略 | 参数类型  | 参数作用  |\n| ------------ | ------------ | ------------ | ------------ |\nurl|	不可省略	|string|	规定你请求的url|\ndata	|可省略	|object	|请求资源期间要携带的参数|\ncallback	|可省略|	function|	请求成功后所执行的函数名\n案例：\n```\n // 发送get请求，请求 bookname 为 \'西游记\' 的数据\n $.get(\'http://www.liulongbin.top:3006/api/getbooks\', { bookname: \'西游记\' }, function (res) {\n   console.log(res);  // res 是服务器返回的数据\n})\n```\n## 2.2. post请求\n语法：\n\n`$.post(url, [data], [callback]);  // 带有中括号的参数表示可以省略`\n参数介绍：\n| 参数  |  是否可省略 | 参数类型  | 参数作用  |\n| ------------ | ------------ | ------------ | ------------ |\nurl	|不可省略|	string|	规定你请求的url\ndata	|可省略|	object	|要提交的数据\ncallback	|可省略	|function|	请求成功后所执行的函数名\n案例：\n```\n// 定义url\nlet url = \'http://www.liulongbin.top:3006/api/addbooks\'  \n// 定义data数据\nlet data = {\n  bookname: \'富婆成长计\',\n  author: \'tuoni\',\n  publisher: \'广东出版社\'\n}\n// post请求\n$.post(url, data, function (res) {\n  console.log(res);\n})\n```\n## 2.3. ajax请求\n语法以及参数：\n```\n$.ajax({\n  type: \'\',  // 请求的方式，例如 \'GET\' 或 \'POST\'\n  url: \'\',  // 请求的URL地址\n  data: {},  // 这次请求要携带的数据\n  success： function(res) {}  // 请求成功之后的回调函数\n})\n```', '<h1><a id=\"1__0\"></a>1. 介绍</h1>\n<ul>\n<li>\n<p><code>get请求</code> 通常用于 <code>获取服务端资源</code>（向服务器要资源）<br />\n​ 例如：根据URL地址，从服务器获取HTML文件、CSS文件、JS文件、图片文件、数据资源等。</p>\n</li>\n<li>\n<p><code>post请求</code> 通常用于 <code>向服务器提交数据</code>（往服务器发送资源）<br />\n​ 例如：登录时向服务器提交的登录信息、注册是向服务器提交的注册信息、添加用户时向服务器提交的用户信息等各种数据提交操作。</p>\n</li>\n<li>\n<p><code>ajax请求</code> 就比较综合，既可以发送 <code>get请求</code> 也可以发送 <code>post请求</code></p>\n</li>\n</ul>\n<h1><a id=\"2__8\"></a>2. 用法</h1>\n<h2><a id=\"21_get_9\"></a>2.1. get请求</h2>\n<p>语法：<br />\n<code>$.get(url, [data], [callback]);  // 带有中括号的参数表示可以省略</code><br />\n参数介绍：</p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>是否可省略</th>\n<th>参数类型</th>\n<th>参数作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>url</td>\n<td>不可省略</td>\n<td>string</td>\n<td>规定你请求的url</td>\n</tr>\n<tr>\n<td>data</td>\n<td>可省略</td>\n<td>object</td>\n<td>请求资源期间要携带的参数</td>\n</tr>\n<tr>\n<td>callback</td>\n<td>可省略</td>\n<td>function</td>\n<td>请求成功后所执行的函数名</td>\n</tr>\n</tbody>\n</table>\n<p>案例：</p>\n<pre><code class=\"lang-\"> // 发送get请求，请求 bookname 为 \'西游记\' 的数据\n $.get(\'http://www.liulongbin.top:3006/api/getbooks\', { bookname: \'西游记\' }, function (res) {\n   console.log(res);  // res 是服务器返回的数据\n})\n</code></pre>\n<h2><a id=\"22_post_25\"></a>2.2. post请求</h2>\n<p>语法：</p>\n<p><code>$.post(url, [data], [callback]);  // 带有中括号的参数表示可以省略</code><br />\n参数介绍：</p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>是否可省略</th>\n<th>参数类型</th>\n<th>参数作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>url</td>\n<td>不可省略</td>\n<td>string</td>\n<td>规定你请求的url</td>\n</tr>\n<tr>\n<td>data</td>\n<td>可省略</td>\n<td>object</td>\n<td>要提交的数据</td>\n</tr>\n<tr>\n<td>callback</td>\n<td>可省略</td>\n<td>function</td>\n<td>请求成功后所执行的函数名</td>\n</tr>\n</tbody>\n</table>\n<p>案例：</p>\n<pre><code class=\"lang-\">// 定义url\nlet url = \'http://www.liulongbin.top:3006/api/addbooks\'  \n// 定义data数据\nlet data = {\n  bookname: \'富婆成长计\',\n  author: \'tuoni\',\n  publisher: \'广东出版社\'\n}\n// post请求\n$.post(url, data, function (res) {\n  console.log(res);\n})\n</code></pre>\n<h2><a id=\"23_ajax_50\"></a>2.3. ajax请求</h2>\n<p>语法以及参数：</p>\n<pre><code class=\"lang-\">$.ajax({\n  type: \'\',  // 请求的方式，例如 \'GET\' 或 \'POST\'\n  url: \'\',  // 请求的URL地址\n  data: {},  // 这次请求要携带的数据\n  success： function(res) {}  // 请求成功之后的回调函数\n})\n</code></pre>\n', 1658818233379176450);
INSERT INTO `ms_article_body` VALUES (1658819577318064131, '# 工厂模式\n工厂模式：Factory pattern。属于建造行（创建型）模式，对对象的创建过程进行隐藏，没有直接暴露给客户端，可以通过一个共同的接口指向一个新创建的对象  \n## 1.1 介绍\n意图：定义一个箭扣，让所有的类继承这个接口，定义一个工厂的类，可以根据不同的条件来创建不同的实现类对象，将对象的创建延迟到其他类中。  \n主要解决：解决接口的选择的问题。   \n如何使用：我们确定计划，在不同的条件下需要不同的对象。  \n如何解决：将其子类具体的实现某个工厂接口，然后再创建一个工厂类，可以生产创造抽象的产品（指向这产品的接口）。  \n关键代码：创建过程在其子类中执行。  \n应用实例：\n1.买一辆车，直接去4s（相当于车的工厂类）店提车    \n2.Hibernate对应不同的驱动而已和对应的方言而已  \n优点：  \n1. 如果创建一个对象，只需要给条件  \n2. 拓展性高，在工厂里加东西，其他不受影响\n3. 屏蔽掉了产品的具体实现过程，关注产品的接口。`Connection coon=db.getConnection()`返回的是Connection接口   \n缺点：  \n1. 如果每次增加一个产品（具体的实现类），都需要增加一个实现类，再去重新构建一下工厂中的设计（耦合性高），类的个数递增了，增加了系统的复杂度增加了。    \n应用实例：举例\n- 数据库的访问（用户不想知道细节）\n- POP3(邮箱的协议)、JMAP、HTTP协议，统一的进行同一个接口的设计，再去访问工厂类，返回具体的协议\n- 日志管理：日志数据保存在本地磁盘、远程的服务器上、临时保存。此时关于日志处理，用户可以用工厂。\n## 1.2实现\n我们将创建一个shape接口和实现shape接口的实体类，下一步是定义工厂类ShapeFactory。  \nShapeFactoryDemo类使用ShapeFactory来获取Shape对象。它将向ShapeFactory传递信息，以便获取他所需的对象的类型。  \n![工厂实现.jpg](http://ruizmypmv.hn-bkt.clouddn.com/ab720aa8-f332-4d7e-a616-0f8060df4bd1.jpg)', '<h1><a id=\"_0\"></a>工厂模式</h1>\n<p>工厂模式：Factory pattern。属于建造行（创建型）模式，对对象的创建过程进行隐藏，没有直接暴露给客户端，可以通过一个共同的接口指向一个新创建的对象</p>\n<h2><a id=\"11__2\"></a>1.1 介绍</h2>\n<p>意图：定义一个箭扣，让所有的类继承这个接口，定义一个工厂的类，可以根据不同的条件来创建不同的实现类对象，将对象的创建延迟到其他类中。<br />\n主要解决：解决接口的选择的问题。<br />\n如何使用：我们确定计划，在不同的条件下需要不同的对象。<br />\n如何解决：将其子类具体的实现某个工厂接口，然后再创建一个工厂类，可以生产创造抽象的产品（指向这产品的接口）。<br />\n关键代码：创建过程在其子类中执行。<br />\n应用实例：<br />\n1.买一辆车，直接去4s（相当于车的工厂类）店提车<br />\n2.Hibernate对应不同的驱动而已和对应的方言而已<br />\n优点：</p>\n<ol>\n<li>如果创建一个对象，只需要给条件</li>\n<li>拓展性高，在工厂里加东西，其他不受影响</li>\n<li>屏蔽掉了产品的具体实现过程，关注产品的接口。<code>Connection coon=db.getConnection()</code>返回的是Connection接口<br />\n缺点：</li>\n<li>如果每次增加一个产品（具体的实现类），都需要增加一个实现类，再去重新构建一下工厂中的设计（耦合性高），类的个数递增了，增加了系统的复杂度增加了。<br />\n应用实例：举例</li>\n</ol>\n<ul>\n<li>数据库的访问（用户不想知道细节）</li>\n<li>POP3(邮箱的协议)、JMAP、HTTP协议，统一的进行同一个接口的设计，再去访问工厂类，返回具体的协议</li>\n<li>日志管理：日志数据保存在本地磁盘、远程的服务器上、临时保存。此时关于日志处理，用户可以用工厂。</li>\n</ul>\n<h2><a id=\"12_21\"></a>1.2实现</h2>\n<p>我们将创建一个shape接口和实现shape接口的实体类，下一步是定义工厂类ShapeFactory。<br />\nShapeFactoryDemo类使用ShapeFactory来获取Shape对象。它将向ShapeFactory传递信息，以便获取他所需的对象的类型。<br />\n<img src=\"http://ruizmypmv.hn-bkt.clouddn.com/ab720aa8-f332-4d7e-a616-0f8060df4bd1.jpg\" alt=\"工厂实现.jpg\" /></p>\n', 1658819577250955265);
INSERT INTO `ms_article_body` VALUES (1658819789432406019, '# 抽象工厂模式（业务更加复杂时。）\nAbstract Factory Pattern.围绕一个超级工厂来创建其他工厂。这个超级工厂称之为工厂的工厂，是创建型模式。  \n接口是负责创建一个工厂的标准约束，显然它不在指向某个实现类。\n## 2.1 介绍\n意图：创建和提供一系列相互依赖和相互关联对象的接口，无需指向具体的实现类    \n主要解决：解决的是接口的选择问题  \n何时使用：系统的产品有多个产品族。而多个产品族里某个时刻只需要是摸个产品  \n如何解决：在一个产品族里，定义多个产品    \n关键代码：再一个工厂中如何将多个产品聚集在一块形成一个产品族。  \n应用实例：多层依赖，每层依赖都会产生一定抽象：衣物存放    \n优点：\n1. 当一个产品族中的多个对象被设计再一起工作时，可以保证客户端使用只使用同一个产品族就可以得到具体的产品。   \n缺点：\n1. 非常的难进行扩充，如果增加新的模块，需要调整整个项目的结构，有些类的内部细节甚至都需要进行调整。  \n使用场景：  \n1. QQ换皮肤，一整套一起换\n2. 生成不同的操作系统能够识别的程序  \n注意事项：产品的族不容易拓展，但是具体的产品容易拓展。  \n## 2.2 实现\n![抽象工厂实现.jpg](./抽象工厂实现.jpg)\n**代码见Design_pattern**', '<h1><a id=\"_0\"></a>抽象工厂模式（业务更加复杂时。）</h1>\n<p>Abstract Factory Pattern.围绕一个超级工厂来创建其他工厂。这个超级工厂称之为工厂的工厂，是创建型模式。<br />\n接口是负责创建一个工厂的标准约束，显然它不在指向某个实现类。</p>\n<h2><a id=\"21__3\"></a>2.1 介绍</h2>\n<p>意图：创建和提供一系列相互依赖和相互关联对象的接口，无需指向具体的实现类<br />\n主要解决：解决的是接口的选择问题<br />\n何时使用：系统的产品有多个产品族。而多个产品族里某个时刻只需要是摸个产品<br />\n如何解决：在一个产品族里，定义多个产品<br />\n关键代码：再一个工厂中如何将多个产品聚集在一块形成一个产品族。<br />\n应用实例：多层依赖，每层依赖都会产生一定抽象：衣物存放<br />\n优点：</p>\n<ol>\n<li>当一个产品族中的多个对象被设计再一起工作时，可以保证客户端使用只使用同一个产品族就可以得到具体的产品。<br />\n缺点：</li>\n<li>非常的难进行扩充，如果增加新的模块，需要调整整个项目的结构，有些类的内部细节甚至都需要进行调整。<br />\n使用场景：</li>\n<li>QQ换皮肤，一整套一起换</li>\n<li>生成不同的操作系统能够识别的程序<br />\n注意事项：产品的族不容易拓展，但是具体的产品容易拓展。</li>\n</ol>\n<h2><a id=\"22__18\"></a>2.2 实现</h2>\n<p><img src=\"./%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E5%AE%9E%E7%8E%B0.jpg\" alt=\"抽象工厂实现.jpg\" /><br />\n<strong>代码见Design_pattern</strong></p>\n', 1658819789432406017);
INSERT INTO `ms_article_body` VALUES (1658820077463650308, '1. java运行时一个类是什么时候被加载的\n一个类什么时候开始被加载，《java虚拟机规范》中没有进行强制约束，交给了虚拟机自己去实现，HotSpot虚拟机是按需加载，在需要用到这个类的时候再加载这个类。\n1）sun公司最早的classic虚拟机\n2）sun/oracle公司的Hotspot虚拟机\n3）BEA公司的JRockit虚拟机\n3）IBM公司的IBM J9虚拟机\n\n-XX:+TraceClassLoading 监控类的加载	  \n\n1.2 jvm一个类的加载过程\n1.加载\n\n2.验证\n3.准备 -->三个统称为链接（linking）\n4.解析\n\n5.初始化\n6.使用\n7.卸载\n加载 验证 准备 解析 初始化 使用 卸载\n加载：classpath、jar包、网络、某个磁盘位置下的类的class二进制字节流读进来，在内存中生成一个代表这个类的java.lang.Class对象放入元空间，此阶段我们程序员可以干预，我们可以自定义类加载器来实现类的加载;\n\n验证：验证Class文件的字节流中包含的信息符合《java虚拟机规范》的全部约束要求，保证虚拟机的安全\n\n准备：类变量（static）赋默认初始值（boolean为false，int为0），常量在准备阶段就已经赋正式值了；\n\n解析：将常量池内的符号引用翻译为直接引用；\n\n初始化：当我们new一个类的对象，访问一个类的静态属性，修改一个类的静态属性，调用一个类的静态方法，用反射API对一个类进行调用，初始化当前类，其父类也会被初始化...,那么这些都会触发类的初始化；\n\n使用：使用这个类\n\n卸载：\n1.该类所有的实例都已经被GC，也就是JVM中不存在该Class的任何实例\n2.加载该类的ClassLoader已经被GC；\n3.该类的java.lang.Class对象没有在任何地方被引用，也不能在任何地方通过反射访问该类的方法 \n\n1.3 一个类被初始化的过程？\n准备阶段已经赋过一次系统要求的初始零值，而在初始化阶段，才正真初始化类变量和其他资源。\n静态常量、静态变量、静态初始化块在加载类的时候就初始话了，后面的是在创建对象执行\n静态常量->静态变量->静态初始化块->变量->初始化块->构造器\n\n1.4 继承时父子类的初始化顺序是怎样的？\n（静态变量和静态代码块执行是看顺序的）\n父类--静态变量\n父类--静态初始化快\n子类--静态变量\n子类--静态初始化块\n父类--变量\n父类--初始化块\n父类--构造器\n子类--变量\n子类--初始化块\n子类--构造器\n\nmain（入口类）会执行初始化  \n\n1.5 究竟什么是类加载器？\n在类加载阶段，通过一个类的全限定名来获取描述该类的二进制字节流的这个动作的\"代码\"被称为类加载器，这个动作是可以自定义实现的；（是一个程序、也是代码）\n\n1.6 JVM有哪些类加载器？\n站在Java虚拟机的角度来看，只存在两种不同的类加载器：\n（1）启动类加载器（Bootstrap ClassLoader），使用C++语言实现，是虚拟机自身的一部份；\n（2）其他所有的类加载器，由Java语言实现，独立存在于虚拟机外部，并且全部继承自抽象类java.lang.ClassLoader;\n\n站在java开发者的角度来看，自jdk1.2开始， java一直保持着三层类加载器架构；\n   BootstrapClassLoader\n      ExtClassLoader\n      AppClassLoader\n自定义类加载器A  自定义类加载器B  \n\n1.7 jvm中不同的类加载器加载哪些文件？\n1. 启动类加载器（Bootstrap ClassLoader  C++实现的，java打印不出来）：（根据类加载器）\n<JAVA_HOME>\\jre\\lib\\rt.jar,resources.jar,charsets.jar \n被-Xbootclasspath参数所指定的路径中存放的类库；\n2. 拓展类加载器（ExtClassLoader）\nsun.misc.Launcher$ExtClassLoader,\n<JAVA_HOME>\\jre\\lib\\ext\n被java.exe.dirs系统变量所指定的路径中所有的类库\n3. 应用程序类加载器（AppClassLoader）：系统的类加载器\nsun.misc.Launcher$AppClassLoader\n加载用户类路径（ClassPath）上所有的类库（包括引入的jar包）  \n\n内部类的全限定类名表示方法：	\nclasscom.test.InnerClassTest$1Inner \n\n1.8 jvm三层类加载器之间的关系是继承吗？\n不是，都是launcher的静态内部类，有相同的父类（包括自定义类加载器也不是）\n\n1.9 双亲委派机制\n向上委派（查找缓存），向下查找（查找加载路径）\n\n好处：\n	主要是为了安全性，避免用户自己编写的类动态替换java的一些核心类，比如String\n	同时也避免类的重复加载，因为jvm中区分不同类，不仅仅是根据类名，相同的class文件被不同的classLoader加载就是不同的两个类\n	\n', '<ol>\n<li>java运行时一个类是什么时候被加载的<br />\n一个类什么时候开始被加载，《java虚拟机规范》中没有进行强制约束，交给了虚拟机自己去实现，HotSpot虚拟机是按需加载，在需要用到这个类的时候再加载这个类。<br />\n1）sun公司最早的classic虚拟机<br />\n2）sun/oracle公司的Hotspot虚拟机<br />\n3）BEA公司的JRockit虚拟机<br />\n3）IBM公司的IBM J9虚拟机</li>\n</ol>\n<p>-XX:+TraceClassLoading 监控类的加载</p>\n<p>1.2 jvm一个类的加载过程<br />\n1.加载</p>\n<p>2.验证<br />\n3.准备 --&gt;三个统称为链接（linking）<br />\n4.解析</p>\n<p>5.初始化<br />\n6.使用<br />\n7.卸载<br />\n加载 验证 准备 解析 初始化 使用 卸载<br />\n加载：classpath、jar包、网络、某个磁盘位置下的类的class二进制字节流读进来，在内存中生成一个代表这个类的java.lang.Class对象放入元空间，此阶段我们程序员可以干预，我们可以自定义类加载器来实现类的加载;</p>\n<p>验证：验证Class文件的字节流中包含的信息符合《java虚拟机规范》的全部约束要求，保证虚拟机的安全</p>\n<p>准备：类变量（static）赋默认初始值（boolean为false，int为0），常量在准备阶段就已经赋正式值了；</p>\n<p>解析：将常量池内的符号引用翻译为直接引用；</p>\n<p>初始化：当我们new一个类的对象，访问一个类的静态属性，修改一个类的静态属性，调用一个类的静态方法，用反射API对一个类进行调用，初始化当前类，其父类也会被初始化…,那么这些都会触发类的初始化；</p>\n<p>使用：使用这个类</p>\n<p>卸载：<br />\n1.该类所有的实例都已经被GC，也就是JVM中不存在该Class的任何实例<br />\n2.加载该类的ClassLoader已经被GC；<br />\n3.该类的java.lang.Class对象没有在任何地方被引用，也不能在任何地方通过反射访问该类的方法</p>\n<p>1.3 一个类被初始化的过程？<br />\n准备阶段已经赋过一次系统要求的初始零值，而在初始化阶段，才正真初始化类变量和其他资源。<br />\n静态常量、静态变量、静态初始化块在加载类的时候就初始话了，后面的是在创建对象执行<br />\n静态常量-&gt;静态变量-&gt;静态初始化块-&gt;变量-&gt;初始化块-&gt;构造器</p>\n<p>1.4 继承时父子类的初始化顺序是怎样的？<br />\n（静态变量和静态代码块执行是看顺序的）<br />\n父类–静态变量<br />\n父类–静态初始化快<br />\n子类–静态变量<br />\n子类–静态初始化块<br />\n父类–变量<br />\n父类–初始化块<br />\n父类–构造器<br />\n子类–变量<br />\n子类–初始化块<br />\n子类–构造器</p>\n<p>main（入口类）会执行初始化</p>\n<p>1.5 究竟什么是类加载器？<br />\n在类加载阶段，通过一个类的全限定名来获取描述该类的二进制字节流的这个动作的&quot;代码&quot;被称为类加载器，这个动作是可以自定义实现的；（是一个程序、也是代码）</p>\n<p>1.6 JVM有哪些类加载器？<br />\n站在Java虚拟机的角度来看，只存在两种不同的类加载器：<br />\n（1）启动类加载器（Bootstrap ClassLoader），使用C++语言实现，是虚拟机自身的一部份；<br />\n（2）其他所有的类加载器，由Java语言实现，独立存在于虚拟机外部，并且全部继承自抽象类java.lang.ClassLoader;</p>\n<p>站在java开发者的角度来看，自jdk1.2开始， java一直保持着三层类加载器架构；<br />\nBootstrapClassLoader<br />\nExtClassLoader<br />\nAppClassLoader<br />\n自定义类加载器A  自定义类加载器B</p>\n<p>1.7 jvm中不同的类加载器加载哪些文件？</p>\n<ol>\n<li>启动类加载器（Bootstrap ClassLoader  C++实现的，java打印不出来）：（根据类加载器）<br />\n&lt;JAVA_HOME&gt;\\jre\\lib\\rt.jar,resources.jar,charsets.jar<br />\n被-Xbootclasspath参数所指定的路径中存放的类库；</li>\n<li>拓展类加载器（ExtClassLoader）<br />\nsun.misc.Launcher$ExtClassLoader,<br />\n&lt;JAVA_HOME&gt;\\jre\\lib\\ext<br />\n被java.exe.dirs系统变量所指定的路径中所有的类库</li>\n<li>应用程序类加载器（AppClassLoader）：系统的类加载器<br />\nsun.misc.Launcher$AppClassLoader<br />\n加载用户类路径（ClassPath）上所有的类库（包括引入的jar包）</li>\n</ol>\n<p>内部类的全限定类名表示方法：	<br />\nclasscom.test.InnerClassTest$1Inner</p>\n<p>1.8 jvm三层类加载器之间的关系是继承吗？<br />\n不是，都是launcher的静态内部类，有相同的父类（包括自定义类加载器也不是）</p>\n<p>1.9 双亲委派机制<br />\n向上委派（查找缓存），向下查找（查找加载路径）</p>\n<p>好处：<br />\n主要是为了安全性，避免用户自己编写的类动态替换java的一些核心类，比如String<br />\n同时也避免类的重复加载，因为jvm中区分不同类，不仅仅是根据类名，相同的class文件被不同的classLoader加载就是不同的两个类</p>\n', 1658820077463650306);
INSERT INTO `ms_article_body` VALUES (1658820246917726210, '聚簇索引：将数据存与索引放到一块，索引结构的叶子节点保存了行数据\n非聚簇索引：将数据和索引分开存储，索引结构的叶子节点指向了数据对应的位置。 \n在innodb中，在聚簇索引之上创建的索引称之为辅助索引，非聚簇索引都是辅助索引，像复合索引、前缀索引、唯一索引。辅助索引存储的是主键值\n\n什么时候不能进行索引：\n1.使用like关键字进行查询的时候，%出现在左边，无法利用索引\n2.普通语句上使用多列索引：只有查询字段使用了多列索引中的第一个才可以使用（最左原则）\n3.查询语句中使用or关键字：如果or前后两个关键字都是索引，就会使用。如果or前后有一个条件列不是索引，就不能使用索引\n\n \n44、索引的基本原理\n	索引用来快速查找那些具有特定值的记录。如果没有索引，一般来说执行查询时遍历整张表。\n？？索引的原理：就是把无序的数据变为有序的查询\n	1.把创建了索引的列的内容进行排序\n	2.对排序结果生成倒排表\n	3.在倒排表内容上拼上数据地址链\n	4.在查询的时候，先拿到倒排表内容，再取出数据地址链，从而拿到具体数据\n\n\n\nCREATE TABLE [ IF NOT EXISTS ] `表名`(\n	`字段名1`    列类型 [ 属性 ]  [ 索引 ] [注释] ,\n	`字段名2`   列类型 [ 属性 ]  [ 索引 ] [注释] , \n	 … …    \n	 `字段名n`   列类型 [ 属性 ]  [ 索引 ] [注释] \n)  [ 表类型] [表字符集] [注释] ;\n\n表类型：ENGINE关键字\n表字符集：CHARSET关键字\nMySQL的数据表的类型：MyISAM、InnoDB 、HEAP、BOB、CSV等\n常用的有：MyISAM、InnoDB\n\"CREATE TABLE `subject` (\n  `SubjectNo` INT(11) NOT NULL COMMENT \'课程编号\',\n  `SubjectName` VARCHAR(50) DEFAULT NULL COMMENT \'课程名称\',\n  `ClassHour` INT(4) DEFAULT NULL COMMENT \'学时\',\n  `GradeID` INT(4) DEFAULT NULL COMMENT \'年级编号\',\n) ENGINE=INNODB CHARSET=utf8\n\"\n\nalter语句:\n1.修改表名：\nalter table 旧表名 rename as 新表名\n\n2.添加字段：\nalter table 表名 add 字段名 列类型[属性]\n\n3.修改字段：\n// 此种修改方式无法修改列名\nALTER TABLE 表名 MODIFY 字段名 列类型[属性]\n// 若要修改列名用change的方式\nALTER TABLE 表名 CHANGE 旧字段名 新字段名 列类型[属性]\n\n4.删除字段\nALTER TABLE 表名 DROP 字段名 \n\ndrop语句\nDROP TABLE [IF EXISTS] 表名\n\n\n为什么我们不建立外键：\n\n有外键关联的时候，从表的信息必须是主表的数据中存在的值，所以有外间关联时需要先插入主表信息。\n在我们正常的开发中，一般使用虚拟外键的思想，这样有助于对表进行管理，提高效率。\n有外键关联时，添加信息需要先添加主表信息，删除信息需要先删除从表的信息，这样使得效率下降  \n\n5.删除约束 DROP 如果创建的约束取名了，那么删除时就需要通过名称删除,如果没有写名称，会有默认名字\nALTER TABLE student DROP FOREIGN KEY fk;\n-- 删除唯一约束\nALTER TABLE cars DROP INDEX s_phone; \n\ntruncate语句\n作用：\n用于完全清空表数据，但表结构、索引、约束等不变\n语法：TRUNCATE [TABLE] table_name  \n\n修改密码\n#切换到mysql库\nuse mysql;\n#更新密码\nUPDATE user SET password=password(\'新密码\') WHERE user=\'用户名\' AND host=\'IP地址\';\n#刷新权限\nFLUSH PRIVILEGES;\n\n#合并常规字符串\nSELECT concat(\'Alian\',\' lover\',\' java\') as \'字符串合并\'; \n+------------------+\n| 字符串合并       |\n+------------------+\n| Alian lover java |\n+------------------+\n\n#给前面4个员工名字后面都拼一个 lover mysql\nSELECT concat(emp_name,\' lover\',\' mysql\') as \'字符串合并\' from tb_employee limit 4; \n+-----------------------+\n| 字符串合并            |\n+-----------------------+\n| 赖晓畅 lover mysql    |\n| 谢又蓝 lover mysql    |\n| 吕芸溪 lover mysql    |\n| 谭淑慧 lover mysql    |\n+-----------------------+\n\n\n1、索引设计原则（占用空间更小、查询更快）理解几个就行\n	1.对于经常查询的字段，建议创建索引。..\n	2.索引不是越多越好，一个表如果有大量索引，不仅占用磁盘空间，而且会影响INSERT，DELETE，UPDATE等语句的性能。\n	3.避免对经常更新的表进行过多的索引，因为当表中数据更改的同时，索引也会进行调整和更新，十分消耗系统资源。\n	4.数据量小的表建议不要创建索引，数据量小时索引不仅起不到明显的优化效果，对于索引结构的维护反而消耗系统资源。\n	5.不要在区分度低的字段建立索引。比如性别字段，只有 “男” 和 “女” ，建索引完全起不到优化效果。\n	6.对于定义为text。image和bit的数据类型不要建立索引。\n	7.在频繁进行跑排列分组（即进行 group by 或 order by操作）的列上建立索引，如果待排序有多个，可以在这些列上建立组合索引。\n	8.使用短索引，如果对长字符串进行索引，应该指定一个前缀长度，这样能节省大量索引空间\n	9.有外键的表一定要建立索引\n	10.尽量拓展索引，不要新建索引（联合索引）\n2.事务的基本特性和隔离级别\n	https://developer.aliyun.com/article/743691\n	\n	\n2、分库分表\n	什么是分库分表：当表中的数据量过大时，整个查询效率就会明显的降低。这时为了提高查询效率，就会将一个表中的数据分散到多个数据库的多个表当中。\n	\n	分库分表的方式：分库分表包含分库和分表两个部分，而这两个部分可以统称为数据分片，其目的都是将数据拆分成不同的存储单元。从拆分的角度上，可以分为垂直分片和水平分片。\n	\n	垂直分片：按照业务将不同的表拆分到不同的库中，又称为纵向分片。他的核心就是转库专用。解决数据库数据文件过大的问题，但是不能从根本上解决查询问题。\n	水平分片：就是从数据角度将一个表中的数据拆分到不同的库或表中，这样可以从根本上解决数据量过大造成的查询效率低的问题。\n	\n	水平分片策略：\n	取余/取模：	优点 均匀存放数据，缺点 扩容非常麻烦，数据移动量大\n	按照范围分布：比较好扩容，但是数据不够均匀\n	按照时间分片：比较容易将热点数据区分开\n	按枚举值。。。\n	\n	阿里提供的开发手册中，建议：预测三年的业务量，一个表中的数据超过500万，或者数据文件超过2G，需要考虑分库分表。\n	\n	分库分表后，sql语句的执行流程：\n	\n	\n3、mysql主从同步原理\n	MySQL的主从复制中主要有三个线程： master（bin log dump thread）、slave（I/O thread 、SQL thread） ，Master一条线程和Slave中的两条线程。\n	\n	-主节点 binlog日志，主从复制的基础是主库记录数据库的所有变更记录到binlog。binlog 是数据库服务器启动的那一刻起，保存所有修改数据库结构或内容的一个文件。\n	-主节点log dump 线程，当 binlog 有变动时，log dump 线程读取其内容并发送给从节点。\n	- 从节点 I/O线程接收 binlog 内容，并将其写入到 relay log 文件中。\n	- 从节点的SQL 线程读取 relay log 文件内容对数据更新进行重放，最终保证主从数据库的一致性。\n	\n	注：主从节点使用 bing log 文件 + position 偏移量来定位主从同步的位置，从节点会保存其已接收到的偏移量，如果从节点发生宕机重启，则会自动从 position 的位置发起同步。 \n	\n	由于mysql默认的复制方式是异步的，主库把日志发送给从库后不关心从库是否已经处理，这样会产生一个问题：假设主库挂了，从库处理失败了，这时候从库升级为主库后，日志就丢失了。由此产生两个概念：\n	\n	1、全同步复制：主库写入binlog后强制同步日志到从库，所有的从库都执行完成后才返回给客户端，但是很显然这个方式很影响性能\n	2、半同步复制：从库写入日志成功后返回ACK确认给主库，主库收到至少一个从库的确认就认为写操作完成。\n4、MyISAM、InnoDB的区别？\n	MyISAM：\n	不支持事务，但是每次查询都是原子的；\n	支持表级锁，即每次操作是对整个表加锁；\n	存储表的总行数;\n	一个MyISAM表有三个文件：索引文件、表结构文件、数据文件；\n	采用非聚簇索引，索引文件的数据域存储指向数据文件的指针。辅索引与主索引不用保证唯一性\n	InnoDB：\n	支持ACID事务，支持事务的四种隔离级别；\n	支持行级锁及外键约束：因此可以支持写并发；\n	不存储总行数；\n	一个InnoDB引擎存储一个文件空间（共享表空间，表大小不受操作系统控制，一个表可能分布在多个文件里），也可能多个（设置独立表空间，表大小受操作系统文件大小限制，一般为2G），受操作系统大小限制。\n\n1. InnoDB支持事务，MyISAM不支持，对于InnoDB每一条SQL语言都默认封装成事务，自动提交，这样会影响速度，所以最好把多条SQL语言放在begin和commit之间，组成一个事务； \n\n2. InnoDB支持外键，而MyISAM不支持。对一个包含外键的InnoDB表转为MYISAM会失败； \n\n3. InnoDB是聚集索引，使用B+Tree作为索引结构，数据文件是和（主键）索引绑在一起的（表数据文件本身就是按B+Tree组织的一个索引结构），必须要有主键，通过主键索引效率很高。但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此，主键不应该过大，因为主键太大，其他索引也都会很大。\n MyISAM是非聚集索引，也是使用B+Tree作为索引结构，索引和数据文件是分离的，索引保存的是数据文件的指针。主键索引和辅助索引是独立的。\n4. InnoDB不保存表的具体行数，执行select count(*) from table时需要全表扫描。而MyISAM用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快（注意不能加有任何WHERE条件）；\n5. Innodb不支持全文索引，而MyISAM支持全文索引，在涉及全文索引领域的查询效率上MyISAM速度更快高；PS：5.7以后的InnoDB支持全文索引了\n6. InnoDB支持表、行(默认)级锁，而MyISAM支持表级锁\n7、InnoDB表必须有唯一索引（如主键）（用户没有指定的话会自己找/生产一个隐藏列Row_id来充当默认主键），而Myisam可以没有\n\n如何选择：\n    1. 是否要支持事务，如果要请选择innodb，如果不需要可以考虑MyISAM；\n\n    2. 如果表中绝大多数都只是读查询，可以考虑MyISAM，如果既有读也有写，请使用InnoDB。\n\n5.exprain语句\n\n6、索引覆盖：\n\n7、最左前缀原则：\n	（a，b，c） sql中一定要提供a字段的条件\n	\n	mysql引擎为了更好的利用索引，在查询过程中会动态调整查询字段顺序，以便利用索引\n\n8、InnoDB是如何实现事务的：\n	\n9、B-树和B+树：\n	\n10、Mysql锁的类型\n	基于锁的属性父类：共享锁、排他锁\n	基于锁的粒度分类：行级锁（InnoDB）、表级锁（InnoDn，MyISAM）、页级锁（BDB引擎）、记录锁、间隙锁、临键锁\n	基于锁的状态分类：意向共享锁、意向排他锁。\n	\n	共享锁：又称为读锁，简称S锁：当一个事务为数据加上读锁之后，其他事务只能对该数据加读锁，而不能对数据加写锁，知道所有的读锁释放之后其他事务才能对其进行加持写锁。共享锁的特性主要是为了支持并发的读取数据，读取数据的时候不支持修改，避免出现重复度的问题。\n	\n	排他锁：又称写锁，简称X锁：当一个事务为数据加上写锁时，其他请求不能再为数据加任何锁，直到该锁释放之后，其他事务才能对数据进行加锁。排他锁的目的是在数据修改时，不允许其他人同时修改，也不允许其他人读取。避免出现脏数据和脏读的问题。\n	\n	表锁：指上锁的时候锁住的是整个表，当下一个事务访问该表的时候，必须等前一个事务释放锁了锁才能对表进行访问；\n	特点：粒度大，加锁简单，容易冲突。\n	\n	行锁：指上锁的时候锁住的是表的某一行或多条记录，其他事务访问同一张表时，只有被锁住的记录不能访问，其他的记录可正常访问；\n	特点：粒度小，加锁比表锁麻烦，不容易冲突，相比表锁支持的并发要高。\n	\n	记录锁（Record Lock）：也是行锁的一种，只不过记录锁的范围只是表中的某一条数据，记录锁是说事务在加锁后锁住的只是表的某一条记录。\n	精准条件命中，并且命中的条件字段是唯一索引\n	加了记录锁之后数据可以避免数据在查询时侯被修改的重复读问题，也避免了在修改的事务未提交前被其他事务读取的脏读问题。\n	\n	页锁：锁粒度介于行级锁和表级锁中间的一种锁。\n	特点：开销和加锁时间介于表锁和行锁之间；会出现死锁；锁粒度介于行级锁和表级锁之间，并发度一般。\n	\n	间隙锁：行锁的一种，间隙锁实在事务加锁后其锁住的是表记录的某一个区间，当表的相邻ID之间出现空隙则会形成一个区间，遵循左开有闭原则。\n	\n	临键锁：也是属于行锁的一种，InnoDB的行锁默认算法，总结来说他就是记录锁和间隙锁的组合，临键锁就会把查询出来的记录锁住，同时也会把该范围内的所有间隙空间锁住，再之它会把相邻的下一区间也锁住\n	\n	意向共享锁：当一个事务试图对整个表进行共享锁之前，首先需要获得这个表的意向共享锁。\n	意向排他锁：当一个事务试图对整个表进行排他锁之前，首先需要获得这个表的意向排他锁。\n	（当表中有排他锁的时候，就给这个表添加意向排他锁，让人知道这个表有人在操作，而不需要一行一行遍历去找有没有行加锁，提高加锁效率）\n	\n11、mysql慢查询该如何优化？\n\n12、', '<p>聚簇索引：将数据存与索引放到一块，索引结构的叶子节点保存了行数据<br />\n非聚簇索引：将数据和索引分开存储，索引结构的叶子节点指向了数据对应的位置。<br />\n在innodb中，在聚簇索引之上创建的索引称之为辅助索引，非聚簇索引都是辅助索引，像复合索引、前缀索引、唯一索引。辅助索引存储的是主键值</p>\n<p>什么时候不能进行索引：<br />\n1.使用like关键字进行查询的时候，%出现在左边，无法利用索引<br />\n2.普通语句上使用多列索引：只有查询字段使用了多列索引中的第一个才可以使用（最左原则）<br />\n3.查询语句中使用or关键字：如果or前后两个关键字都是索引，就会使用。如果or前后有一个条件列不是索引，就不能使用索引</p>\n<p>44、索引的基本原理<br />\n索引用来快速查找那些具有特定值的记录。如果没有索引，一般来说执行查询时遍历整张表。<br />\n？？索引的原理：就是把无序的数据变为有序的查询<br />\n1.把创建了索引的列的内容进行排序<br />\n2.对排序结果生成倒排表<br />\n3.在倒排表内容上拼上数据地址链<br />\n4.在查询的时候，先拿到倒排表内容，再取出数据地址链，从而拿到具体数据</p>\n<p>CREATE TABLE [ IF NOT EXISTS ] <code>表名</code>(<br />\n<code>字段名1</code>    列类型 [ 属性 ]  [ 索引 ] [注释] ,<br />\n<code>字段名2</code>   列类型 [ 属性 ]  [ 索引 ] [注释] ,<br />\n… …<br />\n<code>字段名n</code>   列类型 [ 属性 ]  [ 索引 ] [注释]<br />\n)  [ 表类型] [表字符集] [注释] ;</p>\n<p>表类型：ENGINE关键字<br />\n表字符集：CHARSET关键字<br />\nMySQL的数据表的类型：MyISAM、InnoDB 、HEAP、BOB、CSV等<br />\n常用的有：MyISAM、InnoDB<br />\n&quot;CREATE TABLE <code>subject</code> (<br />\n<code>SubjectNo</code> INT(11) NOT NULL COMMENT ‘课程编号’,<br />\n<code>SubjectName</code> VARCHAR(50) DEFAULT NULL COMMENT ‘课程名称’,<br />\n<code>ClassHour</code> INT(4) DEFAULT NULL COMMENT ‘学时’,<br />\n<code>GradeID</code> INT(4) DEFAULT NULL COMMENT ‘年级编号’,<br />\n) ENGINE=INNODB CHARSET=utf8<br />\n&quot;</p>\n<p>alter语句:<br />\n1.修改表名：<br />\nalter table 旧表名 rename as 新表名</p>\n<p>2.添加字段：<br />\nalter table 表名 add 字段名 列类型[属性]</p>\n<p>3.修改字段：<br />\n// 此种修改方式无法修改列名<br />\nALTER TABLE 表名 MODIFY 字段名 列类型[属性]<br />\n// 若要修改列名用change的方式<br />\nALTER TABLE 表名 CHANGE 旧字段名 新字段名 列类型[属性]</p>\n<p>4.删除字段<br />\nALTER TABLE 表名 DROP 字段名</p>\n<p>drop语句<br />\nDROP TABLE [IF EXISTS] 表名</p>\n<p>为什么我们不建立外键：</p>\n<p>有外键关联的时候，从表的信息必须是主表的数据中存在的值，所以有外间关联时需要先插入主表信息。<br />\n在我们正常的开发中，一般使用虚拟外键的思想，这样有助于对表进行管理，提高效率。<br />\n有外键关联时，添加信息需要先添加主表信息，删除信息需要先删除从表的信息，这样使得效率下降</p>\n<p>5.删除约束 DROP 如果创建的约束取名了，那么删除时就需要通过名称删除,如果没有写名称，会有默认名字<br />\nALTER TABLE student DROP FOREIGN KEY fk;<br />\n– 删除唯一约束<br />\nALTER TABLE cars DROP INDEX s_phone;</p>\n<p>truncate语句<br />\n作用：<br />\n用于完全清空表数据，但表结构、索引、约束等不变<br />\n语法：TRUNCATE [TABLE] table_name</p>\n<p>修改密码<br />\n#切换到mysql库<br />\nuse mysql;<br />\n#更新密码<br />\nUPDATE user SET password=password(‘新密码’) WHERE user=‘用户名’ AND host=‘IP地址’;<br />\n#刷新权限<br />\nFLUSH PRIVILEGES;</p>\n<p>#合并常规字符串<br />\nSELECT concat(‘Alian’,’ lover’,’ java’) as ‘字符串合并’;<br />\n±-----------------+<br />\n| 字符串合并       |<br />\n±-----------------+<br />\n| Alian lover java |<br />\n±-----------------+</p>\n<p>#给前面4个员工名字后面都拼一个 lover mysql<br />\nSELECT concat(emp_name,’ lover’,’ mysql’) as ‘字符串合并’ from tb_employee limit 4;<br />\n±----------------------+<br />\n| 字符串合并            |<br />\n±----------------------+<br />\n| 赖晓畅 lover mysql    |<br />\n| 谢又蓝 lover mysql    |<br />\n| 吕芸溪 lover mysql    |<br />\n| 谭淑慧 lover mysql    |<br />\n±----------------------+</p>\n<p>1、索引设计原则（占用空间更小、查询更快）理解几个就行<br />\n1.对于经常查询的字段，建议创建索引。…<br />\n2.索引不是越多越好，一个表如果有大量索引，不仅占用磁盘空间，而且会影响INSERT，DELETE，UPDATE等语句的性能。<br />\n3.避免对经常更新的表进行过多的索引，因为当表中数据更改的同时，索引也会进行调整和更新，十分消耗系统资源。<br />\n4.数据量小的表建议不要创建索引，数据量小时索引不仅起不到明显的优化效果，对于索引结构的维护反而消耗系统资源。<br />\n5.不要在区分度低的字段建立索引。比如性别字段，只有 “男” 和 “女” ，建索引完全起不到优化效果。<br />\n6.对于定义为text。image和bit的数据类型不要建立索引。<br />\n7.在频繁进行跑排列分组（即进行 group by 或 order by操作）的列上建立索引，如果待排序有多个，可以在这些列上建立组合索引。<br />\n8.使用短索引，如果对长字符串进行索引，应该指定一个前缀长度，这样能节省大量索引空间<br />\n9.有外键的表一定要建立索引<br />\n10.尽量拓展索引，不要新建索引（联合索引）<br />\n2.事务的基本特性和隔离级别<br />\nhttps://developer.aliyun.com/article/743691</p>\n<p>2、分库分表<br />\n什么是分库分表：当表中的数据量过大时，整个查询效率就会明显的降低。这时为了提高查询效率，就会将一个表中的数据分散到多个数据库的多个表当中。</p>\n<pre><code>分库分表的方式：分库分表包含分库和分表两个部分，而这两个部分可以统称为数据分片，其目的都是将数据拆分成不同的存储单元。从拆分的角度上，可以分为垂直分片和水平分片。\n\n垂直分片：按照业务将不同的表拆分到不同的库中，又称为纵向分片。他的核心就是转库专用。解决数据库数据文件过大的问题，但是不能从根本上解决查询问题。\n水平分片：就是从数据角度将一个表中的数据拆分到不同的库或表中，这样可以从根本上解决数据量过大造成的查询效率低的问题。\n\n水平分片策略：\n取余/取模：	优点 均匀存放数据，缺点 扩容非常麻烦，数据移动量大\n按照范围分布：比较好扩容，但是数据不够均匀\n按照时间分片：比较容易将热点数据区分开\n按枚举值。。。\n\n阿里提供的开发手册中，建议：预测三年的业务量，一个表中的数据超过500万，或者数据文件超过2G，需要考虑分库分表。\n\n分库分表后，sql语句的执行流程：\n</code></pre>\n<p>3、mysql主从同步原理<br />\nMySQL的主从复制中主要有三个线程： master（bin log dump thread）、slave（I/O thread 、SQL thread） ，Master一条线程和Slave中的两条线程。</p>\n<pre><code>-主节点 binlog日志，主从复制的基础是主库记录数据库的所有变更记录到binlog。binlog 是数据库服务器启动的那一刻起，保存所有修改数据库结构或内容的一个文件。\n-主节点log dump 线程，当 binlog 有变动时，log dump 线程读取其内容并发送给从节点。\n- 从节点 I/O线程接收 binlog 内容，并将其写入到 relay log 文件中。\n- 从节点的SQL 线程读取 relay log 文件内容对数据更新进行重放，最终保证主从数据库的一致性。\n\n注：主从节点使用 bing log 文件 + position 偏移量来定位主从同步的位置，从节点会保存其已接收到的偏移量，如果从节点发生宕机重启，则会自动从 position 的位置发起同步。 \n\n由于mysql默认的复制方式是异步的，主库把日志发送给从库后不关心从库是否已经处理，这样会产生一个问题：假设主库挂了，从库处理失败了，这时候从库升级为主库后，日志就丢失了。由此产生两个概念：\n\n1、全同步复制：主库写入binlog后强制同步日志到从库，所有的从库都执行完成后才返回给客户端，但是很显然这个方式很影响性能\n2、半同步复制：从库写入日志成功后返回ACK确认给主库，主库收到至少一个从库的确认就认为写操作完成。\n</code></pre>\n<p>4、MyISAM、InnoDB的区别？<br />\nMyISAM：<br />\n不支持事务，但是每次查询都是原子的；<br />\n支持表级锁，即每次操作是对整个表加锁；<br />\n存储表的总行数;<br />\n一个MyISAM表有三个文件：索引文件、表结构文件、数据文件；<br />\n采用非聚簇索引，索引文件的数据域存储指向数据文件的指针。辅索引与主索引不用保证唯一性<br />\nInnoDB：<br />\n支持ACID事务，支持事务的四种隔离级别；<br />\n支持行级锁及外键约束：因此可以支持写并发；<br />\n不存储总行数；<br />\n一个InnoDB引擎存储一个文件空间（共享表空间，表大小不受操作系统控制，一个表可能分布在多个文件里），也可能多个（设置独立表空间，表大小受操作系统文件大小限制，一般为2G），受操作系统大小限制。</p>\n<ol>\n<li>\n<p>InnoDB支持事务，MyISAM不支持，对于InnoDB每一条SQL语言都默认封装成事务，自动提交，这样会影响速度，所以最好把多条SQL语言放在begin和commit之间，组成一个事务；</p>\n</li>\n<li>\n<p>InnoDB支持外键，而MyISAM不支持。对一个包含外键的InnoDB表转为MYISAM会失败；</p>\n</li>\n<li>\n<p>InnoDB是聚集索引，使用B+Tree作为索引结构，数据文件是和（主键）索引绑在一起的（表数据文件本身就是按B+Tree组织的一个索引结构），必须要有主键，通过主键索引效率很高。但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此，主键不应该过大，因为主键太大，其他索引也都会很大。<br />\nMyISAM是非聚集索引，也是使用B+Tree作为索引结构，索引和数据文件是分离的，索引保存的是数据文件的指针。主键索引和辅助索引是独立的。</p>\n</li>\n<li>\n<p>InnoDB不保存表的具体行数，执行select count(*) from table时需要全表扫描。而MyISAM用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快（注意不能加有任何WHERE条件）；</p>\n</li>\n<li>\n<p>Innodb不支持全文索引，而MyISAM支持全文索引，在涉及全文索引领域的查询效率上MyISAM速度更快高；PS：5.7以后的InnoDB支持全文索引了</p>\n</li>\n<li>\n<p>InnoDB支持表、行(默认)级锁，而MyISAM支持表级锁<br />\n7、InnoDB表必须有唯一索引（如主键）（用户没有指定的话会自己找/生产一个隐藏列Row_id来充当默认主键），而Myisam可以没有</p>\n</li>\n</ol>\n<p>如何选择：<br />\n1. 是否要支持事务，如果要请选择innodb，如果不需要可以考虑MyISAM；</p>\n<pre><code>2. 如果表中绝大多数都只是读查询，可以考虑MyISAM，如果既有读也有写，请使用InnoDB。\n</code></pre>\n<p>5.exprain语句</p>\n<p>6、索引覆盖：</p>\n<p>7、最左前缀原则：<br />\n（a，b，c） sql中一定要提供a字段的条件</p>\n<pre><code>mysql引擎为了更好的利用索引，在查询过程中会动态调整查询字段顺序，以便利用索引\n</code></pre>\n<p>8、InnoDB是如何实现事务的：</p>\n<p>9、B-树和B+树：</p>\n<p>10、Mysql锁的类型<br />\n基于锁的属性父类：共享锁、排他锁<br />\n基于锁的粒度分类：行级锁（InnoDB）、表级锁（InnoDn，MyISAM）、页级锁（BDB引擎）、记录锁、间隙锁、临键锁<br />\n基于锁的状态分类：意向共享锁、意向排他锁。</p>\n<pre><code>共享锁：又称为读锁，简称S锁：当一个事务为数据加上读锁之后，其他事务只能对该数据加读锁，而不能对数据加写锁，知道所有的读锁释放之后其他事务才能对其进行加持写锁。共享锁的特性主要是为了支持并发的读取数据，读取数据的时候不支持修改，避免出现重复度的问题。\n\n排他锁：又称写锁，简称X锁：当一个事务为数据加上写锁时，其他请求不能再为数据加任何锁，直到该锁释放之后，其他事务才能对数据进行加锁。排他锁的目的是在数据修改时，不允许其他人同时修改，也不允许其他人读取。避免出现脏数据和脏读的问题。\n\n表锁：指上锁的时候锁住的是整个表，当下一个事务访问该表的时候，必须等前一个事务释放锁了锁才能对表进行访问；\n特点：粒度大，加锁简单，容易冲突。\n\n行锁：指上锁的时候锁住的是表的某一行或多条记录，其他事务访问同一张表时，只有被锁住的记录不能访问，其他的记录可正常访问；\n特点：粒度小，加锁比表锁麻烦，不容易冲突，相比表锁支持的并发要高。\n\n记录锁（Record Lock）：也是行锁的一种，只不过记录锁的范围只是表中的某一条数据，记录锁是说事务在加锁后锁住的只是表的某一条记录。\n精准条件命中，并且命中的条件字段是唯一索引\n加了记录锁之后数据可以避免数据在查询时侯被修改的重复读问题，也避免了在修改的事务未提交前被其他事务读取的脏读问题。\n\n页锁：锁粒度介于行级锁和表级锁中间的一种锁。\n特点：开销和加锁时间介于表锁和行锁之间；会出现死锁；锁粒度介于行级锁和表级锁之间，并发度一般。\n\n间隙锁：行锁的一种，间隙锁实在事务加锁后其锁住的是表记录的某一个区间，当表的相邻ID之间出现空隙则会形成一个区间，遵循左开有闭原则。\n\n临键锁：也是属于行锁的一种，InnoDB的行锁默认算法，总结来说他就是记录锁和间隙锁的组合，临键锁就会把查询出来的记录锁住，同时也会把该范围内的所有间隙空间锁住，再之它会把相邻的下一区间也锁住\n\n意向共享锁：当一个事务试图对整个表进行共享锁之前，首先需要获得这个表的意向共享锁。\n意向排他锁：当一个事务试图对整个表进行排他锁之前，首先需要获得这个表的意向排他锁。\n（当表中有排他锁的时候，就给这个表添加意向排他锁，让人知道这个表有人在操作，而不需要一行一行遍历去找有没有行加锁，提高加锁效率）\n</code></pre>\n<p>11、mysql慢查询该如何优化？</p>\n<p>12、</p>\n', 1658820246859005953);
INSERT INTO `ms_article_body` VALUES (1658820406947201028, 'RDB和AOF机制\nRDB：\n在指定的时间间隔内将内存中的数据集快照写入磁盘，实际操作过程是fork一个子进程，先将数据集写入临时文件，写入成功后，再替换之前的文件，用二进制压缩文件。\n优点：\n1.整个Redis数据库将只包含一个文件sump.rbd,方便持久化。\n2.容灾性好，方便备份,可以随时将数据集还原到不同的版本\n3.性能最大化，fork子进程来完成写操作，让主进程继续处理命令，所以是IO最大化。使用单独子进程来进行持久化，主进程不会进行任何IO操作，保证redis的高性能。\n4.相对于数据集大时，比AOF的启动效率更高。\n缺点：\n1.数据安全性低。RDB间隔，redis发生故障，会丢失一部风数据\n2.RDB通过fork子进程来协助完成数据持久化工作，当数据集较大时，可能会导致整个服务器停止几百毫秒，甚至是1秒。\n\nAOF\n以日志的形式记录服务器的每一个写、删除操作，查询操作不会记录，以文本的方式记录。\n\n优点：\n1.数据安全，redis提供了三种同步策略，即每秒同步、每修改同步和不同步。\n2.通过append模式写文件，即使中途服务器宕机也不会破坏以及存在的内容，可以通过redis-check-aof工具解决数据一致性问题。\n3.aof机制的rewrite模式。定期对aof文件进行重写，以达到压缩的目的（同样的命令合并）\n缺点：\n1.aof文件比rdb文件大，且恢复速度慢。\n2.数据集大的时候，比rdb启动效率低。\n3.运行效率没有rdb高。\n\naof文件比rdb更新频率高，优先使用aof还原数据\naof比rdb更安全也更大\nrdb性能比aof好\n如果两个都配了，优先加载aof。\n\n2、redis的过期键的删除策略\n定时过期：创建一个定时器，当key设置有过期时间，且过期时间到达时，由定时器任务立即执行对键的删除操作，cpu压力过大\n惰性过期：只有当访问一个key的时候，才会判断key是否已过期，过期则清除。该策略最大地节省了cpu资源，却对内存非常不友好。极端情况可能出现大量的过期key没有再次被访问，从而不会被清除，占用大量内存\n定期过期：每隔一段时间，会扫描一定数量的数据库的expires字典中的key，清除已经过期地key。改策略是前两者地一个折中方案。通过调整定时扫描地时间间隔和每次扫描的限定耗时，可以在不同情况下使得cpu和内存资源达到最优的平衡效果\nredis中同时使用了惰性过期和定期过期两种策略。\n\n3.redis线程模型，单线程为什么快。\n\n', '<p>RDB和AOF机制<br />\nRDB：<br />\n在指定的时间间隔内将内存中的数据集快照写入磁盘，实际操作过程是fork一个子进程，先将数据集写入临时文件，写入成功后，再替换之前的文件，用二进制压缩文件。<br />\n优点：<br />\n1.整个Redis数据库将只包含一个文件sump.rbd,方便持久化。<br />\n2.容灾性好，方便备份,可以随时将数据集还原到不同的版本<br />\n3.性能最大化，fork子进程来完成写操作，让主进程继续处理命令，所以是IO最大化。使用单独子进程来进行持久化，主进程不会进行任何IO操作，保证redis的高性能。<br />\n4.相对于数据集大时，比AOF的启动效率更高。<br />\n缺点：<br />\n1.数据安全性低。RDB间隔，redis发生故障，会丢失一部风数据<br />\n2.RDB通过fork子进程来协助完成数据持久化工作，当数据集较大时，可能会导致整个服务器停止几百毫秒，甚至是1秒。</p>\n<p>AOF<br />\n以日志的形式记录服务器的每一个写、删除操作，查询操作不会记录，以文本的方式记录。</p>\n<p>优点：<br />\n1.数据安全，redis提供了三种同步策略，即每秒同步、每修改同步和不同步。<br />\n2.通过append模式写文件，即使中途服务器宕机也不会破坏以及存在的内容，可以通过redis-check-aof工具解决数据一致性问题。<br />\n3.aof机制的rewrite模式。定期对aof文件进行重写，以达到压缩的目的（同样的命令合并）<br />\n缺点：<br />\n1.aof文件比rdb文件大，且恢复速度慢。<br />\n2.数据集大的时候，比rdb启动效率低。<br />\n3.运行效率没有rdb高。</p>\n<p>aof文件比rdb更新频率高，优先使用aof还原数据<br />\naof比rdb更安全也更大<br />\nrdb性能比aof好<br />\n如果两个都配了，优先加载aof。</p>\n<p>2、redis的过期键的删除策略<br />\n定时过期：创建一个定时器，当key设置有过期时间，且过期时间到达时，由定时器任务立即执行对键的删除操作，cpu压力过大<br />\n惰性过期：只有当访问一个key的时候，才会判断key是否已过期，过期则清除。该策略最大地节省了cpu资源，却对内存非常不友好。极端情况可能出现大量的过期key没有再次被访问，从而不会被清除，占用大量内存<br />\n定期过期：每隔一段时间，会扫描一定数量的数据库的expires字典中的key，清除已经过期地key。改策略是前两者地一个折中方案。通过调整定时扫描地时间间隔和每次扫描的限定耗时，可以在不同情况下使得cpu和内存资源达到最优的平衡效果<br />\nredis中同时使用了惰性过期和定期过期两种策略。</p>\n<p>3.redis线程模型，单线程为什么快。</p>\n', 1658820406947201026);
INSERT INTO `ms_article_body` VALUES (1658820724778975234, '\n\n## 1.1 springBoot入门程序开发\n- SpringBoot是由Pivotal团队提供的全新框架，其设计目的是用来简化Spring应用的初始搭建以及开发过程  \n\n## springboot优点\n- 创建独立的spring应用\n- 内嵌web服务器\n- 自动starter依赖，简化构建配置\n- 自动配置spring以及第三方功能\n- 提供生产级别的监控、健康检查及外部化配置\n- 无代码生成，无需编写xml\n\n## 缺点\n- 高兴换代快\n- 封装太深，内部原理复杂\n\n## 1.2 快速入门：\n1. 创建新模块，选择Spring INitializr，并配置模块相关基础信息\n2. 选择当前模块的需要使用的技术集\n3. 开发控制器\n4. 运行自动生成的Application类\n## 1.3 最简SpringBoot程序所包含的基础文件\n- poom.xml\n- Application类\n\n## 1.4 Spring程序和SpringBoot程序的对比\n|类/配置文件|spring |springBoot |\n|----|----|-----|\n|pom文件中的坐标|手工添加|勾选添加|\n|web3.0(web.xml)配置类|手工制作|无|\n|Spring/SpringMVC配置类|手工制作|无|\n|控制类|手工制作|手工制作|  \n\n\n## 1.5 小结\n1. 开发SpringBoot程序可以根据向导进行联网快速制作\n2. SpringBoot程序需要基于JDK8进行制作\n3. SpringBoot程序中需要使用何种功能通过勾选选择技术\n4. 运行SpringBoot程序通过运行Application程序路口进行\n\n**基于idea开发SpringBoot程序需要确保联网且能够加载到程序框架结构**\n\n\n## 2.1 基于SpringBoot官网创建项目\n地址：<https://start.spring.io/>,得到压缩文件，得到项目。\n\n## 2.2 小结\n1. 打开SpingBoot官网，选择Quickstart Your Project\n2. 创建工程，并保存项目\n3. 解压项目，通过idea导入项目  \n\n**spring官网不是国内网站，慢**\n\n\n## 3.1 基于阿里云官网创建项目\n地址<https://start.aliyun.com>，更改项目创建路径\n1. 选择start来源为自定义的URL\n2. 输入阿里云start地址\n3. 创建项目  \n\n## 4.1 没网怎么整\n创建maven工程--》 手工导入项目（手工导入坐标）（继承，依赖）--》手工制作引导类（Application）\n1. 创建普通的maven工程\n2. 继承spring-boot-starter-parent\n3. 添加依赖spring-boot-starter-web\n4. 制作引导类Application  \n\n## 5.1 隐藏文件和文件夹\n在idea的setting里的File types中的ignore里添加隐藏的文件就行  \n\n## 6.1springBoot简介\nSpringBoot是由Pivotal团队提供的全新框架，其设计目的是用来简化Spring应用的初始搭建以及开发过程   \nspring程序的缺点\n- 依赖设置繁琐\n- 配置繁琐  \nspringboot程序优点\n- 起步依赖（简化依赖配置）\n- 自动配置（简化常用工程相关配置）\n- 辅助功能（内置服务器，...）  ', '<h2><a id=\"11_springBoot_2\"></a>1.1 springBoot入门程序开发</h2>\n<ul>\n<li>SpringBoot是由Pivotal团队提供的全新框架，其设计目的是用来简化Spring应用的初始搭建以及开发过程</li>\n</ul>\n<h2><a id=\"springboot_5\"></a>springboot优点</h2>\n<ul>\n<li>创建独立的spring应用</li>\n<li>内嵌web服务器</li>\n<li>自动starter依赖，简化构建配置</li>\n<li>自动配置spring以及第三方功能</li>\n<li>提供生产级别的监控、健康检查及外部化配置</li>\n<li>无代码生成，无需编写xml</li>\n</ul>\n<h2><a id=\"_13\"></a>缺点</h2>\n<ul>\n<li>高兴换代快</li>\n<li>封装太深，内部原理复杂</li>\n</ul>\n<h2><a id=\"12__17\"></a>1.2 快速入门：</h2>\n<ol>\n<li>创建新模块，选择Spring INitializr，并配置模块相关基础信息</li>\n<li>选择当前模块的需要使用的技术集</li>\n<li>开发控制器</li>\n<li>运行自动生成的Application类</li>\n</ol>\n<h2><a id=\"13_SpringBoot_22\"></a>1.3 最简SpringBoot程序所包含的基础文件</h2>\n<ul>\n<li>poom.xml</li>\n<li>Application类</li>\n</ul>\n<h2><a id=\"14_SpringSpringBoot_26\"></a>1.4 Spring程序和SpringBoot程序的对比</h2>\n<table>\n<thead>\n<tr>\n<th>类/配置文件</th>\n<th>spring</th>\n<th>springBoot</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>pom文件中的坐标</td>\n<td>手工添加</td>\n<td>勾选添加</td>\n</tr>\n<tr>\n<td>web3.0(web.xml)配置类</td>\n<td>手工制作</td>\n<td>无</td>\n</tr>\n<tr>\n<td>Spring/SpringMVC配置类</td>\n<td>手工制作</td>\n<td>无</td>\n</tr>\n<tr>\n<td>控制类</td>\n<td>手工制作</td>\n<td>手工制作</td>\n</tr>\n</tbody>\n</table>\n<h2><a id=\"15__35\"></a>1.5 小结</h2>\n<ol>\n<li>开发SpringBoot程序可以根据向导进行联网快速制作</li>\n<li>SpringBoot程序需要基于JDK8进行制作</li>\n<li>SpringBoot程序中需要使用何种功能通过勾选选择技术</li>\n<li>运行SpringBoot程序通过运行Application程序路口进行</li>\n</ol>\n<p><strong>基于idea开发SpringBoot程序需要确保联网且能够加载到程序框架结构</strong></p>\n<h2><a id=\"21_SpringBoot_44\"></a>2.1 基于SpringBoot官网创建项目</h2>\n<p>地址：<a href=\"https://start.spring.io/\" target=\"_blank\">https://start.spring.io/</a>,得到压缩文件，得到项目。</p>\n<h2><a id=\"22__47\"></a>2.2 小结</h2>\n<ol>\n<li>打开SpingBoot官网，选择Quickstart Your Project</li>\n<li>创建工程，并保存项目</li>\n<li>解压项目，通过idea导入项目</li>\n</ol>\n<p><strong>spring官网不是国内网站，慢</strong></p>\n<h2><a id=\"31__55\"></a>3.1 基于阿里云官网创建项目</h2>\n<p>地址<a href=\"https://start.aliyun.com\" target=\"_blank\">https://start.aliyun.com</a>，更改项目创建路径</p>\n<ol>\n<li>选择start来源为自定义的URL</li>\n<li>输入阿里云start地址</li>\n<li>创建项目</li>\n</ol>\n<h2><a id=\"41__61\"></a>4.1 没网怎么整</h2>\n<p>创建maven工程–》 手工导入项目（手工导入坐标）（继承，依赖）–》手工制作引导类（Application）</p>\n<ol>\n<li>创建普通的maven工程</li>\n<li>继承spring-boot-starter-parent</li>\n<li>添加依赖spring-boot-starter-web</li>\n<li>制作引导类Application</li>\n</ol>\n<h2><a id=\"51__68\"></a>5.1 隐藏文件和文件夹</h2>\n<p>在idea的setting里的File types中的ignore里添加隐藏的文件就行</p>\n<h2><a id=\"61springBoot_71\"></a>6.1springBoot简介</h2>\n<p>SpringBoot是由Pivotal团队提供的全新框架，其设计目的是用来简化Spring应用的初始搭建以及开发过程<br />\nspring程序的缺点</p>\n<ul>\n<li>依赖设置繁琐</li>\n<li>配置繁琐<br />\nspringboot程序优点</li>\n<li>起步依赖（简化依赖配置）</li>\n<li>自动配置（简化常用工程相关配置）</li>\n<li>辅助功能（内置服务器，…）</li>\n</ul>\n', 1658820724711866370);
INSERT INTO `ms_article_body` VALUES (1658821020133474307, '## 1.1 springboot简介\nSpringBoot是由Pivotal团队提供的全新框架，其设计目的是用来简化Spring应用的初始搭建以及开发过程   \nspring程序的缺点\n- 依赖设置繁琐\n- 配置繁琐  \nspringboot程序优点\n- 起步依赖（简化依赖配置）\n- 自动配置（简化常用工程相关配置）\n- 辅助功能（内置服务器，...） \n\n# 入门案例解析\n\n## 2.1 parent依赖（仅定义未使用）\n1. 定义一系列的常用坐标版本\n2. 定义一系列的常用坐标组合\n3. 直接使用组合  \n```\n<parent>\n	<groupId>org.springframework.boot</groupId>\n	<artifactId>spring-boot-starter-parent</artifactId>\n	<version>2.4.2</version>\n	<relativePath/> <!-- lookup parent from repository -->\n</parent>\n他的父项目：\n  <parent>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-dependencies</artifactId>\n    <version>2.4.2</version>\n  </parent>里的dependence里声明了许多依赖，及版本。\n\n  几乎声明了所有开发中常用的依赖版本号（自动版本仲裁机制）\n\n如何修改版本：\n<properties>\n        <对应jar包版本></对应jar包版本>\n</properties>\n\n```\n\n\n## 2.2小结\n1. 开发springboot程序要继承spring-boot-starter-parent\n2. spring-boot-starter-parent中定义了若干个依赖管理\n3. 继承parent模块可以避免多个依赖使用相同的技术时出现依赖版本冲突\n4. 继承parent的形式也可以采用引入依赖的形式实现效果（继承只能一次）   \n\n## 3.1 starter\n- starter(起步依赖)\n- - springboot中常见的项目名称，定义了当前项目的使用的所有依赖坐标，以达到减少依赖配置的目的  \n- parent\n- - 所有的springboot项目要继承的项目，定义了若干个坐标版本号（依赖管理，而非依赖），以达到减少依赖冲突的目的\n- - spring-boot-starter-parent各版本间存在着诸多坐标版本不同    \n\n- 实际开发\n- - 使用任意坐标时，仅书写GAV中的G和A，V由springboot提供，除非springboot未提供相应的版本\n- - 如果发生坐标错误，再指定version（小心版本冲突）  \n- - 见到*-spring-boot-starter，第三方为我们提供的简化开发的场景启动器。\n- - 所有的场景启动器最底层的依赖就是spring-boot-starte（springboot自动配置的核心依赖）\n\n- 各种配置拥有默认值\n- - 默认配置最终映射到MulitipartProperties\n- - 配置文件俺的值最终会绑定在某个类上，这个类会在容器中创建对象\n\n- 按需加载所有配置项\n- - 非常多的starter\n- - 引入哪些场景这个场景的配置才会自动配置\n- - springboot所有的配置功能都在spring-boot-autoconfiguration\n\n\n## 3.2小结\n1. 开发springboot程序需要导入坐标时通常导入对应的starter\n2. 每个不同的starter根据功能不同，通常包含多个依赖坐标\n3. 使用starter可以实现快速配置的效果达到简化配置的目的  \n（starter和parent解决的是配置问题）\n\n## 4.1引导类（运行程序靠谁）\n启动方式：SpringApplication.run(Object.clss)解析，这就是启动spring容器，bean加载到里面。\n```\nConfigurableApplicationContext ctx = SpringApplication.run(SpringQuickstartApplication.class, args);\n        BookController bean = ctx.getBean(BookController.class);\n        System.out.println(bean);\n```  \n@SpringBootApplication里的@ComponentScan扫描当前类所在包及其子包的bean （SpringBootApplication程序的入口，加载bean）   \n\nspringboot的引导类是boot工程的执行入口，运行main方法就可以启动项目（**未启动服务器**）   \nspringboot工程运行后初始化spring容器，扫描引导类所在的包加载bena   \n## 4.2小结\n1. springboot工程提供引导类用来启动程序\n2. springboot工程启动后创建并初始化spring容器   \n\n## 5.1内嵌Tomcat(tomcat-embed-core)\n可以在以来中去掉tomcat服务器，再导入其他的服务器依赖\n- Jetty比Tomcat更轻量级，可拓展性更强（相比于tomcat），谷歌搜索引擎（GAE）已经全面切换为Jetty  \n内置服务器有：\n- tomcat（默认）：apache出品，应用面广，负载若干较重的组件\n- jetty：更轻量级，负载运不及tomcat\n- undertow：负载性能勉强跑赢tomcat   \n## 5.2小结\n1. 内嵌的tomcat服务器是springboot辅助功能之一\n2. 内嵌tomcat工作原理是将tomcat服务器作为对象运行，并将该对象交给spring容器管理\n3. 变更内嵌服务器思想市区除现有的服务器，添加全新的服务器。  \n\n\n', '<h2><a id=\"11_springboot_0\"></a>1.1 springboot简介</h2>\n<p>SpringBoot是由Pivotal团队提供的全新框架，其设计目的是用来简化Spring应用的初始搭建以及开发过程<br />\nspring程序的缺点</p>\n<ul>\n<li>依赖设置繁琐</li>\n<li>配置繁琐<br />\nspringboot程序优点</li>\n<li>起步依赖（简化依赖配置）</li>\n<li>自动配置（简化常用工程相关配置）</li>\n<li>辅助功能（内置服务器，…）</li>\n</ul>\n<h1><a id=\"_10\"></a>入门案例解析</h1>\n<h2><a id=\"21_parent_12\"></a>2.1 parent依赖（仅定义未使用）</h2>\n<ol>\n<li>定义一系列的常用坐标版本</li>\n<li>定义一系列的常用坐标组合</li>\n<li>直接使用组合</li>\n</ol>\n<pre><code class=\"lang-\">&lt;parent&gt;\n	&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n	&lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;\n	&lt;version&gt;2.4.2&lt;/version&gt;\n	&lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;\n&lt;/parent&gt;\n他的父项目：\n  &lt;parent&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt;\n    &lt;version&gt;2.4.2&lt;/version&gt;\n  &lt;/parent&gt;里的dependence里声明了许多依赖，及版本。\n\n  几乎声明了所有开发中常用的依赖版本号（自动版本仲裁机制）\n\n如何修改版本：\n&lt;properties&gt;\n        &lt;对应jar包版本&gt;&lt;/对应jar包版本&gt;\n&lt;/properties&gt;\n\n</code></pre>\n<h2><a id=\"22_40\"></a>2.2小结</h2>\n<ol>\n<li>开发springboot程序要继承spring-boot-starter-parent</li>\n<li>spring-boot-starter-parent中定义了若干个依赖管理</li>\n<li>继承parent模块可以避免多个依赖使用相同的技术时出现依赖版本冲突</li>\n<li>继承parent的形式也可以采用引入依赖的形式实现效果（继承只能一次）</li>\n</ol>\n<h2><a id=\"31_starter_46\"></a>3.1 starter</h2>\n<ul>\n<li>\n<p>starter(起步依赖)</p>\n</li>\n<li>\n<ul>\n<li>springboot中常见的项目名称，定义了当前项目的使用的所有依赖坐标，以达到减少依赖配置的目的</li>\n</ul>\n</li>\n<li>\n<p>parent</p>\n</li>\n<li>\n<ul>\n<li>所有的springboot项目要继承的项目，定义了若干个坐标版本号（依赖管理，而非依赖），以达到减少依赖冲突的目的</li>\n</ul>\n</li>\n<li>\n<ul>\n<li>spring-boot-starter-parent各版本间存在着诸多坐标版本不同</li>\n</ul>\n</li>\n<li>\n<p>实际开发</p>\n</li>\n<li>\n<ul>\n<li>使用任意坐标时，仅书写GAV中的G和A，V由springboot提供，除非springboot未提供相应的版本</li>\n</ul>\n</li>\n<li>\n<ul>\n<li>如果发生坐标错误，再指定version（小心版本冲突）</li>\n</ul>\n</li>\n<li>\n<ul>\n<li>见到*-spring-boot-starter，第三方为我们提供的简化开发的场景启动器。</li>\n</ul>\n</li>\n<li>\n<ul>\n<li>所有的场景启动器最底层的依赖就是spring-boot-starte（springboot自动配置的核心依赖）</li>\n</ul>\n</li>\n<li>\n<p>各种配置拥有默认值</p>\n</li>\n<li>\n<ul>\n<li>默认配置最终映射到MulitipartProperties</li>\n</ul>\n</li>\n<li>\n<ul>\n<li>配置文件俺的值最终会绑定在某个类上，这个类会在容器中创建对象</li>\n</ul>\n</li>\n<li>\n<p>按需加载所有配置项</p>\n</li>\n<li>\n<ul>\n<li>非常多的starter</li>\n</ul>\n</li>\n<li>\n<ul>\n<li>引入哪些场景这个场景的配置才会自动配置</li>\n</ul>\n</li>\n<li>\n<ul>\n<li>springboot所有的配置功能都在spring-boot-autoconfiguration</li>\n</ul>\n</li>\n</ul>\n<h2><a id=\"32_69\"></a>3.2小结</h2>\n<ol>\n<li>开发springboot程序需要导入坐标时通常导入对应的starter</li>\n<li>每个不同的starter根据功能不同，通常包含多个依赖坐标</li>\n<li>使用starter可以实现快速配置的效果达到简化配置的目的<br />\n（starter和parent解决的是配置问题）</li>\n</ol>\n<h2><a id=\"41_75\"></a>4.1引导类（运行程序靠谁）</h2>\n<p>启动方式：SpringApplication.run(Object.clss)解析，这就是启动spring容器，bean加载到里面。</p>\n<pre><code class=\"lang-\">ConfigurableApplicationContext ctx = SpringApplication.run(SpringQuickstartApplication.class, args);\n        BookController bean = ctx.getBean(BookController.class);\n        System.out.println(bean);\n</code></pre>\n<p>@SpringBootApplication里的@ComponentScan扫描当前类所在包及其子包的bean （SpringBootApplication程序的入口，加载bean）</p>\n<p>springboot的引导类是boot工程的执行入口，运行main方法就可以启动项目（<strong>未启动服务器</strong>）<br />\nspringboot工程运行后初始化spring容器，扫描引导类所在的包加载bena</p>\n<h2><a id=\"42_86\"></a>4.2小结</h2>\n<ol>\n<li>springboot工程提供引导类用来启动程序</li>\n<li>springboot工程启动后创建并初始化spring容器</li>\n</ol>\n<h2><a id=\"51Tomcattomcatembedcore_90\"></a>5.1内嵌Tomcat(tomcat-embed-core)</h2>\n<p>可以在以来中去掉tomcat服务器，再导入其他的服务器依赖</p>\n<ul>\n<li>Jetty比Tomcat更轻量级，可拓展性更强（相比于tomcat），谷歌搜索引擎（GAE）已经全面切换为Jetty<br />\n内置服务器有：</li>\n<li>tomcat（默认）：apache出品，应用面广，负载若干较重的组件</li>\n<li>jetty：更轻量级，负载运不及tomcat</li>\n<li>undertow：负载性能勉强跑赢tomcat</li>\n</ul>\n<h2><a id=\"52_97\"></a>5.2小结</h2>\n<ol>\n<li>内嵌的tomcat服务器是springboot辅助功能之一</li>\n<li>内嵌tomcat工作原理是将tomcat服务器作为对象运行，并将该对象交给spring容器管理</li>\n<li>变更内嵌服务器思想市区除现有的服务器，添加全新的服务器。</li>\n</ol>\n', 1658821020066365442);
INSERT INTO `ms_article_body` VALUES (1658821135531360257, '# springboot整合junit\n```\n@SpringBootTest\nclass Springboot4JunitApplicationTests {\n    @Autowired\n    private BookDao bookDao;\n\n    @Test\n    void contextLoads() {\n        bookDao.save();\n    }\n}\n```   \n## 整合junit\n- 名称：@SpringBootTest\n- 类型：测试类注解\n- 位置：测试类定义上方\n- 作用：设置junit加载的springboot启动类\n\n1. 导入测试对应的starter (spring-boot-starter-test)\n2. 测试类使用@SpringBootTest修饰\n3. 使用自动装配的形势添加要测试的对象  \n## @SpringBootTest\n`@SpringBootTest(classes = Springboot4JunitApplication.class)`\n- 相关属性：classes：设置springboot的启动类\n1. 测试类如果存在于引导类所在的包或者子包中无需指定引导类\n2. 测试类如果不存在于引导类所在的包或者子包中需要通过classes属性指定引导类  \n\n## 整合mybatis\n1. 勾选mybatis技术，也就是导入mybatis对应的starter\n2. 数据库连接相关信息转换成配置\n3. 数据库SQL映射需要添加@Mapper被容器意识到（必须）\n\n1. mysql8.X驱动强制要求设置时区\n- 修改url，添加servletTimeZone设定\n- 修改mysql数据库配置  \n2. 驱动类过时，更换为com.mysql.cj.jdbc.Driver\n\n## 整合mybatis-plus\n整合mybatis-plus和整合mybatis区别\n- 导入坐标不同\n- 数据层实现简化\n\n\n## 整合druid\n```\n通用：\n  type:(一般用下面的方法)\n\n专用\nspring:\n  datasource:\n    druid:\n      driver-class-name: com.mysql.cj.jdbc.Driver\n      url: jdbc:mysql://localhost:3306/springboot?serverTimeone=UTC\n      username: root\n      password: root\n```\n1. 整合Druid需要导入对应的starter\n2. 根据Druid提供的配置方式进行配置\n3. 整合任意的第三方技术\n    - 导入对应的starter\n    - 配置对应的设置采用默认配置\n\n## 整合任意的第三方技术\n- 导入对应的starter\n- 配置对应的设置采用默认配置\n\n\n## 整合ssmp\n使用配置方式开启日志，设置日志输出方式为标准输出。  \n\n分页功能：（自己配置，采用的时拦截器的方式）  \n实质，在查询语句后面添加 limit ？，？   \n- 分页操作需要设定分页对象Ipage\n- Ipage中封装了分页操作中的所有数据：\n数据、当前页码值、每页数据总量、最大页码值、数据总量  \n- 分页功能是在mybatisplus的常规操作基础上增强得到，内部是动态的拼写sql语句，因此需要增强对应的功能，使用mybatisplus拦截器实现。   \n\n\n## ssmp业务层开发\n- service层接口定义与数据层接口定义有较大差别，不要混用\n- - servvice：login(String username,String password)\n- - mapper:selectByUserNameAndPassword(String username,String password)    \n**一定要测**\n\n1. 使用通用结口`IService<T>` 快速开发Service  \n2. 使用通用实现类`ServiceImpl<M,T>`快速开发serviceimpl  \n3. 可以在接口的基础上做功能的重载或功能追加\n4. 注意重载时不要覆盖原始操作，避免原始功能丢失   \n\n## ssmp表现层\n\n统一格式：  \n把所有的（boolean、json、json数组）都放在data里，\n但是查询id不存在时返回null，查询过程中抛出异常返回null，所以再加一个flag（true表示查询成功，这时null就是数据。false null就是查询失败）\n- 设计表现层返回结果的模型类，用于后端和前端进行数据格式统一，也称为前后端数据协议\n```\n@Data\npublic class R{\n  private Boolean flag;\n  private Object data;\n}\n```  \n1. 设计统一的返回值结果类型便于前端开发读取数据\n2. 返回的结果类型可以根据需求自行定义，没有固定格式\n3. 返回值结果模型类用于后端与前端进行数据格式的统一，也称为前后端数据协议  \n\n## ssmp页面\n前后端协调联调  \n- 前后端分离结构设计中页面归属前端服务器\n- 单体工程中页面放置再resource目录下的staticmulzhong（建议执行clear）  \n- created钩子函数用于初始化页面发起调用\n- 页面使用axios发送异步请求获取数据后确定前后端是否连通   \n- 将查询数据返回到页面，利用前端数据双向绑定进行数据展示   ', '<h1><a id=\"springbootjunit_0\"></a>springboot整合junit</h1>\n<pre><code class=\"lang-\">@SpringBootTest\nclass Springboot4JunitApplicationTests {\n    @Autowired\n    private BookDao bookDao;\n\n    @Test\n    void contextLoads() {\n        bookDao.save();\n    }\n}\n</code></pre>\n<h2><a id=\"junit_13\"></a>整合junit</h2>\n<ul>\n<li>名称：@SpringBootTest</li>\n<li>类型：测试类注解</li>\n<li>位置：测试类定义上方</li>\n<li>作用：设置junit加载的springboot启动类</li>\n</ul>\n<ol>\n<li>导入测试对应的starter (spring-boot-starter-test)</li>\n<li>测试类使用@SpringBootTest修饰</li>\n<li>使用自动装配的形势添加要测试的对象</li>\n</ol>\n<h2><a id=\"SpringBootTest_22\"></a>@SpringBootTest</h2>\n<p><code>@SpringBootTest(classes = Springboot4JunitApplication.class)</code></p>\n<ul>\n<li>相关属性：classes：设置springboot的启动类</li>\n</ul>\n<ol>\n<li>测试类如果存在于引导类所在的包或者子包中无需指定引导类</li>\n<li>测试类如果不存在于引导类所在的包或者子包中需要通过classes属性指定引导类</li>\n</ol>\n<h2><a id=\"mybatis_28\"></a>整合mybatis</h2>\n<ol>\n<li>\n<p>勾选mybatis技术，也就是导入mybatis对应的starter</p>\n</li>\n<li>\n<p>数据库连接相关信息转换成配置</p>\n</li>\n<li>\n<p>数据库SQL映射需要添加@Mapper被容器意识到（必须）</p>\n</li>\n<li>\n<p>mysql8.X驱动强制要求设置时区</p>\n</li>\n</ol>\n<ul>\n<li>修改url，添加servletTimeZone设定</li>\n<li>修改mysql数据库配置</li>\n</ul>\n<ol start=\"2\">\n<li>驱动类过时，更换为com.mysql.cj.jdbc.Driver</li>\n</ol>\n<h2><a id=\"mybatisplus_38\"></a>整合mybatis-plus</h2>\n<p>整合mybatis-plus和整合mybatis区别</p>\n<ul>\n<li>导入坐标不同</li>\n<li>数据层实现简化</li>\n</ul>\n<h2><a id=\"druid_44\"></a>整合druid</h2>\n<pre><code class=\"lang-\">通用：\n  type:(一般用下面的方法)\n\n专用\nspring:\n  datasource:\n    druid:\n      driver-class-name: com.mysql.cj.jdbc.Driver\n      url: jdbc:mysql://localhost:3306/springboot?serverTimeone=UTC\n      username: root\n      password: root\n</code></pre>\n<ol>\n<li>整合Druid需要导入对应的starter</li>\n<li>根据Druid提供的配置方式进行配置</li>\n<li>整合任意的第三方技术\n<ul>\n<li>导入对应的starter</li>\n<li>配置对应的设置采用默认配置</li>\n</ul>\n</li>\n</ol>\n<h2><a id=\"_64\"></a>整合任意的第三方技术</h2>\n<ul>\n<li>导入对应的starter</li>\n<li>配置对应的设置采用默认配置</li>\n</ul>\n<h2><a id=\"ssmp_69\"></a>整合ssmp</h2>\n<p>使用配置方式开启日志，设置日志输出方式为标准输出。</p>\n<p>分页功能：（自己配置，采用的时拦截器的方式）<br />\n实质，在查询语句后面添加 limit ？，？</p>\n<ul>\n<li>分页操作需要设定分页对象Ipage</li>\n<li>Ipage中封装了分页操作中的所有数据：<br />\n数据、当前页码值、每页数据总量、最大页码值、数据总量</li>\n<li>分页功能是在mybatisplus的常规操作基础上增强得到，内部是动态的拼写sql语句，因此需要增强对应的功能，使用mybatisplus拦截器实现。</li>\n</ul>\n<h2><a id=\"ssmp_80\"></a>ssmp业务层开发</h2>\n<ul>\n<li>service层接口定义与数据层接口定义有较大差别，不要混用</li>\n<li>\n<ul>\n<li>servvice：login(String username,String password)</li>\n</ul>\n</li>\n<li>\n<ul>\n<li>mapper:selectByUserNameAndPassword(String username,String password)<br />\n<strong>一定要测</strong></li>\n</ul>\n</li>\n</ul>\n<ol>\n<li>使用通用结口<code>IService&lt;T&gt;</code> 快速开发Service</li>\n<li>使用通用实现类<code>ServiceImpl&lt;M,T&gt;</code>快速开发serviceimpl</li>\n<li>可以在接口的基础上做功能的重载或功能追加</li>\n<li>注意重载时不要覆盖原始操作，避免原始功能丢失</li>\n</ol>\n<h2><a id=\"ssmp_91\"></a>ssmp表现层</h2>\n<p>统一格式：<br />\n把所有的（boolean、json、json数组）都放在data里，<br />\n但是查询id不存在时返回null，查询过程中抛出异常返回null，所以再加一个flag（true表示查询成功，这时null就是数据。false null就是查询失败）</p>\n<ul>\n<li>设计表现层返回结果的模型类，用于后端和前端进行数据格式统一，也称为前后端数据协议</li>\n</ul>\n<pre><code class=\"lang-\">@Data\npublic class R{\n  private Boolean flag;\n  private Object data;\n}\n</code></pre>\n<ol>\n<li>设计统一的返回值结果类型便于前端开发读取数据</li>\n<li>返回的结果类型可以根据需求自行定义，没有固定格式</li>\n<li>返回值结果模型类用于后端与前端进行数据格式的统一，也称为前后端数据协议</li>\n</ol>\n<h2><a id=\"ssmp_108\"></a>ssmp页面</h2>\n<p>前后端协调联调</p>\n<ul>\n<li>前后端分离结构设计中页面归属前端服务器</li>\n<li>单体工程中页面放置再resource目录下的staticmulzhong（建议执行clear）</li>\n<li>created钩子函数用于初始化页面发起调用</li>\n<li>页面使用axios发送异步请求获取数据后确定前后端是否连通</li>\n<li>将查询数据返回到页面，利用前端数据双向绑定进行数据展示</li>\n</ul>\n', 1658821135468445698);
INSERT INTO `ms_article_body` VALUES (1658822003743899651, '## 1.1 原始jdbc操作（查询数据）\n![原始jdbc操作](图\\原始jdbc操作.png)\n![原始jdbc操作](图\\原始jdbc插入.png)\n## 1.2 原始jdbc操作的分析\n原始jdbc开发存在的问题：  \n1.数据库连接创建、释放频繁造成系统资源浪费从而影响系统性能  \n2.sql语句在代码中硬编码，造成代码不宜维护，实际应用sql变化的可能性较大，sql变动需要改变java代码  \n3.查询操作时，需要手动将结果封装到结果集中。插入操作时，需要手动将实体的数据设置到sql语句的占位符位置  \n应对上述问题给出的解决方案：  \n1.使用数据库连接池初始化连接资源  \n2.将sql语句抽取到xml配置文件中  \n3.使用反射、内省等底层技术，自动将实体与表进行属性与字段的自动映射  \n## 1.3 什么是Mybatis\n- mybatis是一个优秀的基于java的持久层（dao）框架，它内部封装了jdbc，使开发者只需要关注sql语句本身，而不需要花费精力去处理加载驱动、创建连接、创建statement等繁杂的过程。\n- mybatis通过xml或注解的方式将要执行的各种statement配置起来，并通过Java对象和statement中sql的动态参数进行映射生成最终执行的sql语句。  \n- 最后mybatis框架执行sql并将结果映射为Java对象并返回。采用ORM思想解决了实体和数据库映射的问题，对jdbc进行了封装，屏蔽了jdbc api底层访问细节，使我们不用于jdbc api打交道，就完成了对数据库的持久化操作  ', '<h2><a id=\"11_jdbc_0\"></a>1.1 原始jdbc操作（查询数据）</h2>\n<p><img src=\"%E5%9B%BE%5C%E5%8E%9F%E5%A7%8Bjdbc%E6%93%8D%E4%BD%9C.png\" alt=\"原始jdbc操作\" /><br />\n<img src=\"%E5%9B%BE%5C%E5%8E%9F%E5%A7%8Bjdbc%E6%8F%92%E5%85%A5.png\" alt=\"原始jdbc操作\" /></p>\n<h2><a id=\"12_jdbc_3\"></a>1.2 原始jdbc操作的分析</h2>\n<p>原始jdbc开发存在的问题：<br />\n1.数据库连接创建、释放频繁造成系统资源浪费从而影响系统性能<br />\n2.sql语句在代码中硬编码，造成代码不宜维护，实际应用sql变化的可能性较大，sql变动需要改变java代码<br />\n3.查询操作时，需要手动将结果封装到结果集中。插入操作时，需要手动将实体的数据设置到sql语句的占位符位置<br />\n应对上述问题给出的解决方案：<br />\n1.使用数据库连接池初始化连接资源<br />\n2.将sql语句抽取到xml配置文件中<br />\n3.使用反射、内省等底层技术，自动将实体与表进行属性与字段的自动映射</p>\n<h2><a id=\"13_Mybatis_12\"></a>1.3 什么是Mybatis</h2>\n<ul>\n<li>mybatis是一个优秀的基于java的持久层（dao）框架，它内部封装了jdbc，使开发者只需要关注sql语句本身，而不需要花费精力去处理加载驱动、创建连接、创建statement等繁杂的过程。</li>\n<li>mybatis通过xml或注解的方式将要执行的各种statement配置起来，并通过Java对象和statement中sql的动态参数进行映射生成最终执行的sql语句。</li>\n<li>最后mybatis框架执行sql并将结果映射为Java对象并返回。采用ORM思想解决了实体和数据库映射的问题，对jdbc进行了封装，屏蔽了jdbc api底层访问细节，使我们不用于jdbc api打交道，就完成了对数据库的持久化操作</li>\n</ul>\n', 1658822003743899649);
INSERT INTO `ms_article_body` VALUES (1658822244262068227, '## 2.1 MyBatis开发步骤\nMyBatis官网：http://www.mybatis.org/mybatis-3/  \nMyBatis开发步骤：  \n1.添加mybatis的坐标  \n2.创建user数据库  \n3.编写User实体类  \n4.编写映射文件UserMapper.xml  \n5.编写核心文件SqlMapConfig.xml  \n6.编写测试类  \n## 2.2 环境搭建\n编写MyBatis核心文件\n## 2.3 编写测试类 \n```\npublic void test() throws IOException {\n        //获得核心配置文集\n        InputStream resourceAsFile = Resources.getResourceAsStream(\"sqlMapConfig.xml\");\n        //获得session工厂对象\n        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(resourceAsFile);\n        //获得session绘画对象\n        SqlSession sqlSession = sqlSessionFactory.openSession();\n        //执行操作 参数：namespace+id\n        List<User> userList = sqlSession.selectList(\"userMapper.findAll\");\n        //打印数据\n        System.out.println(userList);\n        //释放资源\n        sqlSession.close();\n    }\n```\n## 2.4 知识小结\n', '<h2><a id=\"21_MyBatis_0\"></a>2.1 MyBatis开发步骤</h2>\n<p>MyBatis官网：http://www.mybatis.org/mybatis-3/<br />\nMyBatis开发步骤：<br />\n1.添加mybatis的坐标<br />\n2.创建user数据库<br />\n3.编写User实体类<br />\n4.编写映射文件UserMapper.xml<br />\n5.编写核心文件SqlMapConfig.xml<br />\n6.编写测试类</p>\n<h2><a id=\"22__9\"></a>2.2 环境搭建</h2>\n<p>编写MyBatis核心文件</p>\n<h2><a id=\"23__11\"></a>2.3 编写测试类</h2>\n<pre><code class=\"lang-\">public void test() throws IOException {\n        //获得核心配置文集\n        InputStream resourceAsFile = Resources.getResourceAsStream(&quot;sqlMapConfig.xml&quot;);\n        //获得session工厂对象\n        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(resourceAsFile);\n        //获得session绘画对象\n        SqlSession sqlSession = sqlSessionFactory.openSession();\n        //执行操作 参数：namespace+id\n        List&lt;User&gt; userList = sqlSession.selectList(&quot;userMapper.findAll&quot;);\n        //打印数据\n        System.out.println(userList);\n        //释放资源\n        sqlSession.close();\n    }\n</code></pre>\n<h2><a id=\"24__28\"></a>2.4 知识小结</h2>\n', 1658822244211736578);
INSERT INTO `ms_article_body` VALUES (1658822614287761411, 'tar -cvf 文件名称.tar 目录 ----打包\ntar -zcvf 文件名称.tar.gz 目录 ---打包压缩\ntar -xvf test.tar ----解压包文件\ntar -zxvf test.tar.gz （-C  放到哪） ----解压压缩包\n\n\nfind:在指定目录下查找文件\nfind dirName -option fileName 在dirName目录及子目录下找文件filename  \n\ngrep:从指定文件中查找指定的文本内容\ngrep word fileName  查找fileName文件中出现的word字符串的位置', '<p>tar -cvf 文件名称.tar 目录 ----打包<br />\ntar -zcvf 文件名称.tar.gz 目录 —打包压缩<br />\ntar -xvf test.tar ----解压包文件<br />\ntar -zxvf test.tar.gz （-C  放到哪） ----解压压缩包</p>\n<p>find:在指定目录下查找文件<br />\nfind dirName -option fileName 在dirName目录及子目录下找文件filename</p>\n<p>grep:从指定文件中查找指定的文本内容<br />\ngrep word fileName  查找fileName文件中出现的word字符串的位置</p>\n', 1658822614287761409);
INSERT INTO `ms_article_body` VALUES (1658822869255307267, '## 一、EL和JSTL作用：  \n简化Jsp文件上java代码开发步骤  \n## 二、jsp主要开发任务：  \n将域对象中数据读取并写入到响应体  \n## 三、jsp文件上面使用java命令，将域对象中数据读取并写入到响应体开发步骤。  \n```\n<%\n    String value=(String)request.getAttribute(\"key\");\n    //out.write(value)\n%>\n<%=value%>\n1.从域对象中得取数据\n2.对得到的数据进行类型转换\n3.将最终的结果写入到响应体中\n```  \n## 四、EL工具包：\n1. 是一个由java开发的工具包\n2. 专门用于从域中对象读取数据并写入响应体开发任务\n3. 语法格式：路径格式。\n4. EL工具包自动存在于Tomcat的lib（el-api.jar）。开发时可以直接使用。  \n## 五、EL的标准格式：（${域对象别名.关键字}）\n${域对象别名.关键字}：到指定域对象中读取对应的关键字的内容，并自动将内容写入到响应体中      \n## 六、 jsp中的域对象：\n1. application：全局域对象\n2. session:会话作用域对象\n3. request:请求作用域对象\n4. pageContext：当前页作用域对象(用来初始化jsp的其他域对象)  \n## 七、EL域对象的别名：\n1. application：applicationScope\n2. session:sessionScope\n3. request:requestScope\n4. pageContext：pageScope\n5. cookie\n## 八、EL表达式将高级域对象属性写入到响应体\n- ${域对象别名.关键字.属性名}（属性名和实体的一样）\n- **EL表达式使用了反射机制，通过调用当前属性的对应的get获取属性值**  \n## 九、EL表达式简化版：\n- ${关键字}：可以省略域对象别名\n- 【简化版的工作原理】：首先到{pageContext}定位关键字，如果有读取输出并结束执行。没有找到到{request}定位关键字，以此类推。都没，返回null。\n- - 弊端：\n- - 1. 增加运行时间。\n- - 2. 定位错误。\n- 使用场景：专门为pageContext读取数据并写入响应体做准备。\n## 十、EL表达式支持的运算：\n1. 数学运算\n2. 关系运算：> < >= <= !=（gt lt ge le eq !=）\n3. 逻辑运算：&& || ！\n```\n<%\n    request.setAttribute(\"key1\", \"100\");\n    request.setAttribute(\"key2\", \"200\");\n%>\nel表达式数学运算${requestScope.key1+requestScope.key2}\nel关系运算：${requestScope.key1>requestScope.key2}\n```\n## 十一、El表达式其他内置对象\n1. param：\n- 使用：${param.请求参数名}\n- 作用：读取请求协议包参数内容\n- 代替：request.getParameter(\"请求参数名称\")\n```\n<%-- http://localhost:8080/index1.jsp?uname=lisi&password=123 --%>\n登录名：${param.uname}\n密码：${param.password}\n```\n2. paramValues:(el没有动态输出)\n- 作用：读取请求协议包中关联多个值的请求参数，将将请求参数保存到数组\n- 使用：${paramValues.请求参数名}\n- 代替：String arr[]=request.getParameterValues(\"请求参数名称\")\n```\n<%-- http://localhost:8080/index1.jsp?emp=10&emp=20  --%>\n第一个值：${paramValues.emp[0]}\n第二个值：${paramValues.emp[0]}\n```\n3. initParam：(将web.xml文件的值写入)\n- 代替：String value=application.getInitParameter(\" \")\n- 使用：${initParam.共享数据名}\n## 十二、相对路径与绝对路径\n## 十三、El表达式缺陷\n1. 只能读取域对象数据，不能向域对象中写入数据和更改数据\n2. 不支持控制语句（if、while）无法确保jsp文件中所有的java命令都被替换调。', '<h2><a id=\"ELJSTL_0\"></a>一、EL和JSTL作用：</h2>\n<p>简化Jsp文件上java代码开发步骤</p>\n<h2><a id=\"jsp_2\"></a>二、jsp主要开发任务：</h2>\n<p>将域对象中数据读取并写入到响应体</p>\n<h2><a id=\"jspjava_4\"></a>三、jsp文件上面使用java命令，将域对象中数据读取并写入到响应体开发步骤。</h2>\n<pre><code class=\"lang-\">&lt;%\n    String value=(String)request.getAttribute(&quot;key&quot;);\n    //out.write(value)\n%&gt;\n&lt;%=value%&gt;\n1.从域对象中得取数据\n2.对得到的数据进行类型转换\n3.将最终的结果写入到响应体中\n</code></pre>\n<h2><a id=\"EL_15\"></a>四、EL工具包：</h2>\n<ol>\n<li>是一个由java开发的工具包</li>\n<li>专门用于从域中对象读取数据并写入响应体开发任务</li>\n<li>语法格式：路径格式。</li>\n<li>EL工具包自动存在于Tomcat的lib（el-api.jar）。开发时可以直接使用。</li>\n</ol>\n<h2><a id=\"EL_20\"></a>五、EL的标准格式：（${域对象别名.关键字}）</h2>\n<p>${域对象别名.关键字}：到指定域对象中读取对应的关键字的内容，并自动将内容写入到响应体中</p>\n<h2><a id=\"_jsp_22\"></a>六、 jsp中的域对象：</h2>\n<ol>\n<li>application：全局域对象</li>\n<li>session:会话作用域对象</li>\n<li>request:请求作用域对象</li>\n<li>pageContext：当前页作用域对象(用来初始化jsp的其他域对象)</li>\n</ol>\n<h2><a id=\"EL_27\"></a>七、EL域对象的别名：</h2>\n<ol>\n<li>application：applicationScope</li>\n<li>session:sessionScope</li>\n<li>request:requestScope</li>\n<li>pageContext：pageScope</li>\n<li>cookie</li>\n</ol>\n<h2><a id=\"EL_33\"></a>八、EL表达式将高级域对象属性写入到响应体</h2>\n<ul>\n<li>${域对象别名.关键字.属性名}（属性名和实体的一样）</li>\n<li><strong>EL表达式使用了反射机制，通过调用当前属性的对应的get获取属性值</strong></li>\n</ul>\n<h2><a id=\"EL_36\"></a>九、EL表达式简化版：</h2>\n<ul>\n<li>${关键字}：可以省略域对象别名</li>\n<li>【简化版的工作原理】：首先到{pageContext}定位关键字，如果有读取输出并结束执行。没有找到到{request}定位关键字，以此类推。都没，返回null。</li>\n<li>\n<ul>\n<li>弊端：</li>\n</ul>\n</li>\n<li>\n<ul>\n<li>\n<ol>\n<li>增加运行时间。</li>\n</ol>\n</li>\n</ul>\n</li>\n<li>\n<ul>\n<li>\n<ol start=\"2\">\n<li>定位错误。</li>\n</ol>\n</li>\n</ul>\n</li>\n<li>使用场景：专门为pageContext读取数据并写入响应体做准备。</li>\n</ul>\n<h2><a id=\"EL_43\"></a>十、EL表达式支持的运算：</h2>\n<ol>\n<li>数学运算</li>\n<li>关系运算：&gt; &lt; &gt;= &lt;= !=（gt lt ge le eq !=）</li>\n<li>逻辑运算：&amp;&amp; || ！</li>\n</ol>\n<pre><code class=\"lang-\">&lt;%\n    request.setAttribute(&quot;key1&quot;, &quot;100&quot;);\n    request.setAttribute(&quot;key2&quot;, &quot;200&quot;);\n%&gt;\nel表达式数学运算${requestScope.key1+requestScope.key2}\nel关系运算：${requestScope.key1&gt;requestScope.key2}\n</code></pre>\n<h2><a id=\"El_55\"></a>十一、El表达式其他内置对象</h2>\n<ol>\n<li>param：</li>\n</ol>\n<ul>\n<li>使用：${param.请求参数名}</li>\n<li>作用：读取请求协议包参数内容</li>\n<li>代替：request.getParameter(“请求参数名称”)</li>\n</ul>\n<pre><code class=\"lang-\">&lt;%-- http://localhost:8080/index1.jsp?uname=lisi&amp;password=123 --%&gt;\n登录名：${param.uname}\n密码：${param.password}\n</code></pre>\n<ol start=\"2\">\n<li>paramValues:(el没有动态输出)</li>\n</ol>\n<ul>\n<li>作用：读取请求协议包中关联多个值的请求参数，将将请求参数保存到数组</li>\n<li>使用：${paramValues.请求参数名}</li>\n<li>代替：String arr[]=request.getParameterValues(“请求参数名称”)</li>\n</ul>\n<pre><code class=\"lang-\">&lt;%-- http://localhost:8080/index1.jsp?emp=10&amp;emp=20  --%&gt;\n第一个值：${paramValues.emp[0]}\n第二个值：${paramValues.emp[0]}\n</code></pre>\n<ol start=\"3\">\n<li>initParam：(将web.xml文件的值写入)</li>\n</ol>\n<ul>\n<li>代替：String value=application.getInitParameter(&quot; &quot;)</li>\n<li>使用：${initParam.共享数据名}</li>\n</ul>\n<h2><a id=\"_77\"></a>十二、相对路径与绝对路径</h2>\n<h2><a id=\"El_78\"></a>十三、El表达式缺陷</h2>\n<ol>\n<li>只能读取域对象数据，不能向域对象中写入数据和更改数据</li>\n<li>不支持控制语句（if、while）无法确保jsp文件中所有的java命令都被替换调。</li>\n</ol>\n', 1658822869255307265);
INSERT INTO `ms_article_body` VALUES (1658822996560822274, '## 一、介绍\n1. JSP Standrad Tag Lib：Jsp中标准的标签工具类库。  \n2. 是sun公司提供\n3. 组成：  \n1）.核心标签：java在jsp上基本功能进行封装（if、while）  \n2）sql标签：jdbc在jsp上使用功能  \n3）xml标签：Dom4j在jsp使用功能  \n4）Format标签：jsp文件格式转换  \n## 二、配置：\n1. 导入依赖jar：\n2. 在jsp文件引入jstl中core包依赖约束<%@taglib prefix=\"c\" uri=\"http://java.sun.com/jsp/jstl/core\" %>\n## 三、标签使用\n1. `<c:set>`  \n作用：在jsp文件上设置域对象共享数据\n使用：`<c:set scope=\"session\" var=\"key\" value=\"10\">`  \n代替：session.setAttribute(\"key\",\"10\")  \n属性：  \nscope：指定操作域对象的别名scope=\"session/application/request/page\"  \nvar:存入的共享数据\n```\n<c:set scope=\"application\" var=\"sid\" value=\"10\"></c:set>\n<c:set scope=\"session\" var=\"sname\" value=\"lisi\"></c:set>\n<c:set scope=\"request\" var=\"age\" value=\"10\"></c:set>\n<c:set scope=\"page\" var=\"home\" value=\"ganzhou\"></c:set>\n${applicationScope.sid} <br>\n${sessionScope.sname}<br>\n${requestScope.age}<br>\n${pageScope.home}\n```\njstl和el混合使用：先执行el表达式，在写入表达式，在执行jstl\n```\n<c:set scope=\"request\" var=\"age1\" value=\"10\"></c:set>\n<c:set scope=\"request\" var=\"age1\" value=\"${requestScope.age+2}\"></c:set>\n```\n2. `<c:if>`:  \n作用：在jsp页面上控制哪些内容可以写入到响应体  \n使用：`<c:if test=\"通过el表达式进行判断\">内容</c:if>`\n3. `<c:choose>`  \n作用：在jsp中实现多分支选择判断，决定哪些内容可以写入到响应体  \n使用:\n```\n<c:choose>  \n    <c:when test=\"通过el表达式进行判断\">内容1</c:when>\n    <c:when test=\"通过el表达式进行判断\">内容2</c:when>\n     <c:otherwise>内容3</c:otherwise>\n</c:choose>\n```  \n4. `<c:forEach>`   \n作用：循环遍历  \n使用方式1：（循环变量被保存在【pageContext】）\n```\n<c:forEach var=\"声明循环变量名称\" begin=\"初始化循环变量\" end=\"最大值\" step=\"循环变量递增值，默认为+1\">\n<option>第${pageScope.i}页</option>\n</c:forEach>\n```  \n\n使用方式2：\n\n```\nrequest.setAttibute(\"BookList\",list);\n<c:forEach items=\"${BookList}\" var=\"声明循环变量\">\n    ${list.name}\n    ${list.age}\n</c:forEach>\n```\n遍历Map：  \n遍历map集合时，每次从map集合中得到一个【键值对】，【键值对】交给循环变量。循环变量.key获得【键值对】的关键字名字，循环变量.value获得【键值对】的值', '<h2><a id=\"_0\"></a>一、介绍</h2>\n<ol>\n<li>JSP Standrad Tag Lib：Jsp中标准的标签工具类库。</li>\n<li>是sun公司提供</li>\n<li>组成：<br />\n1）.核心标签：java在jsp上基本功能进行封装（if、while）<br />\n2）sql标签：jdbc在jsp上使用功能<br />\n3）xml标签：Dom4j在jsp使用功能<br />\n4）Format标签：jsp文件格式转换</li>\n</ol>\n<h2><a id=\"_8\"></a>二、配置：</h2>\n<ol>\n<li>导入依赖jar：</li>\n<li>在jsp文件引入jstl中core包依赖约束&lt;%@taglib prefix=“c” uri=“http://java.sun.com/jsp/jstl/core” %&gt;</li>\n</ol>\n<h2><a id=\"_11\"></a>三、标签使用</h2>\n<ol>\n<li><code>&lt;c:set&gt;</code><br />\n作用：在jsp文件上设置域对象共享数据<br />\n使用：<code>&lt;c:set scope=&quot;session&quot; var=&quot;key&quot; value=&quot;10&quot;&gt;</code><br />\n代替：session.setAttribute(“key”,“10”)<br />\n属性：<br />\nscope：指定操作域对象的别名scope=“session/application/request/page”<br />\nvar:存入的共享数据</li>\n</ol>\n<pre><code class=\"lang-\">&lt;c:set scope=&quot;application&quot; var=&quot;sid&quot; value=&quot;10&quot;&gt;&lt;/c:set&gt;\n&lt;c:set scope=&quot;session&quot; var=&quot;sname&quot; value=&quot;lisi&quot;&gt;&lt;/c:set&gt;\n&lt;c:set scope=&quot;request&quot; var=&quot;age&quot; value=&quot;10&quot;&gt;&lt;/c:set&gt;\n&lt;c:set scope=&quot;page&quot; var=&quot;home&quot; value=&quot;ganzhou&quot;&gt;&lt;/c:set&gt;\n${applicationScope.sid} &lt;br&gt;\n${sessionScope.sname}&lt;br&gt;\n${requestScope.age}&lt;br&gt;\n${pageScope.home}\n</code></pre>\n<p>jstl和el混合使用：先执行el表达式，在写入表达式，在执行jstl</p>\n<pre><code class=\"lang-\">&lt;c:set scope=&quot;request&quot; var=&quot;age1&quot; value=&quot;10&quot;&gt;&lt;/c:set&gt;\n&lt;c:set scope=&quot;request&quot; var=&quot;age1&quot; value=&quot;${requestScope.age+2}&quot;&gt;&lt;/c:set&gt;\n</code></pre>\n<ol start=\"2\">\n<li><code>&lt;c:if&gt;</code>:<br />\n作用：在jsp页面上控制哪些内容可以写入到响应体<br />\n使用：<code>&lt;c:if test=&quot;通过el表达式进行判断&quot;&gt;内容&lt;/c:if&gt;</code></li>\n<li><code>&lt;c:choose&gt;</code><br />\n作用：在jsp中实现多分支选择判断，决定哪些内容可以写入到响应体<br />\n使用:</li>\n</ol>\n<pre><code class=\"lang-\">&lt;c:choose&gt;  \n    &lt;c:when test=&quot;通过el表达式进行判断&quot;&gt;内容1&lt;/c:when&gt;\n    &lt;c:when test=&quot;通过el表达式进行判断&quot;&gt;内容2&lt;/c:when&gt;\n     &lt;c:otherwise&gt;内容3&lt;/c:otherwise&gt;\n&lt;/c:choose&gt;\n</code></pre>\n<ol start=\"4\">\n<li><code>&lt;c:forEach&gt;</code><br />\n作用：循环遍历<br />\n使用方式1：（循环变量被保存在【pageContext】）</li>\n</ol>\n<pre><code class=\"lang-\">&lt;c:forEach var=&quot;声明循环变量名称&quot; begin=&quot;初始化循环变量&quot; end=&quot;最大值&quot; step=&quot;循环变量递增值，默认为+1&quot;&gt;\n&lt;option&gt;第${pageScope.i}页&lt;/option&gt;\n&lt;/c:forEach&gt;\n</code></pre>\n<p>使用方式2：</p>\n<pre><code class=\"lang-\">request.setAttibute(&quot;BookList&quot;,list);\n&lt;c:forEach items=&quot;${BookList}&quot; var=&quot;声明循环变量&quot;&gt;\n    ${list.name}\n    ${list.age}\n&lt;/c:forEach&gt;\n</code></pre>\n<p>遍历Map：<br />\n遍历map集合时，每次从map集合中得到一个【键值对】，【键值对】交给循环变量。循环变量.key获得【键值对】的关键字名字，循环变量.value获得【键值对】的值</p>\n', 1658822996493713410);
INSERT INTO `ms_article_body` VALUES (1658823734150152194, '# NoSql(非结构化，键值型) \n键值型、文本型、图\n## SQL和NoSQL\n### SQL：\n结构化、关联的、SQL查询、ACID\n- 使用场景：数据结构固定；相关业务对数据安全性、一致性要求较高（ 磁盘存储）\n### NoSQl：\n1. 非结构化\n- 1.键值类型（Redis）。\n- 2、文档类型（MongDB）。\n- 3、列表型（Hbase）。\n- 4、Group型（Neo4j）。   \n2. 无关联的\n3. 非SQL（语法不统一）\n4. 事务：BASE（要么没有事务，要么不完全保证ACID）\n- 使用场景：数据结构不固定；对一致性、安全性要求不高；对性能要求（内存存储）  \n![SQL和NoSQL.png](http://ruizmypmv.hn-bkt.clouddn.com/82824c55-a0fb-4658-a3ff-09edd5c27e76.png)\n# 认识Redis（Remote Dictioary Server）\nRedis诞生于2009年，全称是Remote Dictioary Server，远程词典服务器，是一个基于内存的键值型NoSql数据库。\n## 特征\n- 键值（key-value）型，value支持多种不同数据结构，功能丰富\n- 单线程，每个命令具备原子性\n- 低延迟，速度快（基于内存**核心**，IO多路复用、良好的编码）。\n- 支持数据持久化  \n- 支持主从集群、分片集群（数据拆分到不同节点）  \n- 支持多语言客户端  \n# 安装。看说明', '<h1><a id=\"NoSql_0\"></a>NoSql(非结构化，键值型)</h1>\n<p>键值型、文本型、图</p>\n<h2><a id=\"SQLNoSQL_2\"></a>SQL和NoSQL</h2>\n<h3><a id=\"SQL_3\"></a>SQL：</h3>\n<p>结构化、关联的、SQL查询、ACID</p>\n<ul>\n<li>使用场景：数据结构固定；相关业务对数据安全性、一致性要求较高（ 磁盘存储）</li>\n</ul>\n<h3><a id=\"NoSQl_6\"></a>NoSQl：</h3>\n<ol>\n<li>非结构化</li>\n</ol>\n<ul>\n<li>1.键值类型（Redis）。</li>\n<li>2、文档类型（MongDB）。</li>\n<li>3、列表型（Hbase）。</li>\n<li>4、Group型（Neo4j）。</li>\n</ul>\n<ol start=\"2\">\n<li>无关联的</li>\n<li>非SQL（语法不统一）</li>\n<li>事务：BASE（要么没有事务，要么不完全保证ACID）</li>\n</ol>\n<ul>\n<li>使用场景：数据结构不固定；对一致性、安全性要求不高；对性能要求（内存存储）<br />\n<img src=\"http://ruizmypmv.hn-bkt.clouddn.com/82824c55-a0fb-4658-a3ff-09edd5c27e76.png\" alt=\"SQL和NoSQL.png\" /></li>\n</ul>\n<h1><a id=\"RedisRemote_Dictioary_Server_17\"></a>认识Redis（Remote Dictioary Server）</h1>\n<p>Redis诞生于2009年，全称是Remote Dictioary Server，远程词典服务器，是一个基于内存的键值型NoSql数据库。</p>\n<h2><a id=\"_19\"></a>特征</h2>\n<ul>\n<li>键值（key-value）型，value支持多种不同数据结构，功能丰富</li>\n<li>单线程，每个命令具备原子性</li>\n<li>低延迟，速度快（基于内存<strong>核心</strong>，IO多路复用、良好的编码）。</li>\n<li>支持数据持久化</li>\n<li>支持主从集群、分片集群（数据拆分到不同节点）</li>\n<li>支持多语言客户端</li>\n</ul>\n<h1><a id=\"_26\"></a>安装。看说明</h1>\n', 1658823734083043330);
INSERT INTO `ms_article_body` VALUES (1658824196156932099, '# Redis数据结构介绍\n- Redis是一个key-value的数据库，key一般为String类型，不过value的类型多种多样：(前5种为基本类型、后面是特殊类型)\n- String\n- Hash\n- List\n- Set\n- SortedSet\n- Geo\n- BitMap\n- HyperLog  \n\n# 通用命令（）\n- 官方文档generic\n- 命令行：help @generic\n## 常用的有\n1. KEYS：查看复合模版的所有的key，不建议在生产环境设备上使用\n2. DEL：删除一个指定的key（返回值是删除的key数）\n3. exists：判断key是否存在\n4. expile：给key设置一个有效期，有效期到期时key会被自动删除  \n5. ttl：查看一个key的剩余有效期（返回-1表示永久有效，-2表示死亡）\n## String常见命令\n- String类型，也就是字符串类型，是Redis中最简单的存储类型    \n其value是字符串，不过根据字符串的格式不同，又可以分为三类：  \n- string：普通字符串\n- int：整数类型，可以做自增、自减操作\n- float：浮点类型，可以做自增、自减操作  \n不管哪种格式，底层都是字节数组形式存储，只不过是编码方式不同。字符串类型的最大空间不能超过512m\n### String类型常见命令有：\n1. SET：添加或者修改已经存在的一个String类型的键值对\n2. GET：根据key获取String类型的value\n3. MSET：批量添加多个String类型的键值对\n4. MGET：根据多个key获取多个String类型的value\n5. INCR：让一个整型的key自增1\n6. INCRBY：让一个整型的key自增并指定步长，incrby num 2：让num自增2\n7. incrbyfloat：让一个浮点型的key自增并指定步长\n8. SETINT：添加一个String类型的键值对，前提是这个key不存在，否则不执行\n9. SETEX：添加一个String类型的键值对，并指定有效期\n\n# KEY的底层格式\n- redis没有类似mysql中的table的概念，我们该如何区分不同类型的key：\n## key的结构\nRedis的key允许有多个单词形式的层级结构，多个单词之间用“：”隔开，格式如下：        项目名：业务名：类型：id（根据自己所需，格式不固定）  \n如果value是一个java对象，例如一个User对象，则可以将对象序列化为Json字符串后存储\n\n# Hash类型\nHash类型，也叫散列，其value是一个无序字典，类型于Java中的HashMap结构     \nString类型是将对象序列化为json字符串后存储，当需要修改对象的某个字段时很不方便  \n![Hash结构.png](http://ruizmypmv.hn-bkt.clouddn.com/601a2967-cc7d-4836-a474-6a8e9d20836a.png)\n### Hash常用命令\n1. HSET key field value：添加或者修改已经存在的一个hashg类型key的field值\n2. HGET key field：获取hash类型的key的field的值\n3. HMSET：批量添加多个hash类型的key的field的值\n4. HMGET：批量获取多个hash类型的key的field的值\n5. HGETALL:获取一个hash类型的kry中的所有field和value\n6. HKEYS：获取一个Hash类型的key中的所有field\n7. HVALS：获取一个hash类型的key中的所有的value\n8. HINCRBY：让一个hash类型的key的字段自增并指定步长\n9. HSETNX：添加一个hash类型的key的field值，前提是这个field不存在，否则不执行    \n\n\n# List类型\nRedis中的List类型与Java中的LinkedList类似，可以看作时一个双向链表结构。既可以支持正向检索也可以支持反向检索。  \n特征也与LinkedList类似：\n- 有序\n- 元素可以重复\n- 插入和删除块\n- 查询速度一般  \n## List常见命令\n1. LPUSH key element ...:向列表左侧插入一个或多个元素\n2. LPOP key:移除并返回队列左侧的对一个元素，没有则返回nil\n3. RPUSH key element ...：向列表右侧插入一个或多个元素\n4. RPOP key:移除并返回队列右侧的对一个元素，没有则返回nil\n5. LRANGE key star end:返回一段角标（从0开始）范围内的所有元素\n6. BLPOP和BRPOP：与LPOP和RPOP类似，只不过在没有元素时等待指定时间，而不是直接返回nil  \n### 利用LIst模拟一个栈\n- 入口出口在同一边\n### 模拟队列\n- 入口出口不在一边\n### 阻塞队列\n- 入口出口不在一边\n- 出队列采用BLPOP或BRPOP\n\n# Set类型\nredid的set结构与Java中的hashSet类似，可以看做是一个value为null的hashMap。因为也是一个hash表，因此具有与HashSet类似的特征  \n- 无序\n- 元素不可重复\n- 查找快\n- 支持交集，并集、差集等功能\n## set常见命令\n1. SADD key member ...:向set中添加一个或多个元素\n2. SREM key member ...:移除set中的指定元素  \n3. SCARD key:返回set中元素的个数\n4. SISMEMBER key member:判断一个元素是否存在于set中\n5. SMEMBERS：获取set中的所有元素  \n6. SINTER key1 key2...：求key1和key2的交集\n7. SDIFF key1 key2...：求key1和key2的差集\n8. SUNION key1 key2...：求key1和key2的并集  \n\n# SortedSet类型\nRedis的SortedSet是一个可排序的set集合，与Java中的TreeSet有些类似，但底层数据结构差距很大。SortedSet中的每一个元素都带有一个score属性，可以基于score属性对元素排序，底层实现是一个跳表（SkipList）加hash表。  \nSortedSet具备下列特征\n- 可排序\n- 元素不可重复\n- 查询速度块(跳表（SkipList）加hash表)  \n因为SortedSet的可排序特性，经常被用来实现排行榜这样的功能  \n## SortedSet类型常见的命令\n1. ZADD key score member：添加一个或多个元素到sorted set，如果以及存在则更新其score值。\n2. ZREM key member：删除sorted set中的一个指定元素\n3. ZSCORE key member：获取sorted set中的指定元素的score值\n4. ZRANK key member：获取sorted set中的指定元素的排名\n5. ZCARD key：获取sorted set中的元素个数\n6. ZCOUNT key min max：统计score值在给定范围内的所有元素的个数\n7. ZINCRBY key increment member：让sorted set中的指定元素自增，步长为指定的increment值\n8. ZRANGE key min max：按照score排序后，获取指定排名范围内的元素\n9. ZRANGEBYSCORE key min max：按照score排序后，获取指定score范围内的元素\n10. ZDIFF\\ZINTER\\ZUNION:求差集、交集、并集', '<h1><a id=\"Redis_0\"></a>Redis数据结构介绍</h1>\n<ul>\n<li>Redis是一个key-value的数据库，key一般为String类型，不过value的类型多种多样：(前5种为基本类型、后面是特殊类型)</li>\n<li>String</li>\n<li>Hash</li>\n<li>List</li>\n<li>Set</li>\n<li>SortedSet</li>\n<li>Geo</li>\n<li>BitMap</li>\n<li>HyperLog</li>\n</ul>\n<h1><a id=\"_11\"></a>通用命令（）</h1>\n<ul>\n<li>官方文档generic</li>\n<li>命令行：help @generic</li>\n</ul>\n<h2><a id=\"_14\"></a>常用的有</h2>\n<ol>\n<li>KEYS：查看复合模版的所有的key，不建议在生产环境设备上使用</li>\n<li>DEL：删除一个指定的key（返回值是删除的key数）</li>\n<li>exists：判断key是否存在</li>\n<li>expile：给key设置一个有效期，有效期到期时key会被自动删除</li>\n<li>ttl：查看一个key的剩余有效期（返回-1表示永久有效，-2表示死亡）</li>\n</ol>\n<h2><a id=\"String_20\"></a>String常见命令</h2>\n<ul>\n<li>String类型，也就是字符串类型，是Redis中最简单的存储类型<br />\n其value是字符串，不过根据字符串的格式不同，又可以分为三类：</li>\n<li>string：普通字符串</li>\n<li>int：整数类型，可以做自增、自减操作</li>\n<li>float：浮点类型，可以做自增、自减操作<br />\n不管哪种格式，底层都是字节数组形式存储，只不过是编码方式不同。字符串类型的最大空间不能超过512m</li>\n</ul>\n<h3><a id=\"String_27\"></a>String类型常见命令有：</h3>\n<ol>\n<li>SET：添加或者修改已经存在的一个String类型的键值对</li>\n<li>GET：根据key获取String类型的value</li>\n<li>MSET：批量添加多个String类型的键值对</li>\n<li>MGET：根据多个key获取多个String类型的value</li>\n<li>INCR：让一个整型的key自增1</li>\n<li>INCRBY：让一个整型的key自增并指定步长，incrby num 2：让num自增2</li>\n<li>incrbyfloat：让一个浮点型的key自增并指定步长</li>\n<li>SETINT：添加一个String类型的键值对，前提是这个key不存在，否则不执行</li>\n<li>SETEX：添加一个String类型的键值对，并指定有效期</li>\n</ol>\n<h1><a id=\"KEY_38\"></a>KEY的底层格式</h1>\n<ul>\n<li>redis没有类似mysql中的table的概念，我们该如何区分不同类型的key：</li>\n</ul>\n<h2><a id=\"key_40\"></a>key的结构</h2>\n<p>Redis的key允许有多个单词形式的层级结构，多个单词之间用“：”隔开，格式如下：        项目名：业务名：类型：id（根据自己所需，格式不固定）<br />\n如果value是一个java对象，例如一个User对象，则可以将对象序列化为Json字符串后存储</p>\n<h1><a id=\"Hash_44\"></a>Hash类型</h1>\n<p>Hash类型，也叫散列，其value是一个无序字典，类型于Java中的HashMap结构<br />\nString类型是将对象序列化为json字符串后存储，当需要修改对象的某个字段时很不方便<br />\n<img src=\"http://ruizmypmv.hn-bkt.clouddn.com/601a2967-cc7d-4836-a474-6a8e9d20836a.png\" alt=\"Hash结构.png\" /></p>\n<h3><a id=\"Hash_48\"></a>Hash常用命令</h3>\n<ol>\n<li>HSET key field value：添加或者修改已经存在的一个hashg类型key的field值</li>\n<li>HGET key field：获取hash类型的key的field的值</li>\n<li>HMSET：批量添加多个hash类型的key的field的值</li>\n<li>HMGET：批量获取多个hash类型的key的field的值</li>\n<li>HGETALL:获取一个hash类型的kry中的所有field和value</li>\n<li>HKEYS：获取一个Hash类型的key中的所有field</li>\n<li>HVALS：获取一个hash类型的key中的所有的value</li>\n<li>HINCRBY：让一个hash类型的key的字段自增并指定步长</li>\n<li>HSETNX：添加一个hash类型的key的field值，前提是这个field不存在，否则不执行</li>\n</ol>\n<h1><a id=\"List_60\"></a>List类型</h1>\n<p>Redis中的List类型与Java中的LinkedList类似，可以看作时一个双向链表结构。既可以支持正向检索也可以支持反向检索。<br />\n特征也与LinkedList类似：</p>\n<ul>\n<li>有序</li>\n<li>元素可以重复</li>\n<li>插入和删除块</li>\n<li>查询速度一般</li>\n</ul>\n<h2><a id=\"List_67\"></a>List常见命令</h2>\n<ol>\n<li>LPUSH key element …:向列表左侧插入一个或多个元素</li>\n<li>LPOP key:移除并返回队列左侧的对一个元素，没有则返回nil</li>\n<li>RPUSH key element …：向列表右侧插入一个或多个元素</li>\n<li>RPOP key:移除并返回队列右侧的对一个元素，没有则返回nil</li>\n<li>LRANGE key star end:返回一段角标（从0开始）范围内的所有元素</li>\n<li>BLPOP和BRPOP：与LPOP和RPOP类似，只不过在没有元素时等待指定时间，而不是直接返回nil</li>\n</ol>\n<h3><a id=\"LIst_74\"></a>利用LIst模拟一个栈</h3>\n<ul>\n<li>入口出口在同一边</li>\n</ul>\n<h3><a id=\"_76\"></a>模拟队列</h3>\n<ul>\n<li>入口出口不在一边</li>\n</ul>\n<h3><a id=\"_78\"></a>阻塞队列</h3>\n<ul>\n<li>入口出口不在一边</li>\n<li>出队列采用BLPOP或BRPOP</li>\n</ul>\n<h1><a id=\"Set_82\"></a>Set类型</h1>\n<p>redid的set结构与Java中的hashSet类似，可以看做是一个value为null的hashMap。因为也是一个hash表，因此具有与HashSet类似的特征</p>\n<ul>\n<li>无序</li>\n<li>元素不可重复</li>\n<li>查找快</li>\n<li>支持交集，并集、差集等功能</li>\n</ul>\n<h2><a id=\"set_88\"></a>set常见命令</h2>\n<ol>\n<li>SADD key member …:向set中添加一个或多个元素</li>\n<li>SREM key member …:移除set中的指定元素</li>\n<li>SCARD key:返回set中元素的个数</li>\n<li>SISMEMBER key member:判断一个元素是否存在于set中</li>\n<li>SMEMBERS：获取set中的所有元素</li>\n<li>SINTER key1 key2…：求key1和key2的交集</li>\n<li>SDIFF key1 key2…：求key1和key2的差集</li>\n<li>SUNION key1 key2…：求key1和key2的并集</li>\n</ol>\n<h1><a id=\"SortedSet_98\"></a>SortedSet类型</h1>\n<p>Redis的SortedSet是一个可排序的set集合，与Java中的TreeSet有些类似，但底层数据结构差距很大。SortedSet中的每一个元素都带有一个score属性，可以基于score属性对元素排序，底层实现是一个跳表（SkipList）加hash表。<br />\nSortedSet具备下列特征</p>\n<ul>\n<li>可排序</li>\n<li>元素不可重复</li>\n<li>查询速度块(跳表（SkipList）加hash表)<br />\n因为SortedSet的可排序特性，经常被用来实现排行榜这样的功能</li>\n</ul>\n<h2><a id=\"SortedSet_105\"></a>SortedSet类型常见的命令</h2>\n<ol>\n<li>ZADD key score member：添加一个或多个元素到sorted set，如果以及存在则更新其score值。</li>\n<li>ZREM key member：删除sorted set中的一个指定元素</li>\n<li>ZSCORE key member：获取sorted set中的指定元素的score值</li>\n<li>ZRANK key member：获取sorted set中的指定元素的排名</li>\n<li>ZCARD key：获取sorted set中的元素个数</li>\n<li>ZCOUNT key min max：统计score值在给定范围内的所有元素的个数</li>\n<li>ZINCRBY key increment member：让sorted set中的指定元素自增，步长为指定的increment值</li>\n<li>ZRANGE key min max：按照score排序后，获取指定排名范围内的元素</li>\n<li>ZRANGEBYSCORE key min max：按照score排序后，获取指定score范围内的元素</li>\n<li>ZDIFF\\ZINTER\\ZUNION:求差集、交集、并集</li>\n</ol>\n', 1658824196089823234);
INSERT INTO `ms_article_body` VALUES (1658826394043531265, '\n# 面向对象高级第一天\n# static关键字\n是静态的意思，可以修饰成员变量，也可以修饰成员方法\n\n# 成员变量的分类\n1. 静态成员变量\n- 有static修饰，属于类，与类一起加载，内存中只有一份，可以被共享访问。\n\n- 什么时候用呢？如果信息要被共享，只需要一份就用静态成员变量，比如：系统在线人数。\n\n- 访问规则：\n建议用类名访问：类名.静态成员变量\n同一个类中，访问静态成员可以省略类名不写。\n 理论上也可以这样访问：对象名.静态成员变量（不推荐）\n\n2. 实例成员变量\n- 无static修饰，属于对象，每个对象中都存在一份实例成员变量。比如：name age\n- 什么时候用呢？比如：name age，每个对象中都有这些信息，而且信息还不同时，定义成实例成员变量。\n\n- 访问规则：\n                    只能用：对象名.实例成员变量。\n\n# 成员方法的分类\n1. 静态成员方法\n- 有static修饰，属于类，与类一起加载，可以被共享访问。\n- 什么时候用呢？如果是做一个通用功能，可以用静态成员方法。\n- 访问规则：\n建议用类名访问：类名.静态方法\n\n注意：同一个类中，访问静态成员可以省略类名不写。\n理论上也可以这样访问：对象名.静态成员方法（不推荐）\n- 静态成员方法的应用：工具类\n是什么？ 工具类中都是静态方法，为了完成一个共用功能\n好处：一次编写，处处可调，提高代码的复用性，提高开发的效率。\n注意：建议把工具类的构造器私有化，因为工具类无需对外创建对象，它的方法都是静态方法，直接用类名访问即可。\n2. 实例成员方法\n- 无static修饰，属于对象，必须用对象触发访问。\n- 什么时候用呢？如果这个方法属于对象，而且要直接访问对象的实例成员，则声明成实例方法。\n- 访问规则：\n只能用：对象名.实例成员方法。\n# static的应用知识\n代码块\n是什么？ 类的5大成分（成员变量、成员方法、构造器、代码块、内部类）之一\n\n分类\n\n静态代码块：（重点了解一下）\n\n格式：static {}\n特点：属于类，与类一起优先加载，自动触发执行一次。\n作用：可以用于在程序启动时，进行静态资源的初始化操作\n实例代码块（几乎不用）：\n\n格式：{}\n特点：属于对象的，每次调用构造器构建对象前都会执行一次，再执行构造器。\n作用：可以用于初始化实例资源\n单例设计模式\n单例是一种设计模式，是为了解决某个问题\n\n单例能解决的问题：保证一个类对外只能产生一个对象。\n\n重点在于如何实现单例：\n\n饿汉单例\n\n特点：拿对象时，对象已经存在\n\n实现步骤：\n\n/**\n * 饿汉单例设计模式\n */\npublic class SingleInstance {\n    // 1.定义一个类，将构造器私有\n    private SingleInstance() {}\n​\n    // 2.对外提供一个静态对象\n    // 饿汉单例是在获取对象前，就已经准备好了一个对象\n    // 这个对象只能通过类名访问，所以定义成static的\n    public static SingleInstance instance = new SingleInstance();\n}\n懒汉单例\n\n特点：要拿对象的时候，才开始创建一个对象。\n\n实现步骤：\n\n/**\n * 懒汉单例设计模式\n */\npublic class SingleInstance2 {\n    // 2.定义一个静态的成员变量负责存储一个对象，只加载一次，只有一份。\n    // 专业的做法是：这里私有化，这样可以避免给别人挖坑\n    private static SingleInstance2 instance2;\n​\n    // 1.将构造器私有化\n    private SingleInstance2() {}\n​\n    // 3.对外提供一个静态的获取对象的方法\n    public static SingleInstance2 getInstance2() {\n        if (instance2 == null) {\n            // 第一次来拿对象 ：此时需要创建对象。\n            instance2 = new SingleInstance2();\n        }\n        return instance2;\n    }\n}\n面向对象的三大特征之二：继承\n继承概述、使用继承的好处\n什么是继承？ Java允许一个类通过extends与另一个类建立父子关系，这就是继承。\n\n# 继承的格式：\n\n子类 extends 父类\n\n# 继承的特点：\n\n子类继承父类后，就可以得到父类的属性和行为。\n\n继承的核心优点：\n\n提高代码的复用性，多个子类的相同代码可以放在父类中，增强了类的扩展性。\n\n继承的设计规范、内存运行原理\n设计规范：子类共用属性和行为放在父类，子类独有属性和行为放在子类自己那里。\n\n内存原理：\n\n子类对象实际上是由子父类这两张设计图共同创建出来的。\n\n继承的特点\nJava是单继承模式：一个类只能继承一个直接父类。\n\nJava不支持多继承、但是支持多层继承。\n\nJava中所有的类都是Object类的子类。\n\n继承后：方法重写\n概念：子类重写了一个声明与父类一样的方法，覆盖父类的方法。子类认为父类的该方法不好用，以后用自己重写的方法。\n\n重写方法建议加上一个重写校验注解：@Override\n\n作用：要求必须是正确重写的才不报错\n\n作用2：可读性好\n\n重写的要求：\n\n重写方法的名称和形参列表必须与父类被重写方法的名称和形参列表一致（重点）\n\n私有方法不能重写\n\n静态方法不能重写\n\n重写方法的权限 >= 被重写方法的访问权限。\n\n在重写的方法中如果想要访问父类的方法怎么办呢？\n\nsuper.方法名();\n\n继承后：成员变量、成员方法的访问特点\n就近原则\n\nthis.子类自己的成员变量\n\n在子类方法中访问父类成员怎么办？ super.父类成员变量/父类成员方法\n\n继承后：子类构造器的特点\n特点：子类的全部构造器默认都会先访问父类的无参数构造器，再执行自己的构造器\n\n为什么呢? 先有爸爸才有儿子。 先调用父类的构造器初始化父类的数据，再调用自己的构造器初始化自己的数据。\n\n代码层面：默认子类构造器的第一行都有一个super()， 访问父类的无参数构造器，写不写都有\n\n继承后：子类构造器访问父类有参构造器\n调用父类有参数构造器，初始化继承自父类的数据。\n\nsuper(....) 根据参数调用父类构造器\n\nthis、super使用总结\nthis访问子类当前对象的成员。\n\nsuper：在子类方法中指定访问父类的成员。\n\nthis(...) : 访问本类兄弟构造器\n\nsuper(...):在本类构造器中指定访问父类的构造器\n\n注意事项：super(...) 必须放在第一行，this(...) 也必须在第一行。因此2者不能共存一个构造器中。', '<h1><a id=\"_1\"></a>面向对象高级第一天</h1>\n<h1><a id=\"static_2\"></a>static关键字</h1>\n<p>是静态的意思，可以修饰成员变量，也可以修饰成员方法</p>\n<h1><a id=\"_5\"></a>成员变量的分类</h1>\n<ol>\n<li>静态成员变量</li>\n</ol>\n<ul>\n<li>\n<p>有static修饰，属于类，与类一起加载，内存中只有一份，可以被共享访问。</p>\n</li>\n<li>\n<p>什么时候用呢？如果信息要被共享，只需要一份就用静态成员变量，比如：系统在线人数。</p>\n</li>\n<li>\n<p>访问规则：<br />\n建议用类名访问：类名.静态成员变量<br />\n同一个类中，访问静态成员可以省略类名不写。<br />\n理论上也可以这样访问：对象名.静态成员变量（不推荐）</p>\n</li>\n</ul>\n<ol start=\"2\">\n<li>实例成员变量</li>\n</ol>\n<ul>\n<li>\n<p>无static修饰，属于对象，每个对象中都存在一份实例成员变量。比如：name age</p>\n</li>\n<li>\n<p>什么时候用呢？比如：name age，每个对象中都有这些信息，而且信息还不同时，定义成实例成员变量。</p>\n</li>\n<li>\n<p>访问规则：<br />\n只能用：对象名.实例成员变量。</p>\n</li>\n</ul>\n<h1><a id=\"_23\"></a>成员方法的分类</h1>\n<ol>\n<li>静态成员方法</li>\n</ol>\n<ul>\n<li>有static修饰，属于类，与类一起加载，可以被共享访问。</li>\n<li>什么时候用呢？如果是做一个通用功能，可以用静态成员方法。</li>\n<li>访问规则：<br />\n建议用类名访问：类名.静态方法</li>\n</ul>\n<p>注意：同一个类中，访问静态成员可以省略类名不写。<br />\n理论上也可以这样访问：对象名.静态成员方法（不推荐）</p>\n<ul>\n<li>静态成员方法的应用：工具类<br />\n是什么？ 工具类中都是静态方法，为了完成一个共用功能<br />\n好处：一次编写，处处可调，提高代码的复用性，提高开发的效率。<br />\n注意：建议把工具类的构造器私有化，因为工具类无需对外创建对象，它的方法都是静态方法，直接用类名访问即可。</li>\n</ul>\n<ol start=\"2\">\n<li>实例成员方法</li>\n</ol>\n<ul>\n<li>无static修饰，属于对象，必须用对象触发访问。</li>\n<li>什么时候用呢？如果这个方法属于对象，而且要直接访问对象的实例成员，则声明成实例方法。</li>\n<li>访问规则：<br />\n只能用：对象名.实例成员方法。</li>\n</ul>\n<h1><a id=\"static_41\"></a>static的应用知识</h1>\n<p>代码块<br />\n是什么？ 类的5大成分（成员变量、成员方法、构造器、代码块、内部类）之一</p>\n<p>分类</p>\n<p>静态代码块：（重点了解一下）</p>\n<p>格式：static {}<br />\n特点：属于类，与类一起优先加载，自动触发执行一次。<br />\n作用：可以用于在程序启动时，进行静态资源的初始化操作<br />\n实例代码块（几乎不用）：</p>\n<p>格式：{}<br />\n特点：属于对象的，每次调用构造器构建对象前都会执行一次，再执行构造器。<br />\n作用：可以用于初始化实例资源<br />\n单例设计模式<br />\n单例是一种设计模式，是为了解决某个问题</p>\n<p>单例能解决的问题：保证一个类对外只能产生一个对象。</p>\n<p>重点在于如何实现单例：</p>\n<p>饿汉单例</p>\n<p>特点：拿对象时，对象已经存在</p>\n<p>实现步骤：</p>\n<p>/**</p>\n<ul>\n<li>饿汉单例设计模式<br />\n*/<br />\npublic class SingleInstance {<br />\n// 1.定义一个类，将构造器私有<br />\nprivate SingleInstance() {}<br />\n​<br />\n// 2.对外提供一个静态对象<br />\n// 饿汉单例是在获取对象前，就已经准备好了一个对象<br />\n// 这个对象只能通过类名访问，所以定义成static的<br />\npublic static SingleInstance instance = new SingleInstance();<br />\n}<br />\n懒汉单例</li>\n</ul>\n<p>特点：要拿对象的时候，才开始创建一个对象。</p>\n<p>实现步骤：</p>\n<p>/**</p>\n<ul>\n<li>懒汉单例设计模式<br />\n*/<br />\npublic class SingleInstance2 {<br />\n// 2.定义一个静态的成员变量负责存储一个对象，只加载一次，只有一份。<br />\n// 专业的做法是：这里私有化，这样可以避免给别人挖坑<br />\nprivate static SingleInstance2 instance2;<br />\n​<br />\n// 1.将构造器私有化<br />\nprivate SingleInstance2() {}<br />\n​<br />\n// 3.对外提供一个静态的获取对象的方法<br />\npublic static SingleInstance2 getInstance2() {<br />\nif (instance2 == null) {<br />\n// 第一次来拿对象 ：此时需要创建对象。<br />\ninstance2 = new SingleInstance2();<br />\n}<br />\nreturn instance2;<br />\n}<br />\n}<br />\n面向对象的三大特征之二：继承<br />\n继承概述、使用继承的好处<br />\n什么是继承？ Java允许一个类通过extends与另一个类建立父子关系，这就是继承。</li>\n</ul>\n<h1><a id=\"_112\"></a>继承的格式：</h1>\n<p>子类 extends 父类</p>\n<h1><a id=\"_116\"></a>继承的特点：</h1>\n<p>子类继承父类后，就可以得到父类的属性和行为。</p>\n<p>继承的核心优点：</p>\n<p>提高代码的复用性，多个子类的相同代码可以放在父类中，增强了类的扩展性。</p>\n<p>继承的设计规范、内存运行原理<br />\n设计规范：子类共用属性和行为放在父类，子类独有属性和行为放在子类自己那里。</p>\n<p>内存原理：</p>\n<p>子类对象实际上是由子父类这两张设计图共同创建出来的。</p>\n<p>继承的特点<br />\nJava是单继承模式：一个类只能继承一个直接父类。</p>\n<p>Java不支持多继承、但是支持多层继承。</p>\n<p>Java中所有的类都是Object类的子类。</p>\n<p>继承后：方法重写<br />\n概念：子类重写了一个声明与父类一样的方法，覆盖父类的方法。子类认为父类的该方法不好用，以后用自己重写的方法。</p>\n<p>重写方法建议加上一个重写校验注解：@Override</p>\n<p>作用：要求必须是正确重写的才不报错</p>\n<p>作用2：可读性好</p>\n<p>重写的要求：</p>\n<p>重写方法的名称和形参列表必须与父类被重写方法的名称和形参列表一致（重点）</p>\n<p>私有方法不能重写</p>\n<p>静态方法不能重写</p>\n<p>重写方法的权限 &gt;= 被重写方法的访问权限。</p>\n<p>在重写的方法中如果想要访问父类的方法怎么办呢？</p>\n<p>super.方法名();</p>\n<p>继承后：成员变量、成员方法的访问特点<br />\n就近原则</p>\n<p>this.子类自己的成员变量</p>\n<p>在子类方法中访问父类成员怎么办？ super.父类成员变量/父类成员方法</p>\n<p>继承后：子类构造器的特点<br />\n特点：子类的全部构造器默认都会先访问父类的无参数构造器，再执行自己的构造器</p>\n<p>为什么呢? 先有爸爸才有儿子。 先调用父类的构造器初始化父类的数据，再调用自己的构造器初始化自己的数据。</p>\n<p>代码层面：默认子类构造器的第一行都有一个super()， 访问父类的无参数构造器，写不写都有</p>\n<p>继承后：子类构造器访问父类有参构造器<br />\n调用父类有参数构造器，初始化继承自父类的数据。</p>\n<p>super(…) 根据参数调用父类构造器</p>\n<p>this、super使用总结<br />\nthis访问子类当前对象的成员。</p>\n<p>super：在子类方法中指定访问父类的成员。</p>\n<p>this(…) : 访问本类兄弟构造器</p>\n<p>super(…):在本类构造器中指定访问父类的构造器</p>\n<p>注意事项：super(…) 必须放在第一行，this(…) 也必须在第一行。因此2者不能共存一个构造器中。</p>\n', 1658826393972228098);
INSERT INTO `ms_article_body` VALUES (1658827199270207491, '![屏幕截图 20230517 212752.png](http://ruizmypmv.hn-bkt.clouddn.com/c5028803-8b58-4b5b-a3a4-4b0b373260d9.png)\n![屏幕截图 20230517 212827.png](http://ruizmypmv.hn-bkt.clouddn.com/6ff7705f-b86a-443f-b693-32c5a674eb84.png)\n![屏幕截图 20230517 212904.png](http://ruizmypmv.hn-bkt.clouddn.com/0c7f30b0-6350-482c-b352-583844c911f2.png)\n![屏幕截图 20230517 212929.png](http://ruizmypmv.hn-bkt.clouddn.com/afb29826-405e-4c26-b7c2-5e6a04b43022.png)', '<p><img src=\"http://ruizmypmv.hn-bkt.clouddn.com/c5028803-8b58-4b5b-a3a4-4b0b373260d9.png\" alt=\"屏幕截图 20230517 212752.png\" /><br />\n<img src=\"http://ruizmypmv.hn-bkt.clouddn.com/6ff7705f-b86a-443f-b693-32c5a674eb84.png\" alt=\"屏幕截图 20230517 212827.png\" /><br />\n<img src=\"http://ruizmypmv.hn-bkt.clouddn.com/0c7f30b0-6350-482c-b352-583844c911f2.png\" alt=\"屏幕截图 20230517 212904.png\" /><br />\n<img src=\"http://ruizmypmv.hn-bkt.clouddn.com/afb29826-405e-4c26-b7c2-5e6a04b43022.png\" alt=\"屏幕截图 20230517 212929.png\" /></p>\n', 1658827199270207489);
INSERT INTO `ms_article_body` VALUES (1658827734819913731, '# 0.安装Docker\n\nDocker 分为 CE 和 EE 两大版本。CE 即社区版（免费，支持周期 7 个月），EE 即企业版，强调安全，付费使用，支持周期 24 个月。\n\nDocker CE 分为 `stable` `test` 和 `nightly` 三个更新频道。\n\n官方网站上有各种环境下的 [安装指南](https://docs.docker.com/install/)，这里主要介绍 Docker CE 在 CentOS上的安装。\n\n# 1.CentOS安装Docker\n\nDocker CE 支持 64 位版本 CentOS 7，并且要求内核版本不低于 3.10， CentOS 7 满足最低内核的要求，所以我们在CentOS 7安装Docker。\n\n\n\n## 1.1.卸载（可选）\n\n如果之前安装过旧版本的Docker，可以使用下面命令卸载：\n\n```\nyum remove docker \\\n                  docker-client \\\n                  docker-client-latest \\\n                  docker-common \\\n                  docker-latest \\\n                  docker-latest-logrotate \\\n                  docker-logrotate \\\n                  docker-selinux \\\n                  docker-engine-selinux \\\n                  docker-engine \\\n                  docker-ce\n```\n\n\n\n## 1.2.安装docker\n\n首先需要大家虚拟机联网，安装yum工具\n\n```sh\nyum install -y yum-utils \\\n           device-mapper-persistent-data \\\n           lvm2 --skip-broken\n```\n\n\n\n然后更新本地镜像源：\n\n```shell\n# 设置docker镜像源\nyum-config-manager \\\n    --add-repo \\\n    https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo\n    \nsed -i \'s/download.docker.com/mirrors.aliyun.com\\/docker-ce/g\' /etc/yum.repos.d/docker-ce.repo\n\nyum makecache fast\n```\n\n\n\n\n\n然后输入命令：\n\n```shell\nyum install -y docker-ce\n```\n\ndocker-ce为社区免费版本。稍等片刻，docker即可安装成功。\n\n\n\n## 1.3.启动docker\n\nDocker应用需要用到各种端口，逐一去修改防火墙设置。非常麻烦，因此建议大家直接关闭防火墙！\n\n启动docker前，一定要关闭防火墙后！！\n\n启动docker前，一定要关闭防火墙后！！\n\n启动docker前，一定要关闭防火墙后！！\n\n\n\n```sh\n# 关闭\nsystemctl stop firewalld\n# 禁止开机启动防火墙\nsystemctl disable firewalld\n```\n\n\n\n通过命令启动docker：\n\n```sh\nsystemctl start docker  # 启动docker服务\n\nsystemctl stop docker  # 停止docker服务\n\nsystemctl restart docker  # 重启docker服务\n```\n\n\n\n然后输入命令，可以查看docker版本：\n\n```\ndocker -v\n```\n\n如图：\n\n![image-20210418154704436](assets/image-20210418154704436.png) \n\n\n\n## 1.4.配置镜像加速\n\ndocker官方镜像仓库网速较差，我们需要设置国内镜像服务：\n\n参考阿里云的镜像加速文档：https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors\n\n\n\n\n\n# 2.CentOS7安装DockerCompose\n\n\n\n## 2.1.下载\n\nLinux下需要通过命令下载：\n\n```sh\n# 安装\ncurl -L https://github.com/docker/compose/releases/download/1.23.1/docker-compose-`uname -s`-`uname -m` > /usr/local/bin/docker-compose\n```\n\n如果下载速度较慢，或者下载失败，可以使用课前资料提供的docker-compose文件：\n\n![image-20210417133020614](assets/image-20210417133020614.png)\n\n上传到`/usr/local/bin/`目录也可以。\n\n\n\n## 2.2.修改文件权限\n\n修改文件权限：\n\n```sh\n# 修改权限\nchmod +x /usr/local/bin/docker-compose\n```\n\n\n\n\n\n## 2.3.Base自动补全命令：\n\n```sh\n# 补全命令\ncurl -L https://raw.githubusercontent.com/docker/compose/1.29.1/contrib/completion/bash/docker-compose > /etc/bash_completion.d/docker-compose\n```\n\n如果这里出现错误，需要修改自己的hosts文件：\n\n```sh\necho \"199.232.68.133 raw.githubusercontent.com\" >> /etc/hosts\n```\n\n\n\n\n\n# 3.Docker镜像仓库\n\n搭建镜像仓库可以基于Docker官方提供的DockerRegistry来实现。\n\n官网地址：https://hub.docker.com/_/registry\n\n\n\n## 3.1.简化版镜像仓库\n\nDocker官方的Docker Registry是一个基础版本的Docker镜像仓库，具备仓库管理的完整功能，但是没有图形化界面。\n\n搭建方式比较简单，命令如下：\n\n```sh\ndocker run -d \\\n    --restart=always \\\n    --name registry	\\\n    -p 5000:5000 \\\n    -v registry-data:/var/lib/registry \\\n    registry\n```\n\n\n\n命令中挂载了一个数据卷registry-data到容器内的/var/lib/registry 目录，这是私有镜像库存放数据的目录。\n\n访问http://YourIp:5000/v2/_catalog 可以查看当前私有镜像服务中包含的镜像\n\n\n\n## 3.2.带有图形化界面版本\n\n使用DockerCompose部署带有图象界面的DockerRegistry，命令如下：\n\n```yaml\nversion: \'3.0\'\nservices:\n  registry:\n    image: registry\n    volumes:\n      - ./registry-data:/var/lib/registry\n  ui:\n    image: joxit/docker-registry-ui:static\n    ports:\n      - 8080:80\n    environment:\n      - REGISTRY_TITLE=私有仓库\n      - REGISTRY_URL=http://registry:5000\n    depends_on:\n      - registry\n```\n\n\n\n## 3.3.配置Docker信任地址\n\n我们的私服采用的是http协议，默认不被Docker信任，所以需要做一个配置：\n\n```sh\n# 打开要修改的文件\nvi /etc/docker/daemon.json\n# 添加内容：\n\"insecure-registries\":[\"http://192.168.150.101:8080\"]\n# 重加载\nsystemctl daemon-reload\n# 重启docker\nsystemctl restart docker\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n', '<h1><a id=\"0Docker_0\"></a>0.安装Docker</h1>\n<p>Docker 分为 CE 和 EE 两大版本。CE 即社区版（免费，支持周期 7 个月），EE 即企业版，强调安全，付费使用，支持周期 24 个月。</p>\n<p>Docker CE 分为 <code>stable</code> <code>test</code> 和 <code>nightly</code> 三个更新频道。</p>\n<p>官方网站上有各种环境下的 <a href=\"https://docs.docker.com/install/\" target=\"_blank\">安装指南</a>，这里主要介绍 Docker CE 在 CentOS上的安装。</p>\n<h1><a id=\"1CentOSDocker_8\"></a>1.CentOS安装Docker</h1>\n<p>Docker CE 支持 64 位版本 CentOS 7，并且要求内核版本不低于 3.10， CentOS 7 满足最低内核的要求，所以我们在CentOS 7安装Docker。</p>\n<h2><a id=\"11_14\"></a>1.1.卸载（可选）</h2>\n<p>如果之前安装过旧版本的Docker，可以使用下面命令卸载：</p>\n<pre><code class=\"lang-\">yum remove docker \\\n                  docker-client \\\n                  docker-client-latest \\\n                  docker-common \\\n                  docker-latest \\\n                  docker-latest-logrotate \\\n                  docker-logrotate \\\n                  docker-selinux \\\n                  docker-engine-selinux \\\n                  docker-engine \\\n                  docker-ce\n</code></pre>\n<h2><a id=\"12docker_34\"></a>1.2.安装docker</h2>\n<p>首先需要大家虚拟机联网，安装yum工具</p>\n<pre><div class=\"hljs\"><code class=\"lang-sh\">yum install -y yum-utils \\\n           device-mapper-persistent-data \\\n           lvm2 --skip-broken\n</code></div></pre>\n<p>然后更新本地镜像源：</p>\n<pre><div class=\"hljs\"><code class=\"lang-shell\"><span class=\"hljs-meta\">#</span><span class=\"bash\"> 设置docker镜像源</span>\nyum-config-manager \\\n    --add-repo \\\n    https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo\n    \nsed -i \'s/download.docker.com/mirrors.aliyun.com\\/docker-ce/g\' /etc/yum.repos.d/docker-ce.repo\n\nyum makecache fast\n</code></div></pre>\n<p>然后输入命令：</p>\n<pre><div class=\"hljs\"><code class=\"lang-shell\">yum install -y docker-ce\n</code></div></pre>\n<p>docker-ce为社区免费版本。稍等片刻，docker即可安装成功。</p>\n<h2><a id=\"13docker_73\"></a>1.3.启动docker</h2>\n<p>Docker应用需要用到各种端口，逐一去修改防火墙设置。非常麻烦，因此建议大家直接关闭防火墙！</p>\n<p>启动docker前，一定要关闭防火墙后！！</p>\n<p>启动docker前，一定要关闭防火墙后！！</p>\n<p>启动docker前，一定要关闭防火墙后！！</p>\n<pre><div class=\"hljs\"><code class=\"lang-sh\"><span class=\"hljs-comment\"># 关闭</span>\nsystemctl stop firewalld\n<span class=\"hljs-comment\"># 禁止开机启动防火墙</span>\nsystemctl <span class=\"hljs-built_in\">disable</span> firewalld\n</code></div></pre>\n<p>通过命令启动docker：</p>\n<pre><div class=\"hljs\"><code class=\"lang-sh\">systemctl start docker  <span class=\"hljs-comment\"># 启动docker服务</span>\n\nsystemctl stop docker  <span class=\"hljs-comment\"># 停止docker服务</span>\n\nsystemctl restart docker  <span class=\"hljs-comment\"># 重启docker服务</span>\n</code></div></pre>\n<p>然后输入命令，可以查看docker版本：</p>\n<pre><code class=\"lang-\">docker -v\n</code></pre>\n<p>如图：</p>\n<p><img src=\"assets/image-20210418154704436.png\" alt=\"image-20210418154704436\" /></p>\n<h2><a id=\"14_118\"></a>1.4.配置镜像加速</h2>\n<p>docker官方镜像仓库网速较差，我们需要设置国内镜像服务：</p>\n<p>参考阿里云的镜像加速文档：https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors</p>\n<h1><a id=\"2CentOS7DockerCompose_128\"></a>2.CentOS7安装DockerCompose</h1>\n<h2><a id=\"21_132\"></a>2.1.下载</h2>\n<p>Linux下需要通过命令下载：</p>\n<pre><div class=\"hljs\"><code class=\"lang-sh\"><span class=\"hljs-comment\"># 安装</span>\ncurl -L https://github.com/docker/compose/releases/download/1.23.1/docker-compose-`uname -s`-`uname -m` &gt; /usr/<span class=\"hljs-built_in\">local</span>/bin/docker-compose\n</code></div></pre>\n<p>如果下载速度较慢，或者下载失败，可以使用课前资料提供的docker-compose文件：</p>\n<p><img src=\"assets/image-20210417133020614.png\" alt=\"image-20210417133020614\" /></p>\n<p>上传到<code>/usr/local/bin/</code>目录也可以。</p>\n<h2><a id=\"22_149\"></a>2.2.修改文件权限</h2>\n<p>修改文件权限：</p>\n<pre><div class=\"hljs\"><code class=\"lang-sh\"><span class=\"hljs-comment\"># 修改权限</span>\nchmod +x /usr/<span class=\"hljs-built_in\">local</span>/bin/docker-compose\n</code></div></pre>\n<h2><a id=\"23Base_162\"></a>2.3.Base自动补全命令：</h2>\n<pre><div class=\"hljs\"><code class=\"lang-sh\"><span class=\"hljs-comment\"># 补全命令</span>\ncurl -L https://raw.githubusercontent.com/docker/compose/1.29.1/contrib/completion/bash/docker-compose &gt; /etc/bash_completion.d/docker-compose\n</code></div></pre>\n<p>如果这里出现错误，需要修改自己的hosts文件：</p>\n<pre><div class=\"hljs\"><code class=\"lang-sh\"><span class=\"hljs-built_in\">echo</span> <span class=\"hljs-string\">\"199.232.68.133 raw.githubusercontent.com\"</span> &gt;&gt; /etc/hosts\n</code></div></pre>\n<h1><a id=\"3Docker_179\"></a>3.Docker镜像仓库</h1>\n<p>搭建镜像仓库可以基于Docker官方提供的DockerRegistry来实现。</p>\n<p>官网地址：https://hub.docker.com/_/registry</p>\n<h2><a id=\"31_187\"></a>3.1.简化版镜像仓库</h2>\n<p>Docker官方的Docker Registry是一个基础版本的Docker镜像仓库，具备仓库管理的完整功能，但是没有图形化界面。</p>\n<p>搭建方式比较简单，命令如下：</p>\n<pre><div class=\"hljs\"><code class=\"lang-sh\">docker run -d \\\n    --restart=always \\\n    --name registry	\\\n    -p 5000:5000 \\\n    -v registry-data:/var/lib/registry \\\n    registry\n</code></div></pre>\n<p>命令中挂载了一个数据卷registry-data到容器内的/var/lib/registry 目录，这是私有镜像库存放数据的目录。</p>\n<p>访问http://YourIp:5000/v2/_catalog 可以查看当前私有镜像服务中包含的镜像</p>\n<h2><a id=\"32_210\"></a>3.2.带有图形化界面版本</h2>\n<p>使用DockerCompose部署带有图象界面的DockerRegistry，命令如下：</p>\n<pre><div class=\"hljs\"><code class=\"lang-yaml\"><span class=\"hljs-attr\">version:</span> <span class=\"hljs-string\">\'3.0\'</span>\n<span class=\"hljs-attr\">services:</span>\n<span class=\"hljs-attr\">  registry:</span>\n<span class=\"hljs-attr\">    image:</span> <span class=\"hljs-string\">registry</span>\n<span class=\"hljs-attr\">    volumes:</span>\n<span class=\"hljs-bullet\">      -</span> <span class=\"hljs-string\">./registry-data:/var/lib/registry</span>\n<span class=\"hljs-attr\">  ui:</span>\n<span class=\"hljs-attr\">    image:</span> <span class=\"hljs-string\">joxit/docker-registry-ui:static</span>\n<span class=\"hljs-attr\">    ports:</span>\n<span class=\"hljs-bullet\">      -</span> <span class=\"hljs-number\">8080</span><span class=\"hljs-string\">:80</span>\n<span class=\"hljs-attr\">    environment:</span>\n<span class=\"hljs-bullet\">      -</span> <span class=\"hljs-string\">REGISTRY_TITLE=私有仓库</span>\n<span class=\"hljs-bullet\">      -</span> <span class=\"hljs-string\">REGISTRY_URL=http://registry:5000</span>\n<span class=\"hljs-attr\">    depends_on:</span>\n<span class=\"hljs-bullet\">      -</span> <span class=\"hljs-string\">registry</span>\n</code></div></pre>\n<h2><a id=\"33Docker_234\"></a>3.3.配置Docker信任地址</h2>\n<p>我们的私服采用的是http协议，默认不被Docker信任，所以需要做一个配置：</p>\n<pre><div class=\"hljs\"><code class=\"lang-sh\"><span class=\"hljs-comment\"># 打开要修改的文件</span>\nvi /etc/docker/daemon.json\n<span class=\"hljs-comment\"># 添加内容：</span>\n<span class=\"hljs-string\">\"insecure-registries\"</span>:[<span class=\"hljs-string\">\"http://192.168.150.101:8080\"</span>]\n<span class=\"hljs-comment\"># 重加载</span>\nsystemctl daemon-reload\n<span class=\"hljs-comment\"># 重启docker</span>\nsystemctl restart docker\n</code></div></pre>\n', 1658827734752804866);
INSERT INTO `ms_article_body` VALUES (1658828931836526593, '## 下载\n去官网下载即可，最新版如果运行不了，可选择安装其他版本，我安装的就是4.0版本\n\n## 建立项目\n一般就是建立一个空项目\n\n如果使用过idea，那么建立项目就很简单。因为Android Studio和 idea 界面都差不多，功能也类似\n\n## 步骤：\n\nFile——New——New Project 会出现以下画面：\n![2974068202305081253064241517829720.png](http://ruizmypmv.hn-bkt.clouddn.com/dfd95f20-03c9-4584-aa0b-f03b6b9211a7.png)\n然后选择 Empty Activity 再点击 Next，然后将工程命名，选择保存路径，最后点击Finish即可。\n![2974068202305081258204661270871556.png](http://ruizmypmv.hn-bkt.clouddn.com/9935bfbc-8808-43e5-9d01-acc8d55b8d7f.png)\n解决报错\n加载工程时出现这个错误：\nInstalled Build Tools revision 33.0.2 is corrupted. Remove and install again using the SDK Manager.\n\n解决：\n\n换一个SDK，然后找到1所示的文件，点开这个文件，将2所示部分改成你换的SDK版本\n![2974068202305081311043841237473638.png](http://ruizmypmv.hn-bkt.clouddn.com/ffbe86b7-24da-422b-9fd6-291e5cdc1c07.png)\n 修改完成之后在最上边会出现这样一行字，点击 Sync Now 即可', '<h2><a id=\"_0\"></a>下载</h2>\n<p>去官网下载即可，最新版如果运行不了，可选择安装其他版本，我安装的就是4.0版本</p>\n<h2><a id=\"_3\"></a>建立项目</h2>\n<p>一般就是建立一个空项目</p>\n<p>如果使用过idea，那么建立项目就很简单。因为Android Studio和 idea 界面都差不多，功能也类似</p>\n<h2><a id=\"_8\"></a>步骤：</h2>\n<p>File——New——New Project 会出现以下画面：<br />\n<img src=\"http://ruizmypmv.hn-bkt.clouddn.com/dfd95f20-03c9-4584-aa0b-f03b6b9211a7.png\" alt=\"2974068202305081253064241517829720.png\" /><br />\n然后选择 Empty Activity 再点击 Next，然后将工程命名，选择保存路径，最后点击Finish即可。<br />\n<img src=\"http://ruizmypmv.hn-bkt.clouddn.com/9935bfbc-8808-43e5-9d01-acc8d55b8d7f.png\" alt=\"2974068202305081258204661270871556.png\" /><br />\n解决报错<br />\n加载工程时出现这个错误：<br />\nInstalled Build Tools revision 33.0.2 is corrupted. Remove and install again using the SDK Manager.</p>\n<p>解决：</p>\n<p>换一个SDK，然后找到1所示的文件，点开这个文件，将2所示部分改成你换的SDK版本<br />\n<img src=\"http://ruizmypmv.hn-bkt.clouddn.com/ffbe86b7-24da-422b-9fd6-291e5cdc1c07.png\" alt=\"2974068202305081311043841237473638.png\" /><br />\n修改完成之后在最上边会出现这样一行字，点击 Sync Now 即可</p>\n', 1658828931769417730);
INSERT INTO `ms_article_body` VALUES (1658829123264561155, '## 下载\n去官网下载即可，最新版如果运行不了，可选择安装其他版本，我安装的就是4.0版本\n\n## 建立项目\n一般就是建立一个空项目\n\n如果使用过idea，那么建立项目就很简单。因为Android Studio和 idea 界面都差不多，功能也类似\n\n## 步骤：\n\nFile——New——New Project 会出现以下画面：\n![2974068202305081253064241517829720.png](http://ruizmypmv.hn-bkt.clouddn.com/dfd95f20-03c9-4584-aa0b-f03b6b9211a7.png)\n然后选择 Empty Activity 再点击 Next，然后将工程命名，选择保存路径，最后点击Finish即可。\n![2974068202305081258204661270871556.png](http://ruizmypmv.hn-bkt.clouddn.com/9935bfbc-8808-43e5-9d01-acc8d55b8d7f.png)\n解决报错\n加载工程时出现这个错误：\nInstalled Build Tools revision 33.0.2 is corrupted. Remove and install again using the SDK Manager.\n\n解决：\n\n换一个SDK，然后找到1所示的文件，点开这个文件，将2所示部分改成你换的SDK版本\n![2974068202305081311043841237473638.png](http://ruizmypmv.hn-bkt.clouddn.com/ffbe86b7-24da-422b-9fd6-291e5cdc1c07.png)\n 修改完成之后在最上边会出现这样一行字，点击 Sync Now 即可', '<h2><a id=\"_0\"></a>下载</h2>\n<p>去官网下载即可，最新版如果运行不了，可选择安装其他版本，我安装的就是4.0版本</p>\n<h2><a id=\"_3\"></a>建立项目</h2>\n<p>一般就是建立一个空项目</p>\n<p>如果使用过idea，那么建立项目就很简单。因为Android Studio和 idea 界面都差不多，功能也类似</p>\n<h2><a id=\"_8\"></a>步骤：</h2>\n<p>File——New——New Project 会出现以下画面：<br />\n<img src=\"http://ruizmypmv.hn-bkt.clouddn.com/dfd95f20-03c9-4584-aa0b-f03b6b9211a7.png\" alt=\"2974068202305081253064241517829720.png\" /><br />\n然后选择 Empty Activity 再点击 Next，然后将工程命名，选择保存路径，最后点击Finish即可。<br />\n<img src=\"http://ruizmypmv.hn-bkt.clouddn.com/9935bfbc-8808-43e5-9d01-acc8d55b8d7f.png\" alt=\"2974068202305081258204661270871556.png\" /><br />\n解决报错<br />\n加载工程时出现这个错误：<br />\nInstalled Build Tools revision 33.0.2 is corrupted. Remove and install again using the SDK Manager.</p>\n<p>解决：</p>\n<p>换一个SDK，然后找到1所示的文件，点开这个文件，将2所示部分改成你换的SDK版本<br />\n<img src=\"http://ruizmypmv.hn-bkt.clouddn.com/ffbe86b7-24da-422b-9fd6-291e5cdc1c07.png\" alt=\"2974068202305081311043841237473638.png\" /><br />\n修改完成之后在最上边会出现这样一行字，点击 Sync Now 即可</p>\n', 1658828931769417730);
INSERT INTO `ms_article_body` VALUES (1658830019876732930, '# Vue\n- Vue是一套前端框架，免除原生Javascript中的DOM操作，简化书写。\n- 基于MVVM(Model-View-WiewModel)思想，实现数据的双向绑定，将编程的关注点放在数据上\n- 官网：<https://cn.vue.js.org>    \n**MVC：只能实现模型到视图的单项展示**    \n**MVVM：实现数据的双向绑定**     \n\n## 快速入门  \n1. 新建HTML页面，引入Vue.js文件\n2. 在js代码区域，创建Vue核心对象，进行数据绑定\n3. 编写视图\n\n## vue常用指令\n- 指令：html标签上带有v-前缀的特殊属性，不同指令具有不同含义。例如v-if,v-for。。。\n- 常用指令   \n\n|  指令    |  作用                                        |\n|--------  | -----------------------------------------   |\n|v-bind    |为HTML标签绑定属性值，如设置href，css样式等    |\n|v-model   |在表单元素上创建双向数据绑定                   |\n|v-on      |为HTML标签绑定事件                            | \n|v-if      |条件性的渲染某元素，判定为true时渲染，否则不渲染|\n|v-else    |  |\n|v-else-if |  |\n|v-show    |根据条件展示某元素，区别在于切换的是display属性的值|\n|v-for     |列表渲染，遍历容器的元素或者对象的属性  |\n\n## vue生命周期\n- 生命周期的八个阶段：每触发一个生命周期事件，会自动执行一个生命周期方法（**勾子**）    \n|状态          |阶段周期    |\n|---------     |-----------|\n|beforeCreate  |创建前     |\n|create        |创建后     | \n|beforeMount   |载入前     |\n|mounted       |挂载完成   |\n|beforeUpdate  |更新前     |\n|update        |更新后     |\n|beforeDestroy |销毁前     |\n|destroy       |销毁后     |   \n\n \n![vue生命周期.png](./img/vue生命周期.png)  \n- **mounted** :挂载完成，Vue初始化成功，HTML页面渲染成功\n- - 发送异步请求，加载数据  \n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Title</title>\n    <script type=\"text/javascript\" src=\"js/vue.js\"></script>\n</head>\n<body>\n<div id=\"app\">\n\n    <div v-for=\"addr in addrs\">\n        {{addr}}<br>\n    </div>\n\n    <div v-for=\"(addr,i) in addrs\">\n        {{i+1}}.{{addr}}<br>\n    </div>\n</div>\n\n\n<script>\n\n    //创建vue的核心对象\n    new Vue({\n        el: \"#app\",\n        data() {\n            return {\n                username: \"\",\n                url: \"https://www.baidu.com\",\n                count: 3,\n                addrs:[\"江西\",\"上海\",\"北京\",\"广州\",\"武汉\"]\n            }\n        },\n        //注意有s\n        methods: {\n            show() {\n                alert(\"被点了\")\n            }\n        },\n        mounted(){\n            alert(\"加载完成\")\n        }\n\n    });\n\n</script>\n\n</body>\n</html>\n```', '<h1><a id=\"Vue_0\"></a>Vue</h1>\n<ul>\n<li>Vue是一套前端框架，免除原生Javascript中的DOM操作，简化书写。</li>\n<li>基于MVVM(Model-View-WiewModel)思想，实现数据的双向绑定，将编程的关注点放在数据上</li>\n<li>官网：<a href=\"https://cn.vue.js.org\" target=\"_blank\">https://cn.vue.js.org</a><br />\n<strong>MVC：只能实现模型到视图的单项展示</strong><br />\n<strong>MVVM：实现数据的双向绑定</strong></li>\n</ul>\n<h2><a id=\"_7\"></a>快速入门</h2>\n<ol>\n<li>新建HTML页面，引入Vue.js文件</li>\n<li>在js代码区域，创建Vue核心对象，进行数据绑定</li>\n<li>编写视图</li>\n</ol>\n<h2><a id=\"vue_12\"></a>vue常用指令</h2>\n<ul>\n<li>指令：html标签上带有v-前缀的特殊属性，不同指令具有不同含义。例如v-if,v-for。。。</li>\n<li>常用指令</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>指令</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>v-bind</td>\n<td>为HTML标签绑定属性值，如设置href，css样式等</td>\n</tr>\n<tr>\n<td>v-model</td>\n<td>在表单元素上创建双向数据绑定</td>\n</tr>\n<tr>\n<td>v-on</td>\n<td>为HTML标签绑定事件</td>\n</tr>\n<tr>\n<td>v-if</td>\n<td>条件性的渲染某元素，判定为true时渲染，否则不渲染</td>\n</tr>\n<tr>\n<td>v-else</td>\n<td></td>\n</tr>\n<tr>\n<td>v-else-if</td>\n<td></td>\n</tr>\n<tr>\n<td>v-show</td>\n<td>根据条件展示某元素，区别在于切换的是display属性的值</td>\n</tr>\n<tr>\n<td>v-for</td>\n<td>列表渲染，遍历容器的元素或者对象的属性</td>\n</tr>\n</tbody>\n</table>\n<h2><a id=\"vue_27\"></a>vue生命周期</h2>\n<ul>\n<li>生命周期的八个阶段：每触发一个生命周期事件，会自动执行一个生命周期方法（<strong>勾子</strong>）<br />\n|状态          |阶段周期    |<br />\n|---------     |-----------|<br />\n|beforeCreate  |创建前     |<br />\n|create        |创建后     |<br />\n|beforeMount   |载入前     |<br />\n|mounted       |挂载完成   |<br />\n|beforeUpdate  |更新前     |<br />\n|update        |更新后     |<br />\n|beforeDestroy |销毁前     |<br />\n|destroy       |销毁后     |</li>\n</ul>\n<p><img src=\"./img/vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png\" alt=\"vue生命周期.png\" /></p>\n<ul>\n<li><strong>mounted</strong> :挂载完成，Vue初始化成功，HTML页面渲染成功</li>\n<li>\n<ul>\n<li>发送异步请求，加载数据</li>\n</ul>\n</li>\n</ul>\n<pre><div class=\"hljs\"><code class=\"lang-html\"><span class=\"hljs-meta\">&lt;!DOCTYPE html&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">html</span> <span class=\"hljs-attr\">lang</span>=<span class=\"hljs-string\">\"en\"</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">head</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">charset</span>=<span class=\"hljs-string\">\"UTF-8\"</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">title</span>&gt;</span>Title<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">title</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"text/javascript\"</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">\"js/vue.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">head</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">body</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"app\"</span>&gt;</span>\n\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">v-for</span>=<span class=\"hljs-string\">\"addr in addrs\"</span>&gt;</span>\n        {{addr}}<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">br</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">v-for</span>=<span class=\"hljs-string\">\"(addr,i) in addrs\"</span>&gt;</span>\n        {{i+1}}.{{addr}}<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">br</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"javascript\">\n\n    <span class=\"hljs-comment\">//创建vue的核心对象</span>\n    <span class=\"hljs-keyword\">new</span> Vue({\n        <span class=\"hljs-attr\">el</span>: <span class=\"hljs-string\">\"#app\"</span>,\n        data() {\n            <span class=\"hljs-keyword\">return</span> {\n                <span class=\"hljs-attr\">username</span>: <span class=\"hljs-string\">\"\"</span>,\n                <span class=\"hljs-attr\">url</span>: <span class=\"hljs-string\">\"https://www.baidu.com\"</span>,\n                <span class=\"hljs-attr\">count</span>: <span class=\"hljs-number\">3</span>,\n                <span class=\"hljs-attr\">addrs</span>:[<span class=\"hljs-string\">\"江西\"</span>,<span class=\"hljs-string\">\"上海\"</span>,<span class=\"hljs-string\">\"北京\"</span>,<span class=\"hljs-string\">\"广州\"</span>,<span class=\"hljs-string\">\"武汉\"</span>]\n            }\n        },\n        <span class=\"hljs-comment\">//注意有s</span>\n        methods: {\n            show() {\n                alert(<span class=\"hljs-string\">\"被点了\"</span>)\n            }\n        },\n        mounted(){\n            alert(<span class=\"hljs-string\">\"加载完成\"</span>)\n        }\n\n    });\n\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">body</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">html</span>&gt;</span>\n</code></div></pre>\n', 1658830019813818369);
INSERT INTO `ms_article_body` VALUES (1659724222093688833, '## AIDS发货\n![8cb1cb13495409237b1ca7f59858d109b2de49c0.png](http://ruizmypmv.hn-bkt.clouddn.com/1e009d8d-9364-4160-bba6-fb5b4a55cf16.png)', '<h2><a id=\"AIDS_0\"></a>AIDS发货</h2>\n<p><img src=\"http://ruizmypmv.hn-bkt.clouddn.com/1e009d8d-9364-4160-bba6-fb5b4a55cf16.png\" alt=\"8cb1cb13495409237b1ca7f59858d109b2de49c0.png\" /></p>\n', 1659724221955276802);

-- ----------------------------
-- Table structure for ms_article_tag
-- ----------------------------
DROP TABLE IF EXISTS `ms_article_tag`;
CREATE TABLE `ms_article_tag`  (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `article_id` bigint(20) NOT NULL,
  `tag_id` bigint(20) NOT NULL,
  PRIMARY KEY (`id`) USING BTREE,
  INDEX `article_id`(`article_id`) USING BTREE,
  INDEX `tag_id`(`tag_id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 1659724222026579971 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of ms_article_tag
-- ----------------------------
INSERT INTO `ms_article_tag` VALUES (1, 1, 7);
INSERT INTO `ms_article_tag` VALUES (2, 1, 5);
INSERT INTO `ms_article_tag` VALUES (3, 1, 8);
INSERT INTO `ms_article_tag` VALUES (4, 9, 7);
INSERT INTO `ms_article_tag` VALUES (5, 10, 7);
INSERT INTO `ms_article_tag` VALUES (6, 10, 8);
INSERT INTO `ms_article_tag` VALUES (7, 10, 5);
INSERT INTO `ms_article_tag` VALUES (8, 10, 6);
INSERT INTO `ms_article_tag` VALUES (1405916999787233281, 1405916999732707330, 5);
INSERT INTO `ms_article_tag` VALUES (1622156649072435202, 1622156649005326338, 5);
INSERT INTO `ms_article_tag` VALUES (1622157820864503809, 1622157820797394946, 5);
INSERT INTO `ms_article_tag` VALUES (1658757309888839682, 1658757309691707394, 18);
INSERT INTO `ms_article_tag` VALUES (1658759520274464771, 1658759520274464770, 18);
INSERT INTO `ms_article_tag` VALUES (1658761194200219650, 1658761194200219649, 19);
INSERT INTO `ms_article_tag` VALUES (1658761730257436673, 1658761730190327810, 19);
INSERT INTO `ms_article_tag` VALUES (1658763647582846977, 1658763647515738114, 18);
INSERT INTO `ms_article_tag` VALUES (1658764793571557377, 1658764793500254210, 8);
INSERT INTO `ms_article_tag` VALUES (1658766617301073921, 1658766617233965058, 18);
INSERT INTO `ms_article_tag` VALUES (1658768565131657218, 1658768565064548353, 18);
INSERT INTO `ms_article_tag` VALUES (1658770056324169730, 1658770056324169729, 18);
INSERT INTO `ms_article_tag` VALUES (1658772080956653570, 1658772080889544706, 11);
INSERT INTO `ms_article_tag` VALUES (1658774222585053187, 1658774222585053186, 15);
INSERT INTO `ms_article_tag` VALUES (1658776284639117315, 1658776284639117314, 23);
INSERT INTO `ms_article_tag` VALUES (1658781189735038978, 1658781189672124417, 23);
INSERT INTO `ms_article_tag` VALUES (1658806949535399937, 1658806949472485377, 16);
INSERT INTO `ms_article_tag` VALUES (1658816190316920834, 1658816190316920833, 18);
INSERT INTO `ms_article_tag` VALUES (1658818233379176451, 1658818233379176450, 16);
INSERT INTO `ms_article_tag` VALUES (1658819577318064130, 1658819577250955265, 21);
INSERT INTO `ms_article_tag` VALUES (1658819789432406018, 1658819789432406017, 21);
INSERT INTO `ms_article_tag` VALUES (1658820077463650307, 1658820077463650306, 18);
INSERT INTO `ms_article_tag` VALUES (1658820246859005954, 1658820246859005953, 23);
INSERT INTO `ms_article_tag` VALUES (1658820406947201027, 1658820406947201026, 27);
INSERT INTO `ms_article_tag` VALUES (1658820724778975233, 1658820724711866370, 5);
INSERT INTO `ms_article_tag` VALUES (1658821020133474306, 1658821020066365442, 5);
INSERT INTO `ms_article_tag` VALUES (1658821135468445699, 1658821135468445698, 5);
INSERT INTO `ms_article_tag` VALUES (1658822003743899650, 1658822003743899649, 28);
INSERT INTO `ms_article_tag` VALUES (1658822244262068226, 1658822244211736578, 28);
INSERT INTO `ms_article_tag` VALUES (1658822614287761410, 1658822614287761409, 26);
INSERT INTO `ms_article_tag` VALUES (1658822869255307266, 1658822869255307265, 15);
INSERT INTO `ms_article_tag` VALUES (1658822996493713411, 1658822996493713410, 15);
INSERT INTO `ms_article_tag` VALUES (1658823734083043331, 1658823734083043330, 27);
INSERT INTO `ms_article_tag` VALUES (1658824196156932098, 1658824196089823234, 27);
INSERT INTO `ms_article_tag` VALUES (1658826393972228099, 1658826393972228098, 22);
INSERT INTO `ms_article_tag` VALUES (1658827199270207490, 1658827199270207489, 26);
INSERT INTO `ms_article_tag` VALUES (1658827734819913730, 1658827734752804866, 26);
INSERT INTO `ms_article_tag` VALUES (1658829123264561154, 1658828931769417730, 29);
INSERT INTO `ms_article_tag` VALUES (1658830019813818370, 1658830019813818369, 8);
INSERT INTO `ms_article_tag` VALUES (1659724222026579970, 1659724221955276802, 5);
INSERT INTO `ms_article_tag` VALUES (1659724222026579971, 1659724221955276802, 6);

-- ----------------------------
-- Table structure for ms_category
-- ----------------------------
DROP TABLE IF EXISTS `ms_category`;
CREATE TABLE `ms_category`  (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `avatar` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NULL DEFAULT NULL,
  `category_name` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NULL DEFAULT NULL,
  `description` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NULL DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 17 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of ms_category
-- ----------------------------
INSERT INTO `ms_category` VALUES (1, 'http://ruizmypmv.hn-bkt.clouddn.com/1683863378376a01312d86b8745619e2ed0075d1c1635.png', '前端', '前端是什么，大前端');
INSERT INTO `ms_category` VALUES (2, 'http://ruizmypmv.hn-bkt.clouddn.com/1683863600918下载.jfif', '后端', '后端最牛叉');
INSERT INTO `ms_category` VALUES (4, 'http://ruizmypmv.hn-bkt.clouddn.com/1683863575186下载.jfif', '数据库', '没数据库，啥也不管用');
INSERT INTO `ms_category` VALUES (7, 'http://ruizmypmv.hn-bkt.clouddn.com/1683863618038th.jfif', '算法', '算法改变世界');
INSERT INTO `ms_category` VALUES (12, 'http://ruizmypmv.hn-bkt.clouddn.com/1683863626783th.jfif', 'jvm', 'jvm牛牛牛');
INSERT INTO `ms_category` VALUES (13, 'http://ruizmypmv.hn-bkt.clouddn.com/1684293789846OIP.jpg', '软件设计', '软件设计');
INSERT INTO `ms_category` VALUES (14, 'http://ruizmypmv.hn-bkt.clouddn.com/1684293793018OIP.jpg', '移动端开发', '让科技跟随你');
INSERT INTO `ms_category` VALUES (15, 'http://ruizmypmv.hn-bkt.clouddn.com/1684293910617R.jpg', '软件工程', '实现高质量软件开发');
INSERT INTO `ms_category` VALUES (16, 'http://ruizmypmv.hn-bkt.clouddn.com/1684294136771ac6eddc451da81cbe39346945d66d01609243176.jpg', '操作系统', '改变世界');

-- ----------------------------
-- Table structure for ms_comment
-- ----------------------------
DROP TABLE IF EXISTS `ms_comment`;
CREATE TABLE `ms_comment`  (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `content` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL,
  `create_date` bigint(20) NOT NULL,
  `article_id` bigint(11) NOT NULL,
  `author_id` bigint(20) NOT NULL,
  `parent_id` bigint(20) NOT NULL,
  `to_uid` bigint(20) NOT NULL,
  `level` varchar(1) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
  PRIMARY KEY (`id`) USING BTREE,
  INDEX `article_id`(`article_id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 1659724257984348162 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of ms_comment
-- ----------------------------
INSERT INTO `ms_comment` VALUES (1658756602276200450, '*安抚', 1684313366849, 1622157820797394946, 1658756096623493121, 0, 0, '1');
INSERT INTO `ms_comment` VALUES (1658759626436493313, '第一次写，有问题请指出', 1684314087872, 1658759520274464770, 1658756096623493121, 0, 0, '1');
INSERT INTO `ms_comment` VALUES (1658761278040162306, '欢迎指出问题', 1684314481648, 1658761194200219649, 1658759848361312257, 0, 0, '1');
INSERT INTO `ms_comment` VALUES (1659531644580663297, '*', 1684498151329, 1658827734752804866, 1658815292421292033, 0, 0, '1');
INSERT INTO `ms_comment` VALUES (1659608418907893762, '搜素送', 1684516455764, 1658824196089823234, 1, 0, 0, '1');
INSERT INTO `ms_comment` VALUES (1659608607496384514, '安安', 1684516500732, 1658824196089823234, 1, 1659608418907893762, 1, '2');
INSERT INTO `ms_comment` VALUES (1659609738633064450, '222', 1684516770406, 1658824196089823234, 1, 0, 0, '1');
INSERT INTO `ms_comment` VALUES (1659609788889214977, '333', 1684516782394, 1658824196089823234, 1, 1659608418907893762, 1, '2');
INSERT INTO `ms_comment` VALUES (1659724257984348162, '撒大苏打', 1684544073954, 1659724221955276802, 1, 0, 0, '1');

-- ----------------------------
-- Table structure for ms_feedback
-- ----------------------------
DROP TABLE IF EXISTS `ms_feedback`;
CREATE TABLE `ms_feedback`  (
  `id` int(8) NOT NULL AUTO_INCREMENT,
  `user_id` bigint(20) NULL DEFAULT NULL,
  `content` longtext CHARACTER SET utf8 COLLATE utf8_general_ci NULL,
  `create_date` bigint(20) NULL DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 4 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of ms_feedback
-- ----------------------------
INSERT INTO `ms_feedback` VALUES (1, 1, '为啥图片显示不出来', 1680267842570);
INSERT INTO `ms_feedback` VALUES (2, 1, '操作不灵敏', 1680267842570);
INSERT INTO `ms_feedback` VALUES (3, 1, '广告太多了', 1680271722654);

-- ----------------------------
-- Table structure for ms_follow
-- ----------------------------
DROP TABLE IF EXISTS `ms_follow`;
CREATE TABLE `ms_follow`  (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `user_id` bigint(20) NOT NULL,
  `follow_user_id` bigint(20) NOT NULL,
  `create_time` bigint(20) NULL DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 1659614165284728834 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of ms_follow
-- ----------------------------
INSERT INTO `ms_follow` VALUES (1658756197433589761, 1658756096623493121, 1, 1684313270326);
INSERT INTO `ms_follow` VALUES (1658759934310989825, 1658759848361312257, 1658756096623493121, 1684314161278);
INSERT INTO `ms_follow` VALUES (1658764112605331457, 1658759848361312257, 1, 1684315157461);
INSERT INTO `ms_follow` VALUES (1658814008708415490, 1658756096623493121, 1658759848361312257, 1684327053614);
INSERT INTO `ms_follow` VALUES (1658816255332827137, 1658815292421292033, 1658756096623493121, 1684327589250);
INSERT INTO `ms_follow` VALUES (1659597281927671810, 1, 1658756096623493121, 1684513800493);

-- ----------------------------
-- Table structure for ms_permission
-- ----------------------------
DROP TABLE IF EXISTS `ms_permission`;
CREATE TABLE `ms_permission`  (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `name` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL,
  `path` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL,
  `description` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 14 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_unicode_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of ms_permission
-- ----------------------------
INSERT INTO `ms_permission` VALUES (1, '查询权限列表', '/admin/permission/permissionList', '查询权限列表');
INSERT INTO `ms_permission` VALUES (2, '11111', '11', '111');
INSERT INTO `ms_permission` VALUES (7, '1213', '123', '123');
INSERT INTO `ms_permission` VALUES (12, '阿迪斯', '大法', '放大');
INSERT INTO `ms_permission` VALUES (13, 'a', 'a', 'a');

-- ----------------------------
-- Table structure for ms_question
-- ----------------------------
DROP TABLE IF EXISTS `ms_question`;
CREATE TABLE `ms_question`  (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `question` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `user_id` bigint(20) NOT NULL,
  `create_date` bigint(20) NULL DEFAULT NULL,
  `status` int(2) NULL DEFAULT 0 COMMENT '状态 0表示没解决 1表示简介了',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 11 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of ms_question
-- ----------------------------
INSERT INTO `ms_question` VALUES (1, 'spring中bean的生命周期是什么', 1, 1680267113227, 0);
INSERT INTO `ms_question` VALUES (5, '前端学习路线是什么', 1, 1680267113227, 1);
INSERT INTO `ms_question` VALUES (8, 'resultType和resultMap区别 ', 1, 1681549464547, 0);
INSERT INTO `ms_question` VALUES (10, '为什么不能使用Executors创建线程池 ', 1, 1681549588124, 0);
INSERT INTO `ms_question` VALUES (11, '昨天面试遇到一个问题：&和&&的区别？', 1658815292421292033, 1684499564823, 0);

-- ----------------------------
-- Table structure for ms_sys_user
-- ----------------------------
DROP TABLE IF EXISTS `ms_sys_user`;
CREATE TABLE `ms_sys_user`  (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `account` varchar(64) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '账号',
  `admin` bit(1) NULL DEFAULT NULL COMMENT '是否管理员',
  `avatar` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '头像',
  `create_date` bigint(20) NULL DEFAULT NULL COMMENT '注册时间',
  `deleted` bit(1) NULL DEFAULT NULL COMMENT '是否删除',
  `email` varchar(128) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '邮箱',
  `last_login` bigint(20) NULL DEFAULT NULL COMMENT '最后登录时间',
  `nickname` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '昵称',
  `password` varchar(64) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '密码',
  `salt` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '加密盐',
  `status` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '状态',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 1659613843707441154 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of ms_sys_user
-- ----------------------------
INSERT INTO `ms_sys_user` VALUES (1, 'admin', b'0', 'http://ruizmypmv.hn-bkt.clouddn.com/my-image-1684292568177', 20210622223122, b'0', '2735901152@qq.com', 1674222298611, 'admin', '1c870464d28dcd9622556e6b1add7c3f', '12', '1');
INSERT INTO `ms_sys_user` VALUES (1621797555409121281, 'lhl', b'1', 'http://ruizmypmv.hn-bkt.clouddn.com/my-image-1683862533997', 1675501643402, b'0', '2735901152@qq.com', 1675501643402, 'lhl', '72b892a7534124e006b34bdbed0d139e', 'dragon!@#', '');
INSERT INTO `ms_sys_user` VALUES (1646152977632772097, 'yinyue', b'1', 'http://ruizmypmv.hn-bkt.clouddn.com/my-image-1683862533997', 1681308428571, b'1', '2735901152@qq.com', 1681308428571, 'yinyue', '72b892a7534124e006b34bdbed0d139e', 'dragon!@#', '');
INSERT INTO `ms_sys_user` VALUES (1646153791919144961, '李思思', b'1', 'http://ruizmypmv.hn-bkt.clouddn.com/my-image-1683862533997', 1681308622711, b'0', '2735901152@qq.com', 1681308622711, 'lss', '72b892a7534124e006b34bdbed0d139e', 'dragon!@#', '');
INSERT INTO `ms_sys_user` VALUES (1646173406938275841, '一只鱼', b'1', 'http://ruizmypmv.hn-bkt.clouddn.com/my-image-1683862533997', 1681313299301, b'0', '2735901152@qq.com', 1681313299301, 'fish', '72b892a7534124e006b34bdbed0d139e', 'dragon!@#', '');
INSERT INTO `ms_sys_user` VALUES (1658756096623493121, 'test1', b'1', 'http://ruizmypmv.hn-bkt.clouddn.com/my-image-1683862533997', 1684313246147, b'0', '2735901152@qq.com', 1684313246147, 'test1', '72b892a7534124e006b34bdbed0d139e', 'dragon!@#', '');
INSERT INTO `ms_sys_user` VALUES (1658759848361312257, 'test2', b'1', 'http://ruizmypmv.hn-bkt.clouddn.com/my-image-1683862533997', 1684314140781, b'0', 'liuhailong0914@outlook.com', 1684314140781, 'tset2', '72b892a7534124e006b34bdbed0d139e', 'dragon!@#', '');
INSERT INTO `ms_sys_user` VALUES (1658815292421292033, 'test3', b'1', 'http://ruizmypmv.hn-bkt.clouddn.com/my-image-1683862533997', 1684327359677, b'0', '2735901152@qq.com', 1684327359677, '小白', '72b892a7534124e006b34bdbed0d139e', 'dragon!@#', '');

-- ----------------------------
-- Table structure for ms_tag
-- ----------------------------
DROP TABLE IF EXISTS `ms_tag`;
CREATE TABLE `ms_tag`  (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `avatar` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NULL DEFAULT NULL,
  `tag_name` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NULL DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 29 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of ms_tag
-- ----------------------------
INSERT INTO `ms_tag` VALUES (5, 'http://ruizmypmv.hn-bkt.clouddn.com/1683863762100u=3351072256,4221370726&fm=253&fmt=auto&app=138&f=JPEG.webp', 'springboot');
INSERT INTO `ms_tag` VALUES (6, 'http://ruizmypmv.hn-bkt.clouddn.com/1683863765200u=3351072256,4221370726&fm=253&fmt=auto&app=138&f=JPEG.webp', 'spring');
INSERT INTO `ms_tag` VALUES (7, 'http://ruizmypmv.hn-bkt.clouddn.com/1683863770847u=3351072256,4221370726&fm=253&fmt=auto&app=138&f=JPEG.webp', 'springmvc');
INSERT INTO `ms_tag` VALUES (8, 'http://ruizmypmv.hn-bkt.clouddn.com/1683863775425u=3351072256,4221370726&fm=253&fmt=auto&app=138&f=JPEG.webp', 'vue');
INSERT INTO `ms_tag` VALUES (11, 'http://ruizmypmv.hn-bkt.clouddn.com/1683863780170a01312d86b8745619e2ed0075d1c1635.png', 'swagger1111');
INSERT INTO `ms_tag` VALUES (15, 'http://ruizmypmv.hn-bkt.clouddn.com/16842942901379e0306ba3e1d4774bc88e14b2534f1db.png', 'HTML/CSS/JS');
INSERT INTO `ms_tag` VALUES (16, 'http://ruizmypmv.hn-bkt.clouddn.com/16842942977099e0306ba3e1d4774bc88e14b2534f1db.png', 'jQuery');
INSERT INTO `ms_tag` VALUES (17, 'http://ruizmypmv.hn-bkt.clouddn.com/1684294363153111.png', 'Angular');
INSERT INTO `ms_tag` VALUES (18, 'http://ruizmypmv.hn-bkt.clouddn.com/1684294504570R (1).png', 'java');
INSERT INTO `ms_tag` VALUES (19, 'http://ruizmypmv.hn-bkt.clouddn.com/1684294595557R (2).png', '.net');
INSERT INTO `ms_tag` VALUES (20, 'http://ruizmypmv.hn-bkt.clouddn.com/1684294603296R (2).png', 'C++');
INSERT INTO `ms_tag` VALUES (21, 'http://ruizmypmv.hn-bkt.clouddn.com/1684294654907R (3).png', '设计模式');
INSERT INTO `ms_tag` VALUES (22, 'http://ruizmypmv.hn-bkt.clouddn.com/16842947520458cb1cb13495409237b1ca7f59858d109b2de49c0.png', '面向对象');
INSERT INTO `ms_tag` VALUES (23, 'http://ruizmypmv.hn-bkt.clouddn.com/1684294842883ac6eddc451da81cb037c289d5366d016082431c3.jpg', 'MySQL');
INSERT INTO `ms_tag` VALUES (24, 'http://ruizmypmv.hn-bkt.clouddn.com/1684312828147u=3097117616,3273644592&fm=253&fmt=auto&app=138&f=JPEG.webp', 'Oracle');
INSERT INTO `ms_tag` VALUES (25, 'http://ruizmypmv.hn-bkt.clouddn.com/1684312862672oracleanalyticscloud_11516_logo_1606733044_fqrte.png', 'Windows');
INSERT INTO `ms_tag` VALUES (26, 'http://ruizmypmv.hn-bkt.clouddn.com/1684312908650Windows-10-Outline-Blue-scaled.jpg', 'linux');
INSERT INTO `ms_tag` VALUES (27, 'http://ruizmypmv.hn-bkt.clouddn.com/1684312985605Linux-Logo.png', 'NoSQL');
INSERT INTO `ms_tag` VALUES (28, 'http://ruizmypmv.hn-bkt.clouddn.com/1684328854524OIP (1).jpg', 'MyBatis');
INSERT INTO `ms_tag` VALUES (29, 'http://ruizmypmv.hn-bkt.clouddn.com/1684330642369v2-0e0472f97e2262508d09093155ed1706_1440w.jpg', 'Android开发');

SET FOREIGN_KEY_CHECKS = 1;
